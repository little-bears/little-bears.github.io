<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 码农日志</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="码农日志" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">码农日志</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['天行健，君子以自强不息', '愿一生努力，无愧于心', '想要的都拥有，得不到的都释怀~'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="">
                <img src="" width="" alt="">
            </a>
        </li>
    
        <li>
            <a href="">
                <img src="" width="" alt="">
            </a>
        </li>
    
</ul>
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JS常用API（字符串、数组、对象、正则、日期）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/16/JS%E5%B8%B8%E7%94%A8API%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%97%A5%E6%9C%9F%EF%BC%89/"
    >JS常用API（字符串、数组、对象、正则、日期）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/01/16/JS%E5%B8%B8%E7%94%A8API%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%97%A5%E6%9C%9F%EF%BC%89/" class="article-date">
  <time datetime="2021-01-16T06:14:53.000Z" itemprop="datePublished">2021-01-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>JS中常用的API有字符串、数组、对象、正则与日期对象等。</p>
<h2 id="1、字符串（String）"><a href="#1、字符串（String）" class="headerlink" title="1、字符串（String）"></a>1、字符串（String）</h2><p>&emsp;&emsp;字符串，是由零个或多个字符组成的有限序列。在JavaScript中，字符串实例有字符串对象和基本字符串值的区别  ( 对于 Boolean 和Numbers 也同理)。字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。<u>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询</u></p>
<pre><code>  const str1 = &#39;abc&#39;; // 基本字符串实例
  const str2 = new String(&#39;abc&#39;); // 字符串对象实例
  console.log(str1);
  console.log(str2);
</code></pre>
<p>打印结果如下（_特殊的，可以看到基本字符串实例与字符串对象实例区别很大；其他对象如<u>数组</u>、<u>对象</u>等字面量定义与构造函数实例化区别并不大_）：</p>
<p><img src="/images/javascript/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89.png" alt="字符串（String）"></p>
<p>&emsp;&emsp;字符串String对象的属性：String.prototype（显式原型，允许您向对象添加属性和方法）<br>&emsp;&emsp;字符串String对象的方法：String.fromCharCode() （通过一串 Unicode 创建字符串）、String.raw()（通过模板字符串创建字符串）等<br>&emsp;&emsp;字符串实例对象的属性：String.prototype.constructor（构造函数，创建改对象的函数的引用）、String.prototype.length（字符串长度）、N（用于访问第N个位置的字符，‘只读’性质，不可编辑）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JS动画（时序函数、缓动函数、canvas粒子动画）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/02/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/"
    >JS动画（时序函数、缓动函数、canvas粒子动画）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/01/02/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/" class="article-date">
  <time datetime="2021-01-02T13:01:58.000Z" itemprop="datePublished">2021-01-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>CSS动画很强大，特别是CSS3动画。可以进行通过transition的2D/3D变换，以及改变高宽，方位，角度，透明度等，再结合transition过渡属性，能做到几乎完美。但CSS动画也有一些局限，比如不能设置浏览器相关的属性，如scrollTop等。且对于canvas等动画（以及粒子动画），还是要利用计时器（setTimeout/setInterval、requestAnimationFrame）通过JavaScript动态更新元素状态来实现。此外，canvas小游戏的逻辑实现也必须使用JavaScript去处理用户鼠标键盘等事件，才能完成对应的交互动画以及相应功能。JavaScript动画还可以沿着其他<strong>自定义时序函数</strong>的进行移动与变化。</p>
<h2 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h2><h4 id="1）setTimeout（setInterval）与requestAnimationFrame对比"><a href="#1）setTimeout（setInterval）与requestAnimationFrame对比" class="headerlink" title="1）setTimeout（setInterval）与requestAnimationFrame对比"></a>1）setTimeout（setInterval）与requestAnimationFrame对比</h4><p>&emsp;&emsp;(1)setTimeout/setInterval：</p>
<p>&emsp;&emsp;① 计时器的回调的执行时是在内存中对元素属性进行相应的改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上（一般为16.7ms刷新一次）。setTimeout的执行步调和屏幕的刷新步调不一致。就会导致中间某些帧的更新被跳过，照成动画卡顿。比如计时器设置10ms更新一次（帧），而屏幕刷新时间间隔为16.7ms，此时就会出现丢帧现象(即有的内存中元素状态的更新（帧）没来得及被浏览器渲染就被覆盖了)。其实只要计时器设置的更新时间小于16.7ms，就会导致丢帧。<br>&emsp;&emsp;② setTimeout/setInterval 放在异步队列里执行，主线程同步任务会阻塞异步队列的任务，设置的间隔时间不一定是回调执行的时间间隔。同样会造成动画卡顿（停顿）的现象。<br>&emsp;&emsp;③ 使用setTimeout等实现的动画，当页面被隐藏或最小化时，setTimeout仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画浪费 CPU 资源和电池寿命。</p>
<p>&emsp;&emsp;(2) requestAnimationFrame（标准动画时序，浏览器在下次重绘之前调用指定的回调函数来更新动画）：</p>
<p>&emsp;&emsp;① 与setTimeout等相比，requestAnimationFrame最大的优势是由浏览器来决定回调函数的执行时机，即紧跟浏览器的刷新步调，不会出现丢帧现象。<br>&emsp;&emsp;② 当页面处于未激活的状态下，该页面的屏幕绘制任务也会被浏览器暂停，跟着浏览器步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画才会恢复继续执行，有效节省了 CPU 资源与电池寿命。<br>&emsp;&emsp;③ 在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame 有节流的作用，可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。</p>
<p><em>&emsp;&emsp;[注] 通过对比，requestAnimationFrame 要比 setTimeout/setInterval 性能好。<u>特别的，requestAnimationFrame回调函数会被传入DOMHighResTimeStamp参数（一个double类型，用于存储毫秒级的时间值），DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳。</u></em></p>
<h4 id="2）JS动画中的时序函数"><a href="#2）JS动画中的时序函数" class="headerlink" title="2）JS动画中的时序函数"></a>2）JS动画中的时序函数</h4><p>&emsp;&emsp;<u>时序函数就是动画完成情况与时间的关系（一般时序函数的图像也是从（0,0）变化到（1,1），代表动画执行时间到达时动画刚好执行完成）。</u>在JS动画中我们可以更灵活的自定义这种关系，即定义更加多样的时序函数，例如n次幂等满足经过（0,0）变化到（1,1）的曲线都可以作为时序函数。</p>
<p>&emsp;&emsp;为了代码的结构以及代码的可复用，这里编写一个<u>通用的动画函数</u>，放在单独的animate.js文件中：（其中时序函数timing也作为参数传入）</p>
<pre><code>  // animate.js
  function animate(&#123; duration, timing, draw &#125;) &#123;
    let startTime = performance.now(); // 获得一个一个精确到毫秒的DOMHighResTimeStamp来标识动画开始时间
    requestAnimationFrame(function animate(executionTime) &#123; // executionTime为requestAnimationFrame的本次回调函数触发执行时间
      let time = (executionTime - startTime) / duration; // 计算当当前动画已经执行时间与动画延迟总时间的比值，
      // 其值为时序函数的x轴的值（为0代表动画开始执行，1代码动画执行结束）
      if (time &gt; 1) time = 1;
      let progress = timing(time) // 计算当前时间节点动画完成进度，其值为时序函数y轴的值
      draw(progress); // 根据当前动画完成进度更新动画
      if (time &lt; 1) &#123; // 动画未完成，继续更新
        requestAnimationFrame(animate);
      &#125;
    &#125;);
  &#125;
</code></pre>
<p>&emsp;&emsp;其中duration，timing，draw分别代码动画执行时间（ms）,时序函数，元素状态更新函数。首先调用performance.now()获取动画开始执行的精确时间，然后再根据当前动画执行的时间根据时序函数计算出当前动画应完成的状态，然后调用draw方法更新元素状态。动画若为完成，继续执行。</p>
<p>&emsp;&emsp;还是用 <a href="/2020/11/26/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/#CSS%E5%8A%A8%E7%94%BB">CSS动画</a> 中小球移动的示例，这里我们采用一个 y=Math.pow(2, 10 * (x - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * x) 的时序函数来定义动画，时序函数的图像为：</p>
<p><img src="/images/javascript/Js%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0.png" alt="Js自定义时序函数"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
  
    #ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/animate.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    document.getElementById(&quot;ball&quot;).onclick = function () &#123;
      animate(&#123;
        duration: 3000,
        timing: function (time) &#123;
          return Math.pow(2, 10 * (time - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * time)
        &#125;,
        draw: function (progress) &#123;
          document.getElementById(&quot;ball&quot;).style.marginLeft = 250 * progress + &#39;px&#39;;
        &#125;
      &#125;);
    &#125;;
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;动画效果：</p>
<p><img src="/images/javascript/Js%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB.gif" alt="Js时序动画"></p>
<p>&emsp;&emsp;先引入我们animate.js文件，给小球添加onclick点击事件，事件回调函数里为小球创建动画：动画时长3s，时序函数为我们自定义较为复杂的函数（这个时序函数不是CSS里的3次贝塞尔曲线函数，所以这个动画仅使用CSS无法完成），然后再是小球状态更新的方法，根据动画的完成状态向右移动小球直至移动250px，即到达外层div最右侧时动画完成。</p>
<h4 id="3-JS动画中的缓动函数"><a href="#3-JS动画中的缓动函数" class="headerlink" title="3) JS动画中的缓动函数"></a>3) JS动画中的缓动函数</h4><p>&emsp;&emsp;与时序函数类似，在JS动画中，我们可以也用缓动公式来控制每帧动画中个元素的状态，来实现各种动画效果。<u>缓动函数是根据元素状态的初始值、变化量、当前时间与动画总持续时间按照一定的变化规则来控制元素的状态，比时序函数更加灵活，在实际使用应用中也更加常用。</u>著名的缓动公式算法是Tween.js缓动算法。部分代码如下：</p>
<pre><code>  /*
  * Tween.js
  * t: current time（当前时间）；
  * b: beginning value（初始值）；
  * c: change in value（变化量）；
  * d: duration（持续时间）。
  */
  var Tween = &#123;
      Linear: function(t, b, c, d) &#123; 
          return c * t / d + b; 
      &#125;,
      Sine: &#123;
          easeIn: function(t, b, c, d) &#123;
              return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
          &#125;,
          easeOut: function(t, b, c, d) &#123;
              return c * Math.sin(t/d * (Math.PI/2)) + b;
          &#125;,
          easeInOut: function(t, b, c, d) &#123;
              return -c / 2 * (Math.cos(Math.PI * t/d) - 1) + b;
          &#125;
      &#125;
    // .....(其他代码省略）
  &#125;
  Math.tween = Tween;
  
  // 测试Tweem.js算法
  // 1、测试匀速运动
  console.log(&#39;1、匀速算法，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);
  console.log(Math.tween.Linear(5,0,100,10)); // 50
  // 2、测试正弦曲线
  console.log(&#39;2、测试正弦曲线，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);
  console.log(Math.tween.Sine.easeIn(5,0,100,10)); // 29.289321881345245
</code></pre>
<p>&emsp;&emsp;算法中的4个参数分别他，t，b，c，d分别表示动画执行到当前帧的时间，元素的初始状态，动画过程中元素状态的变化量以及动画持续时间。如后面添加的测试代码所示：有一个小球从0px的位置要移动到100px的位置，初始状态的坐标为0，坐标的变化量为100(100-0=100)，假设动画持续时间为10s，传入动画当前帧的时间5s，调用Tween.js的线性渐变算法就能得到当前小球应该处于50px的位置，调用正弦曲线算法能得到当前小球处于约29px的位置。从而以此来控制动画流畅的运动起来。</p>
<p>&emsp;&emsp;在Tween.js中，常用的经典动画场景都已实现，除了Linear，其余每种场景都有easeIn、easeOut和easeInOut方法，具体动画场景如下：<br>&emsp;&emsp;Linear：线性匀速运动效果；<br>&emsp;&emsp;Quadratic：二次方的缓动（t^2）；<br>&emsp;&emsp;Cubic：三次方的缓动（t^3）；<br>&emsp;&emsp;Quartic：四次方的缓动（t^4）；<br>&emsp;&emsp;Quintic：五次方的缓动（t^5）；<br>&emsp;&emsp;Sinusoidal：正弦曲线的缓动（sin(t)）；<br>&emsp;&emsp;Exponential：指数曲线的缓动（2^t）；<br>&emsp;&emsp;Circular：圆形曲线的缓动（sqrt(1-t^2)）；<br>&emsp;&emsp;Elastic：指数衰减的正弦曲线缓动；<br>&emsp;&emsp;Back：超过范围的三次方缓动（(s+1)<em>t^3 – s</em>t^2）；<br>&emsp;&emsp;Bounce：指数衰减的反弹缓动。</p>
<p>&emsp;&emsp;还是小球移动的例子，这里简单应用一下Tween.js的方法，代码如下：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
    #ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt; // 引入Tween.js文件
  &lt;script&gt;
    let duration = 3000;
    let startTime = performance.now(); // 动画持续时间
    let currentMarginLeft = 0;
    requestAnimationFrame(function update(executionTime) &#123;
      currentMarginLeft = Math.tween.Linear(executionTime, 0, 250, duration);  // 匀速线性变化
      // currentMarginLeft = Math.tween.Elastic.easeInOut(executionTime, 0, 250, duration); // 衰减的正弦曲线变化
      // currentMarginLeft = Math.tween.Bounce.easeOut(executionTime, 0, 250, duration); // 指数衰减反弹变化
      document.getElementById(&quot;ball&quot;).style.marginLeft = currentMarginLeft + &#39;px&#39;;
      if (executionTime &lt;= duration) &#123;
        requestAnimationFrame(update)
      &#125;
    &#125;);
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;分别采用匀速、衰减正弦曲线以及指数衰减反弹对小球的margin-left属性进行变化，动画效果依次为：<br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB1.gif" alt="Tween时序动画1"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB2.gif" alt="Tween时序动画2"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB3.gif" alt="Tween时序动画3"></p>
<h4 id="4-canvas粒子动画"><a href="#4-canvas粒子动画" class="headerlink" title="4) canvas粒子动画"></a>4) canvas粒子动画</h4><p>&emsp;&emsp;canvas元素以及基础的动画，已在另一篇文章<a href="/2020/09/15/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89">《HTML Canvas（2D时序动画）》</a>讲到，canvas画布的上下文ctx有对应的API可以调用，可以对相关元素进行旋转、缩放、位移、形变，也可以用martrix方式做更高级的变化。<u>canvas图像处理也可以用于图像压缩，图像裁剪，图像合成、图像滤镜、图像取色器、抠图等功能。</u>不过这里主要补充canvas粒子动画的实现：</p>
<p>&emsp;&emsp;canvas中的粒子，其实是对一个像素的抽象。它具有自己坐标，自己的色值，可以通过改变自身的属性使其按照一定的规律运动起来便可形成相应的粒子动画。<br>&emsp;&emsp;一般我们将粒子用一个对象抽象出来，形如：let particle = { x: 0, y: 0, rgba: ‘(0, 0, 0, 1)’ }，这个过程称为粒子对象化，实际制作粒子动画的过程是对这些粒子对象的属性（如位置，颜色等）进行相应的变化。<br>&emsp;&emsp;为了动画更加自然，我们一般不会采用匀速的变化，而是加入相应的时序函数来控制粒子运动效果，使粒子变化或快或慢，更加自然。<br>&emsp;&emsp;一般为了性能，我们不会把图像所有像素点都抽象出来，因为requestAnimationFrame，正常的情况下一般刷新频率在60HZ，能展现非常流畅的动画。但现在如果要处理庞大的粒子对象数据，浏览器处理压力太大，就会造成了降频现象，导致动画出现卡帧（卡顿）现象。一般我们选择性的来抽象粒子对象：抽象像素点r色值为155以上并且坐标为偶数的像素点；或隔一定距离（像素）后抽象一个像素块（横轴方向上连续多个像素组成）。这样抽象的粒子数量不会影响图像效果的展示，动画的处理过程来也比较流畅。</p>
<p>&emsp;&emsp;<strong>为了更好抽象粒子对象以及其色值信息，补充一个canvas图像滤镜处理的示例来引入<u>canvas像素图像信息</u>的概念：</strong></p>
<p>&emsp;&emsp;先介绍要用到的canvas的3个API：<br>&emsp;&emsp;① <strong>getImageData()</strong>：获得一个ImageData对象</p>
<pre><code>  ctx.getImageData(sx, sy, sw, sh); // 返回ImageData对象
</code></pre>
<p>&emsp;&emsp;ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：width、height、data，分别代表图片宽度(单位px)、高度(单位px)、像素数据（Uint8ClampedArray类型）。</p>
<p>&emsp;&emsp;其中data属性返回像素信息是一个 类型Uint8ClampedArray的一维数组。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份R的色值保存在数组的索引0位置。像素从左到右被处理，然后往下。Uint8ClampedArray  包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1，具体如下：</p>
<p><img src="/images/javascript/ImageData.png" alt="ImageData"></p>
<p>&emsp;&emsp;如图所示，ImgaeData的data属性保存了图片每个像素的RAGA色值信息。第一个像素点的色值RGBA分别保存在Uint8ClampedArray数组索引0到3的位置，第二个像素点的色值保存在数组索引4-7的位置，先行后列，以此类推…。能很容易得到第i行第j列像素点的色值R保存在数组索引 [(j - 1) * width + (i - 1) ] * 4的位置。若像素点色值R在数组的索引为index，则每个像素的位置(i, j)与index的关系为：index=[(j - 1) * width + (i - 1) ] * 4，色值G的索引为index+1，色值B的索引为index+2，透明度A的索引为index+3。 </p>
<p>&emsp;&emsp;② <strong>createImageData()</strong>：Canvas 2D API 创建一个新的、空白的、指定大小的 ImageData 对象。 所有的像素在新对象中都是透明的</p>
<pre><code>  ctx.createImageData(width, height); // 返回ImageData对象
  ctx.createImageData(imagedata); // 返回ImageData对象
</code></pre>
<p>&emsp;&emsp;③ <strong>putImageData()</strong>：Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法</p>
<pre><code>  ctx.putImageData(imagedata, dx, dy);
  ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
</code></pre>
<p>&emsp;&emsp;canvas图像滤镜处理效果：</p>
<p><img src="/images/javascript/canvas%E5%9B%BE%E5%83%8F%E6%BB%A4%E9%95%9C%E5%A4%84%E7%90%86.png" alt="canvas图像滤镜处理"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
  &lt;script&gt;
    const TYPE = &#39;grayscale&#39;; // grayscale - 灰度(默认)、sepia - 复古、inert - 反向
    let canvas = document.getElementById(&#39;canvas&#39;);
    let ctx = canvas.getContext(&#39;2d&#39;);
    const img = document.createElement(&#39;img&#39;);
    img.src = &#39;/img/filter.jpg&#39;;
    img.addEventListener(&#39;load&#39;, () =&gt; &#123;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0); // 将原图渲染到canvas画布上
      let originImage = ctx.getImageData(0, 0, canvas.width, canvas.height); // 获取图片像素信息
      let outputImage = filter(originImage, TYPE); // 按照滤镜风格处理像素信息
      ctx.putImageData(outputImage, 0, 0); // 将处理后的像素信息覆盖到canvas画布上
    &#125;)
    function filter(originImage, type) &#123; // 图像处理函数
      let index, r, g, b;
      let originImageData = originImage.data;
      let width = originImage.width;
      let height = originImage.height;
      let outputImage = ctx.createImageData(width, height);
      let outputImageData = outputImage.data;
      for (let x = 1; x &lt;= width; x++) &#123;
        for (let y = 1; y &lt;= height; y++) &#123;
          index = [(y - 1) * width + (x - 1)] * 4;
          r = originImageData[index];
          g = originImageData[index + 1];
          b = originImageData[index + 2];
          if (type == &#39;sepia&#39;) &#123; // 复古滤镜风格下对色值的处理
            outputImageData[index] = (r * 0.393) + (g * 0.769) + (b * 0.189);
            outputImageData[index + 1] = (r * 0.349) + (g * 0.686) + (b * 0.168);
            outputImageData[index + 2] = (r * 0.272) + (g * 0.534) + (b * 0.131);
          &#125; else if (type == &#39;inert&#39;) &#123; // 反向滤镜风格下对色值的处理
            outputImageData[index] = 255 - r;
            outputImageData[index + 1] = 255 - g;
            outputImageData[index + 2] = 255 - b;
          &#125; else &#123; // 灰度滤镜风格下对图像的处理
            outputImageData[index] = outputImageData[index + 1] = outputImageData[index + 2] = (r + g + b) / 3;
          &#125;
          outputImageData[index + 3] = 255;
        &#125;
      &#125;
      return outputImage;
    &#125;
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：思路就是先讲图片渲染到canvas画布上，再调用getImageData()方法获得canvas元素上的像素信息。根据滤镜风格分别对像素信息进行相应的处理，最后调用putImageData()方法将imageData对象渲染到canvas画布上即可。示例中我们已经获取到了画布上图像的像素信息，也以利用获取到的图片像素信息，监听鼠标指针相对于画布的水平垂直方向偏移的距离（px）获得当前鼠标指针指向的像素点的位置，可以做<u>图像取色器</u>等功能。</p>
<p>&emsp;&emsp;正式介绍<u>粒子动画</u>，先看效果：</p>
<p><img src="/images/javascript/Js%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB.gif" alt="Js粒子动画"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;canvas粒子动画&lt;/title&gt;
    &lt;style&gt;
      body &#123; background: midnightblue; margin: 0; padding: 0; &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;!-- 使用Tween.js缓动函数控制动画 --&gt;
    &lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let cw = document.documentElement.clientWidth;
      let ch = document.documentElement.clientHeight;
      let maxDelay = 0; // 保存粒子动画开始最长延时时间，用于动画完成介绍requestAnimationFrame动画回调
      let canvas = document.getElementById(&#39;canvas&#39;);
      let ctx = canvas.getContext(&#39;2d&#39;);
      const img = document.createElement(&#39;img&#39;);
      img.src = &#39;/img/canvas-img.jpg&#39;;
      img.addEventListener(&#39;load&#39;, () =&gt; &#123;
        canvas.width = cw;
        canvas.height = ch;
        console.log(cw, ch)
        let sx = (cw / 2) - (img.width / 2); // 把图片画在canvas(屏幕)中间
        ctx.drawImage(img, sx, 0, img.width, img.height);
        let originImage = ctx.getImageData(0, 0, cw, ch);
        let particles = dataToObject(originImage.data, originImage.width, originImage.height);
        draw(particles);
      &#125;)
  
      function dataToObject(imageData, width, height) &#123; // 粒子对象化函数
        let inx;
        let particle = &#123;&#125;;
        let particles = [];
        let threshold = 50; // 设置色值阈值，颜色较浅的像素不进行粒子对象化操作
        let delay = 0;
        for (let x = 1; x &lt;= width; x += 2) &#123;
          for (let y = 1; y &lt;= height; y += 2) &#123;
            inx = [(y - 1) * width + (x - 1)] * 4;
            if ((imageData[inx] + imageData[inx + 1] + imageData[inx + 2]) / 3 &gt; threshold) &#123;
              delay = Math.random() * 3000;
              maxDelay &lt; delay &amp;&amp; (maxDelay = delay)
              particle = &#123;
                x0: 100,
                y0: ch,
                x1: x - 1,
                y1: y - 1,
                delay: delay,
                rgba: `rgba($&#123;imageData[inx]&#125;, $&#123;imageData[inx + 1]&#125;, $&#123;imageData[inx + 2]&#125;, $&#123;imageData[inx + 3]&#125;)`
              &#125;;
              particles.push(particle);
            &#125;
          &#125;
        &#125;
        return particles;
      &#125;
      
      function draw(particles) &#123; //画图
        let duration = 5000; // 动画持续时间
        let particle, cur_x, cur_y, cur_time;
        let startTime = performance.now(); // 动画开始时间
        let AnimationFrameId = requestAnimationFrame(function update(executionTime) &#123; // 每帧更新画布
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0, len = particles.length; i &lt; len; i++) &#123;
            particle = particles[i]
            if (executionTime &gt; particle.delay + duration) &#123;
              ctx.fillStyle = particle.rgba;
              ctx.fillRect(particle.x1, particle.y1, 1, 1)
            &#125; else if (executionTime &gt; particle.delay) &#123;
              ctx.fillStyle = particle.rgba;
              cur_time = executionTime - particle.delay;
              cur_x = Math.tween.Elastic.easeInOut(cur_time, particle.x0, particle.x1 - particle.x0, duration);
              cur_y = Math.tween.Bounce.easeOut(cur_time, particle.y0, particle.y1 - particle.y0, duration);
              ctx.fillRect(cur_x, cur_y, 1, 1)
            &#125;
          &#125;
          if (executionTime &gt; maxDelay + duration) &#123;
            cancelAnimationFrame(AnimationFrameId);
          &#125;else&#123;
            AnimationFrameId = requestAnimationFrame(update)
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
<p>&emsp;&emsp;实现思路：使用drawImage()方法将图片对象先放在画布上，然后调用getImageData()获取图片的像素信息。<u>根据将像素信息，生成对象来表示每个像素点的信息，对象属性包括初始位置，结束位置（像素点在canvas画布中原本的位置），颜色等信息。</u>这里为了然动画效果更加自然协调，加入了动画开始延迟时间delay属性。然后根据Tween.js缓动函数对粒子从初始位置移动到对应的结束位置的状态进行控制，调用requestAnimationFrame()方法设置回调来对粒子对象的状态进行刷新，便形成了动画。<br><em>&emsp;&emsp;[注] 有时我们会加入阈值（如代码中设置的阈值threshold为50）、增加对象化像素点的间距（如代码中循环粒子对象化操作时循环步长为2）来减少生成的对象数量，从而减少浏览器每一帧的处理压力，使动画更加流畅自然。</em></p>
<p>&emsp;&emsp;代码中的dataToObject()函数完成的功能就是用对象去标识图像的像素信息，每个对象表示一个像素点，即我们所说的‘粒子’。<u>实际上，粒子动画并不是总要使用getImageData()去抽象图片的信息，然后生成粒子对象。有时我们会直接构造出粒子类，按照我们的需求生成粒子对象，然后根据一定的规则使粒子运动起来即可。粒子动画本质是canvas动画，还可以与鼠标等输入设备交互，作出像放烟花、炫彩小球、小球自由落体、碰撞等有趣的动画。</u></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JS异步操作以及流程控制（串行、并行）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/25/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/"
    >JS异步操作以及流程控制（串行、并行）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/25/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/" class="article-date">
  <time datetime="2020-12-25T07:59:04.000Z" itemprop="datePublished">2020-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Javascript语言的执行环境是”单线程”（single thread），单个脚本只能在一个线程上运行（主线程）。原因在于浏览器内核中JavaScript引擎中负责解释和执行JavaScript代码的主线程是唯一的，同一时间只能执行一件任务。在浏览器内核中，GUI 渲染线程与 JavaScript 引擎线程是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。所以如果JavaScript执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步。”同步模式”指一个任务等待前一个任务执行结束再执行，程序的执行顺序与任务的排列顺序（即与程序的编码顺序）是一致的、同步的；”异步模式”是每一个任务有一个或多个回调函数，一个任务不用等待前一个任务执行完成就便开始执行，当前一个任务执行完成后，不是执行后一个任务，而是执行被添加到待处理队列的前一个任务的回调函数，程序的执行顺序与任务的排列顺序是不一致的、异步的。（<u>此外，JS运行时还有宏任务、微任务、事件循环的概念。</u>）</p>
<h2 id="说在前面-进程（Process）与线程（Thread）"><a href="#说在前面-进程（Process）与线程（Thread）" class="headerlink" title="说在前面 - 进程（Process）与线程（Thread）"></a>说在前面 - 进程（Process）与线程（Thread）</h2><p>&emsp;&emsp;目前的操作系统都是多任务系统，操作系统接管了所有硬件资源并持有对硬件控制的最高权限。在操作系统中执行的程序，都以进程的方式运行在更低的权限中。所有的硬件资源，由操作系统根据进程的优先级以及进程的运行状况进行统一的调配，<u>即操作系统是以进程为单位去分配空间和执行的。</u></p>
<p><em>&emsp;&emsp;[注] 区分程序与进程：程序是一组指令集合，它本身没有任何运行的含义，它只是一个静态的实体，存储于磁盘之内的存储器中；当一个程序被操作系统执行时，会被载入内存并在逻辑上产生一个独立的实例，这就是进程。进程和程序并不是一 一对应的；一个程序有可能没有与之对应的进程(因为它没有执行),也有可能有多个进程与之对应(运行在几个不同的数据集上)。一个程序在运行时，至少有一个进程,一个进程至少有一个线程。</em></p>
<p>&emsp;&emsp;线程是操作系统进行任务调度的最小单元。<strong>线程存活于进程之中；同一个进程中的线程，共享一个虚拟内存空间，以及其中的资源；</strong>线程之间各自持有自己的线程 ID、当前指令的指针（PC）、寄存器集合以及栈。</p>
<p>&emsp;&emsp;<strong>就浏览器来说，浏览器在运行时是多进程的：</strong><br>&emsp;&emsp;Browser进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等<br>&emsp;&emsp;PU 进程：用于3D 绘制等<br>&emsp;&emsp;第三方插件进程：每种类型的插件对应一个进程，仅当使用该浏览器插件时才创建<br>&emsp;&emsp;浏览器渲染进程（浏览器内核）：每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</p>
<p>&emsp;&emsp;<strong>每个渲染进程（浏览器内核）又分为多个线程：</strong><br>&emsp;&emsp;GUI渲染线程：负责渲染浏览器界面，当界面需要重绘或由于某种操作引发回流时，该线程就会执行<br>&emsp;&emsp;JavaScript引擎线程：也称为JavaScript内核，负责处理Javascript脚本程序、解析Javascript脚本、运行代码等，例如 V8 引擎<br>&emsp;&emsp;事件触发线程：用来控制浏览器事件循环，当事件被触发时，该线程才会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理<br>&emsp;&emsp;定时触发器线程：setInterval与setTimeout所在线程（W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms）<br>&emsp;&emsp;异步http请求线程：在XMLHttpRequest连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行</p>
<p><em>&emsp;&emsp;[注] GUI 渲染线程与 JavaScript 引擎线程是互斥的。</em></p>
<h2 id="1、JS异步操作的几种方式"><a href="#1、JS异步操作的几种方式" class="headerlink" title="1、JS异步操作的几种方式"></a>1、JS异步操作的几种方式</h2><p>&emsp;&emsp;JavaScript中的任务分为同步任务和异步任务。<br>&emsp;&emsp;同步任务是那些没有被引擎挂起、<u>在主线程上排队执行的任务。</u>只有前一个任务执行完毕，才能执行后一个任务。<br>&emsp;&emsp;异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列（根据异步任务的类型，引擎实际上存在多个任务队列）的任务。只有引擎认为某个异步任务可以执行了，该任务（通常采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运。即异步任务不具有堵塞效应。<br>&emsp;&emsp;主线程会排队去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。<br>&emsp;&emsp;同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<br>&emsp;&emsp;异步操作的几种模式：回调函数、事件监听、发布/订阅模式、Generator 函数、Promise、async/await。</p>
<hr>
<p>&emsp;&emsp;<strong>由于在分析异步操时需要用到定时器来模拟异步操作，这里先补充定时器相关概念：</strong></p>
<p>&emsp;&emsp;JavaScript 提供定时执行代码的功能，叫做定时器，主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。<u>setTimeout()和setInterval()的运行机制，是将指定的代码移出本轮事件循环（即使设置延迟执行为0ms)，等到下一轮事件循环，再检查是否到了指定时间。如果到了，再将对应代码放入主线程进行执行；如果没到，就继续等待。</u></p>
<p>&emsp;&emsp;<u>setTimeout()</u>：用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，可以将该编号作为参数调用clearTimeout()方法来取消这个定时器。setTimeout()可以接收多个参数，第一个参数为回调函数或字符串代码，会在定时时间到达时执行，第二个参数为延迟执行的时间（单位ms），后面的参数列表会作为第一个参数回调函数的参数传入。<u>特别的，回调函数是如果是某一对象的方法，内部this指向是是全局环境的而不是定义所在的那个对象。</u></p>
<pre><code>  let id = setTimeout(func|code, delay, [a, b, c...]);
</code></pre>
<p>&emsp;&emsp;示例代码：</p>
<pre><code>  console.log(&#39;定时任务开始执行，&#39; + new Date())
  let id =  setTimeout((a,b,c) =&gt; &#123;
    console.log(&#39;定时任务执行完成，&#39;+ new Date() +&#39;，回调函数已开始执行&#39;);
    console.log(&#39;回调函数计算结果为：&#39;+ (a+b+c));
  &#125;,1000, 1,2,3)
</code></pre>
<p>&emsp;&emsp;<u>setInterval()</u>：setInterval()函数的用法与setTimeout()完全一致，区别仅仅在于setInterval()指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。特别的，指定的是<u>“开始执行”</u>之间的间隔，并不考虑每次任务执行本身所消耗的时间。实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 1000ms 执行一次，每次执行需要 500ms，那么第一次执行结束后等待500毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要1500毫秒，那么它结束后，下一次任务执行才会立即开始。</p>
<pre><code>  let count = 0; // 计时器，控制任务执行5次    
  console.log(new Date() + &#39;，延迟2s后开始执行定时任务~&#39;);
  let id = setInterval(() =&gt; &#123;
    let delay = Math.floor(Math.random() * 5 + 1) * 1000;
    console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务开始执行，需要&#39; + delay + &#39;ms才能完成&#39;)
    sleep(delay);
    console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务执行完成&#39;)
    count++;
    if (count == 5) &#123;
      clearInterval(id)
      console.log(&#39;任务已执行5次，结束定时器任务~&#39;);
    &#125;
  &#125;, 2000)
  function sleep(ms) &#123; //通过循环阻塞代码执行来模拟异步操作
    var start = Date.now();
    while ((Date.now() - start) &lt; ms) &#123; &#125;
  &#125;
  
  输出：
  Thu Nov 26 2020 13:13:39 GMT+0800 (中国标准时间)，延迟2s后开始执行定时任务~
  Thu Nov 26 2020 13:13:41 GMT+0800 (中国标准时间)，第1次任务开始执行，需要1000ms才能完成
  Thu Nov 26 2020 13:13:42 GMT+0800 (中国标准时间)，第1次任务执行完成
  Thu Nov 26 2020 13:13:43 GMT+0800 (中国标准时间)，第2次任务开始执行，需要4000ms才能完成
  Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第2次任务执行完成
  Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第3次任务开始执行，需要3000ms才能完成
  Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第3次任务执行完成
  Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第4次任务开始执行，需要3000ms才能完成
  Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第4次任务执行完成
  Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第5次任务开始执行，需要4000ms才能完成
  Thu Nov 26 2020 13:13:57 GMT+0800 (中国标准时间)，第5次任务执行完成
  任务已执行5次，结束定时器任务~
</code></pre>
<p>&emsp;&emsp;可以看到，第一次任务开始在13:13:41，需要执行1s，在13:13:42第一次任务就执行完成。由于设置的执行时间间隔是2s，等待1s后13:13:43才开始执行第二次任务。第二次任务需要执行4s，在13:13:47秒时第二次任务才执行完成；虽然设置的时间间隔为2s，但第二次任务执行时间大于设置的2s，第三次任务在第二次任务执行完后才开始执行。后面的任务执行情况同理。</p>
<p>&emsp;&emsp;注意，setTimeout()定时任务也会被阻塞：</p>
<pre><code>  console.log(new Date() + &#39;，延迟1s后开始执行定时任务~&#39;);
  setTimeout(() =&gt; &#123;
    console.log(new Date() + &#39;，延迟任务执行完成~&#39;)
  &#125;, 1000)
  sleep(2000);
  function sleep(ms) &#123; //通过循环阻塞代码执行来模拟异步操作
    var start = Date.now();
    console.log(&#39;当前sleep任务要执行&#39; + ms + &#39;ms&#39;)
    while ((Date.now() - start) &lt; ms) &#123; &#125;
  &#125;
  
  输出：
  Thu Nov 26 2020 13:34:00 GMT+0800 (中国标准时间)，延迟1s后开始执行定时任务~
  当前sleep任务要执行2000ms
  Thu Nov 26 2020 13:34:02 GMT+0800 (中国标准时间)，延迟任务执行完成~
</code></pre>
<p>&emsp;&emsp;可以看到在13:34:00时，setTimeout()的回调函数本应该延迟1s执行，但sleep操作要执行2s。导致setTimeout()回调函数在13:34:02时才被执行。</p>
<p>&emsp;&emsp;<strong>setTimeout()与setInterval()被阻塞，和定时器的运行机制有关。setTimeout和setInterval指定的回调函数，<u>必须等到本轮事件循环的所有同步任务都执行完</u>，才会被添加到主线程开始执行，而且此时的回调函数执行是同步的，只有回调函数执行完成，才会进行下一轮事件循环。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。<u>所以即使可以使用嵌套的setTimeout()来实现每两次任务执行之间有固定的间隔，也是有被阻塞的风险。</u></strong></p>
<hr>
<h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1) 回调函数"></a>1) 回调函数</h4><p>&emsp;&emsp;回调函数是指在开始执行的异步函数指定为参数的函数，回调函数不会立即被执行。当异步函数包含的异步操作执行完成时，再调用执行该回调函数。<u>回调函数是异步编程的最基本的方法。</u></p>
<p>&emsp;&emsp;将处理函数当做参数，在相关任务执行完成再调用执行，形如：</p>
<pre><code>  function f2(cb)&#123;
    // 相关代码
    cb()
  &#125;
  function f1()&#123;
    // 相关代码
  &#125;
  f2(f1);
</code></pre>
<p>&emsp;&emsp;下面模拟一个读取文件列表（3个文件）获取对应文件的总行数的示例，这里采用回调函数的方式进行依次读取（还有其他或更好的方式实现，这里只是为了用来说明回调函数）。</p>
<pre><code>  let fileLines = [];    
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      fileLines.push(lines)
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb();
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(&#39;代码执行完成，文件行数依次为：&#39;);
    console.log(fileLines)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  // 假设文件列表有3个文件，这里调用3次文件读取函数asyncFn()
  asyncFn(1, function () &#123;
    asyncFn(2, function () &#123;
      asyncFn(3, consoleResult)
    &#125;)
  &#125;)
  
  Mon Nov 30 2020 16:23:40 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 16:23:41 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 95
  Mon Nov 30 2020 16:23:42 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 88
  Mon Nov 30 2020 16:23:43 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 51
  代码执行完成，文件行数依次为：
  95,88,51
</code></pre>
<p>&emsp;&emsp;这里asyncFn()负责读取文件获取文件行数，里面使用了计时器来模拟异步操作，用随机数模拟获取的文件行数。假设文件列表只有3个文件，这里asyncFn()调用了3次，每次分别传入了一个函数，这个函数就是我们说的回调函数，在成功读取文件获得行数后立即被执行。第1个读取文件时，将读取第2个文件的任务放在了回调函数里，在第1个文件读取完成后，执行回调函数，开始了第2个文件的读取；同理，把读取第3个文件的任务放在了读取第2个文件的回调函数里，在第2个文件读取完成后，执行回调函数，第3个文件的读取开始执行。特别的，读取第3个文件的回调函数里放入了我们输出结果的函数consoleResult()，所以当第3个文件读取完成时，回调函数立即被执行，输出函数输出了依次读取的文件行数信息。这里为了使读取文件的顺序与fileLines数组保存的行数依次对应，在setTimeout()回调执行时执行了cb()回调函数。（关于异步操作的流程控制问题，后面会进行分析~）</p>
<p>&emsp;&emsp;<u>回调函数的比较好理解，就是在异步任务完成后，继续执行后续的任务，比较容易理解与实现。但回调函数的代码是高度耦合的，执行取决于代码的结构（代码顺序），特别是多个异步任务作为回调函数嵌套执行的时候（例如上面的代码，这种现象也成‘回调地狱’），代码比较分散，不利于阅读和维护。</u></p>
<h4 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2) 事件监听"></a>2) 事件监听</h4><p>&emsp;&emsp;采用事件驱动的形式，任务被执行不取决于代码结构，取决于相关联的事件是否发生。</p>
<p>&emsp;&emsp;形如：</p>
<pre><code>  eventSource.on(&#39;done&#39;,fn); // eventSource对象监听done事件，并添加fn后续处理函数
  eventSource.tigger(&#39;done&#39;); // eventSource触发done事件
</code></pre>
<p>&emsp;&emsp;还是上面的示例，这里采用jQuery的自定义事件。输出结果也完全一致：</p>
<pre><code>  let times = 0;
  let fileLines = [];
  $(document).on(&#39;done&#39;, doneFn) // 给document绑定done事件，若document的done事件发生，执行doneFn()处理函数
  function doneFn(event, lines)&#123;
    console.log(new Date() + &#39; 第&#39; + times + &#39;次读取文件完成，文件总行数为 &#39; + lines);
    fileLines.push(lines)
  &#125;
  function asyncFn() &#123;
    let id = setInterval(() =&gt; &#123;
      times++;
      if (times &lt;= 3) &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
        $(document).trigger(&#39;done&#39;, lines) // 触发document done事件发生，驱动doneFn()处理函数执行
      &#125; else &#123;
        clearInterval(id)
        console.log(&#39;代码执行完成，文件行数依次为：&#39;);
        console.log(fileLines)
      &#125;
    &#125;, 1000)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  asyncFn()
</code></pre>
<p>&emsp;&emsp;这里使用setInterval()来模拟3次读取文件任务，在第3次文件读取完成后清空计时器并输出结果。可以看到，在每次文件读取完成后，使用$(document).trigger(‘done’, lines)触发‘done’事件，通过事件监听器$(document).on(‘done’, doneFn)关联的doneFn()处理函数被执行。<u>其中，这里的document称为为事件源，‘done’称为为事件，‘on’称为事件监听器，doneFn()函数称为处理方法。</u></p>
<p>&emsp;&emsp;<u>事件驱动比较容易理解，就是在任务完成后继续触发后续任务的执行。可以绑定多个事件，每个事件可以指定多个回调函数，与回调函数相比，大大降低了代码的耦合度（但代码还是耦合的，绑定在同一个事件源上），有利于实现模块化。但事情驱动代码也较为分散，不利于阅读与维护。</u></p>
<h4 id="3-发布-订阅模式"><a href="#3-发布-订阅模式" class="headerlink" title="3) 发布/订阅模式"></a>3) 发布/订阅模式</h4><p>&emsp;&emsp;如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”一个信号，其他任务可以向信号中心“订阅”这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。</p>
<p>&emsp;&emsp;发布/订阅模式的性质与“事件监听”类似，但功能上优于事件监听的方式。因为可以通过查看“信号中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h4 id="4-Generator-函数（ES6新增）"><a href="#4-Generator-函数（ES6新增）" class="headerlink" title="4) Generator 函数（ES6新增）"></a>4) Generator 函数（<u>ES6新增</u>）</h4><p>&emsp;&emsp;Generator 函数是一直特殊的函数，最大特点就是可以交出函数的执行权（即暂停执行）。可以把理解成，Generator 函数是一个状态机，封装了多个内部状态。Generator 函数内部使用yield表达式定义内部状态，为了与普通函数区别，一般在function关键字与函数名直接添加‘*’（非必须，在函数内部使用yield的关键字这个函数就是 Generator 函数）来标识。<u>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的迭代对象。必须调用next方法依次对状态进行迭代（恢复代码执行），内部指针就从函数头部或上一次停下来的地方开始执行（暂停执行的地方），直到遇到下一个yield关键字定义的状态时又会停止执行。每次调用next()会返回本次迭代的结果对象，其中的value属性表示当前的内部状态（结果），done属性标识整个迭代对象的迭代是否完成。</u></p>
<p>&emsp;&emsp;举个简单例子：</p>
<pre><code>  function* gen() &#123;
    console.log(new Date() + &#39; status 1&#39;);
    yield &#39;status 1&#39;;
    console.log(new Date() + &#39; status 2&#39;);
    yield &#39;status 2&#39;;
    console.log(new Date() + &#39; status 3&#39;);
    yield &#39;status 3&#39;;
    console.log(new Date() + &#39; status 4&#39;);
    yield &#39;status 4&#39;;
    console.log(new Date() + &#39; status 5&#39;);
  &#125;
  let g = gen();
  let id = setInterval(() =&gt; &#123; // 用计时器进行迭代来模拟异步操作
    if(g.next().done)&#123;
      clearInterval(id);
      console.log(&#39;状态迭代完成~&#39;);
    &#125;
  &#125;, 1000)

  输出
  Mon Nov 30 2020 21:24:24 GMT+0800 (中国标准时间) status 1
  Mon Nov 30 2020 21:24:25 GMT+0800 (中国标准时间) status 2
  Mon Nov 30 2020 21:24:26 GMT+0800 (中国标准时间) status 3
  Mon Nov 30 2020 21:24:27 GMT+0800 (中国标准时间) status 4
  Mon Nov 30 2020 21:24:28 GMT+0800 (中国标准时间) status 5
  状态迭代完成~
</code></pre>
<p>&emsp;&emsp;用Generator函数来模拟上面异步读取文件行数示例的代码：（_[注] 这种实现方式并不是最优的，结合Promise来确定每次异步操作已执行完成再进行下一次迭代操作比这里简单使用计时器模拟更为合理；使用Thunk函数或者co函数库来实现状态自动迭代的流程管理更加优雅_）：</p>
<pre><code>  let fileLines = [];
  function readFile(inx) &#123;
    let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
    fileLines.push(lines)
    console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
  &#125;
  function* asyncFn() &#123;
    yield readFile(1);
    yield readFile(2);
    readFile(3);
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  let g = asyncFn();
  let id = setInterval(() =&gt; &#123; // 模拟异步
    if(g.next().done)&#123;
      clearInterval(id)
      console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
      console.log(fileLines)
    &#125;
  &#125;, 1000)
</code></pre>
<p>&emsp;&emsp;<u>Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即各个状态间的管理不方便）。不过使用thunk函数或者co函数库能够解决这个问题。</u></p>
<h4 id="5-Promise（ES6新增）"><a href="#5-Promise（ES6新增）" class="headerlink" title="5) Promise（ES6新增）"></a>5) Promise（<u>ES6新增</u>）</h4><p>&emsp;&emsp;promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。一个 promise 必然处于以下几种状态之一：pending（初始状态）、fulfilled（操作成功完成）、rejected（操作失败）。</p>
<p>&emsp;&emsp;<u>处理待定状态（pending）的 Promise 对象要么会通过一个值被成功执行（fulfilled），要么会通过一个原因或错误被拒绝（rejected）。当这些情况之一发生时，promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用。因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。</u></p>
<p>&emsp;&emsp;一般我们使用Promise()构造函数来创建一个新的 promise 对象，对还没有添加 promise 支持的函数进行封装使用。<u>在适当的时候，调用resolve()方法将新的promise 对象的pending状态改变为fulfilled状态，或者调用reject()将pending状态改变为rejected状态。</u>若不使用这两个静态方法，新的 promise 对象的状态仍为pending初始化状态。</p>
<p>&emsp;&emsp;<strong>Promise有一些静态方法：</strong></p>
<p>&emsp;&emsp;all()：所有promise对象都完成且都成功（fulfilled）时触发（执行then()分支），会把所有promise返回值的数组作为成功回调的返回值，顺序跟promise的顺序保持一致，任意一个promise失败（rejected）则立即触发该失败（执行catch分支），第一个触发失败的promise对象的错误信息将作为它的失败错误信息，<u>此时，其他的pending状态的promise还是会执行直至完成（promise开始执行后不能被取消）。Promise.all方法常被用于处理多个promise对象的状态集合。</u></p>
<p>&emsp;&emsp;allSettled() ：所有promise对象都完成(fulfilled/rejected)时触发（执行then()分支），返回一个promise结果对象的数组，顺序与promise的顺序保持一致。每个promise结果对象包含status属性（状态），value属性（fulfilled状态时返回值）以及reason属性（rejected状态时返回的失败原因）等属性。</p>
<p>&emsp;&emsp;any()：promise对象的集合中当其中的一个 promise 成功（fulfilled）触发，就返回那个成功的promise的值（执行then分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;race()：promise对象的集合中当其中的一个 promise 成功（fulfilled）或失败（rejected）时触发，成功就返回那个成功的promise的值（执行then分支），失败就返回那个失败promise失败的原因（执行catch分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;reject()：返回一个失败状态的Promise对象，并将给定的失败信息传递给对应的处理方法。</p>
<p>&emsp;&emsp;resolve()：返回一个成功状态的Promise对象，其中value为返回结果。</p>
<p>&emsp;&emsp;Promise异步读取文件行数示例的代码如下：</p>
<pre><code>  let filelines =[];
  function readFile(inx) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  readFile(1).then(res =&gt; &#123;
    filelines.push(res);
    return readFile(2);
  &#125;).then(res =&gt; &#123;
    filelines.push(res);
    return readFile(3);
  &#125;).then(res =&gt; &#123;
    filelines.push(res);
    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
    console.log(filelines);
  &#125;)
</code></pre>
<p>&emsp;&emsp;<u><strong>Promise处理异步（特别是处理一次性结果）十分方便，也支持链式的进行调用，是目前较好的异步编程方式。</strong>特别是结合Array对象相关的方法如map()、filter()等。不过Promise也有一定的缺点，一但创建便会执行，不能取消，也无法得知目前进展到哪一个阶段；如果不设置回调函数，Promise内部抛出的错误，不会反应到外部等问题。</u></p>
<p>&emsp;&emsp;例如上面的Promise处理代码可以结合Array.map()方法生成promise对象集合（数组），由Promise.all()去并行执行（流程控制相关概念见后文）：</p>
<pre><code>  function readFile(inx)&#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  Promise.all([1, 2, 3].map((item) =&gt; readFile(item))).then(list =&gt; &#123;
    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
    console.log(list)
  &#125;)
</code></pre>
<p>&emsp;&emsp;这两段代码相比，可以看到后面这段代码明显更加的简洁。更重要的是，前一种写法读取3个文件的任务需要3s时间才能完成，后一种并行执行写法只需要1s时间便可完成。</p>
<h4 id="5-async-await（ES7新增）"><a href="#5-async-await（ES7新增）" class="headerlink" title="5) async/await（ES7新增）"></a>5) async/await（<u>ES7新增</u>）</h4><p>&emsp;&emsp;async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。<br>&emsp;&emsp;async 函数是 Generator 函数的语法糖且async 函数自带执行器。async函数可能包含0个或者多个await表达式。<br>&emsp;&emsp;async函数一定会返回一个promise对象。如果一个async函数的返回值不是promise，那么它将会被隐式地包装在一个promise中。</p>
<p>&emsp;&emsp;await表达式会暂停整个async函数的执行进程并出让其控制权：<br>&emsp;&emsp;(1) 如果await后面是普通表达式， await 表达式的运算结果就是它等待的的结果。<br>&emsp;&emsp;(2) 如果await后面是promise对象，只有当其等待的promise的异步操作成功或失败之后才会恢复进程，promise的结果会被当作该await表达式的返回值，此时await会阻塞后面的代码执行。所以把await放在async函数内部，因为async 函数的调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。<br>&emsp;&emsp;(3) await 命令后面的 promise 运行结果如果可能是 rejected，此时async/await无法处理，一般要要把 await 命令放在 try…catch 代码块中。</p>
<p>&emsp;&emsp;async/await读取文件行数示例代码：</p>
<pre><code>  function readFile(inx) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  async function getLines()&#123;
    let line1 = await readFile(1); // 读取文件1
    let line2 = await readFile(2); // 读取文件2
    let line3 = await readFile(3); // 读取文件3
    console.log(new Date() + &#39; 代码执行完成，结果为：&#39; + [line1, line2, line3])
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  getLines();
</code></pre>
<p>&emsp;&emsp;async/await的优点：<br>&emsp;&emsp;它做到了真正的串行的同步写法，代码阅读相对容易。<br>&emsp;&emsp;对于条件语句和其他流程语句比较友好，可以将await直接写到判断条件里。<br>&emsp;&emsp;处理复杂流程时，在代码更加清晰简洁（无try {} catch (err) {}的情况下）。</p>
<p>&emsp;&emsp;async/await的缺点：<br>&emsp;&emsp;<u>无法处理promise返回的reject对象，要借助try…catch…。</u><br>&emsp;&emsp;<strong>await只能串行，做不到并行（因为await一定是阻塞的）等。</strong></p>
<h2 id="2、异步操作流程控制"><a href="#2、异步操作流程控制" class="headerlink" title="2、异步操作流程控制"></a>2、异步操作流程控制</h2><p>&emsp;&emsp;如果有多个异步操作，为了代码的执行效率与可维护性，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。<br>&emsp;&emsp;流程控制一般有串行执行、并行执行等方式。<br>&emsp;&emsp;串行执行：一个异步任务执行完成后在执行下一个任务。（上面异步读取文件行数的示例中，Promise处理中的第2种写法以及async/await的写法。其他全是串行执行的）<br>&emsp;&emsp;并行执行：所有异步任务同时执行（并行非并发）。（例如上面Promise处理中的第2种写法以及async/await的写法）</p>
<p>&emsp;&emsp;例如读取文件异步操作回调函数的写法：</p>
<pre><code>  // 其他代码省略
  asyncFn(1, function () &#123;
    asyncFn(2, function () &#123;
      asyncFn(3, consoleResult)
    &#125;)
  &#125;)
</code></pre>
<p>&emsp;&emsp;这段代码虽然也是串行执行的，但多次嵌套，不利于阅读与维护。我们编写一个流程控制函数来控制异步操作串行执行，代码如下：</p>
<pre><code>  let fileList = [1, 2, 3];
  let fileLines = [];
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb(lines)
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(&#39;代码执行完成，文件行数依次为：&#39;);
    console.log(fileLines)
  &#125;
  function series(item) &#123;
    if (item) &#123;
      asyncFn(item, function (lines) &#123;
        fileLines.push(lines)
        return series(fileList.shift());
      &#125;);
    &#125; else &#123;
      return consoleResult();
    &#125;
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  series(fileList.shift());

  输出
  Mon Nov 30 2020 21:48:41 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 21:48:42 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65
  Mon Nov 30 2020 21:48:43 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 70
  Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 70
  Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,70,70
</code></pre>
<p>&emsp;&emsp;上面的代码中，series为流程控制函数。每次读取一个文件，并将文件名从待读取文件f列表ileList中删除。再递归调用读取下一个文件，直至待读取文件列表为空则所有文件读取完成。这里串行执行读取文件完成需要3s时间。（_串行流程函数控制不止这一种方式实现_）</p>
<p>&emsp;&emsp;将流程控制改为并行执行：</p>
<pre><code>  let fileList = [1, 2, 3];
  let fileLines = [];
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb(lines)
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(new Date() + &#39;代码执行完成，文件行数依次为：&#39; + fileLines);
  &#125;
  function series(fileList) &#123;
    fileList.forEach((item, index) =&gt; &#123;
      asyncFn(item, function (lines) &#123;
        fileLines[index] = lines
        if (fileLines.length == fileList.length) &#123;
          consoleResult();
        &#125;
      &#125;);
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  series(fileList);

  输出
  Mon Nov 30 2020 21:49:52 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 94
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 57
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,94,57
</code></pre>
<p>&emsp;&emsp;上面的代码中，series中使用forEach()方法时读取文件同时进行，因为不知道各次读取文件完成的先后顺序，这里不能使用fileLines.push()方法保存结果，可能会得的结果与文件读取顺序不匹配。这里将结果赋值给fileLines[index]能保证结果的顺序与读取文件的顺序一致。当获得的结果的长度与读取文件的次数相同时，所有文件读取完成。这里并行执行读取文件完成需要1s时间。（_并行流程函数控制不止这一种方式实现_）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JS原型（prototype）链与继承（Class）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/23/JS%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Class%EF%BC%89/"
    >JS原型（prototype）链与继承（Class）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/23/JS%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Class%EF%BC%89/" class="article-date">
  <time datetime="2020-12-23T10:00:00.000Z" itemprop="datePublished">2020-12-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在JavaScript中，每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>&emsp;&emsp;对象：对象是一个包含相关数据和方法的集合，通常由一些变量和函数组成，我们称之为对象里面的属性和方法。对象成员的值可以是任意的，例如Number，String，Function，null， undefined等。<br><em>&emsp;&emsp;[注] 可以使用点表示法或者括号表示法访问对象的成员（对象做了字符串到值的映射，而数组做的是数字到值的映射）。其中，括号表示法一个特别的地方是不仅可以动态的去设置对象成员的值，还可以动态的设置成员的名字。可以用一个对象来做另一个对象成员的值，这样，实际上创建了一个子命名空间，可以链式的使用点表示法或括号表示法去访问其中的成员变量。</em></p>
<p>&emsp;&emsp;<u>面向对象的JavaScript</u>（OOJS）：面向对象编程（OOP）的基本思想为，在程序里，我们通过使用对象去构建现实世界的模型，把原本很难（或不可）能被使用的功能，简单化并提供出来，以供访问。对象可以包含相关的数据和代码，去描述模型以及模型具有的行为和功能。对象包（命名空间）存储（封装）着对象的数据与方法，使数据的组织和访问变得更容易了；对象也常用作数据存储体，用于在网络上运输数据，十分便捷。</p>
<p>&emsp;&emsp;<u>构造函数创建对象</u>：JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。关键字 new 跟着一个含参构造函数，便能创建一个想要的对象（<u>对象的原型指向构建函数</u>）。其中，这个构建函数是 JavaScript 版本的类（ES6已提供class关键字的语法糖定义构建函数）。</p>
<p><em>&emsp;&emsp;[注] 其他创建对象的方式：</em><br><em>&emsp;&emsp;① 字面量定义对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;② Object()构造函数，即使用new Object()创建对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;③ Object.create()方法，允许您基于现有对象创建新的对象。（对象的原型指向创建时指定的对象）</em></p>
<h2 id="1、原型（链）"><a href="#1、原型（链）" class="headerlink" title="1、原型（链）"></a>1、原型（链）</h2><p>&emsp;&emsp;JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层，以此类推。这种关系常被称为原型链，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。<br>&emsp;&emsp;准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。</p>
<p><em>&emsp;&emsp;<strong>[注] 与传统OOP的区别：在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</strong></em><br><em>&emsp;&emsp;[注] 对象原型（可以通过Object.getPrototypeOf(obj)或者浏览器提供的__proto__属性获得）与构造函数的prototype属性是有区别的：前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Bool())和Bool.prototype指向着同一个对象。<u>特别的，没有官方的方法用于直接访问一个对象的原型——原型链中的“连接”被定义在一个内部属性中，</u>在 JavaScript 语言标准中用 [[prototype]] 表示，大多数现代浏览器还是提供了一个名为 __proto__ 属性，其包含了对象的原型。</em></p>
<p>&emsp;&emsp;(1) prototype属性：继承成员被定义的地方<br>&emsp;&emsp;继承的属性和方法是定义在 prototype 属性之上的（可以称之为子命名空间），prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。<br><em>&emsp;&emsp;[注] Object.create()可以指定一个对象作为原型对象创建一个实例对象。</em></p>
<p>&emsp;&emsp;(2) constructor属性：指向了用于构造此实例对象的构造函数<br>&emsp;&emsp;每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。<br>&emsp;&emsp;在某些情况下，没有原始构造器的引用，想要构造实例可以通过已有实例的constructor属性指向的构造函数来完成。即可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），只需在前面添加 new 关键字（let person2 = new person1.constructor()），便能将此函数作为构造器使用，从而调用这个构造器创建另一个对象实例。</p>
<p><em>&emsp;&emsp;[注] 构建函数前new关键字做了什么？</em><br><em>&emsp;&emsp;① 创建一个新对象</em><br><em>&emsp;&emsp;② 将新对象的__proto__属性指向了构建函数对象prototype对象</em><br><em>&emsp;&emsp;③ 将构建函数的this修正为指向新对象，执行构造函数中的代码，即为这个新对象添加对应属性</em><br><em>&emsp;&emsp;④ 返回新对象</em></p>
<pre><code>  var obj = &#123;&#125;;
  obj.__proto__ = Base.prototype;
  Base.call(obj);
</code></pre>
<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><p>&emsp;&emsp;<strong>JavaScript基于原型链继承（prototypal inheritance）</strong></p>
<p>&emsp;&emsp;如何实现继承：（这里以Teacher构造函数继承于Person构造函数的例子来说明）<br>&emsp;&emsp;(1) 定义构造器（构造函数），这里定义构造函数Person。</p>
<pre><code>  function Person(name, age, gender, interests) &#123;
    this.name =name;
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  &#125;;
  Person.prototype.greeting = function() &#123;
    console.log(`hello, I am $&#123;name&#125;!`)
  &#125;;
</code></pre>
<p>&emsp;&emsp;(2) 创建继承于Person构造函数的Teacher构造函数，并为Teacher 构造函数添加特有的subject（所授学科科目）属性。</p>
<pre><code>  function Teacher(name, age, gender, interests, subject) &#123;
    // 创建一个新的对象实例时同时指派其继承的属性（修正this指向Teacher()函数）
    Person.call(this, name, age, gender, interests);
    this.subject = subject;
    
    // 利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，从而继承其属性与方法
    Teacher.prototype = Object.create(Person.prototype);
    
    // 修正Teacher构造器指向，使之与Teacher关联(修正前指向Person)
    Teacher.prototype.constructor = Teacher;
  &#125;
</code></pre>
<p><em>&emsp;&emsp;[注] 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。其中Person()函数是Person.prototype的构造函数，即Person===Person.prototype.constructor。任何您想要被继承的方法都应该定义在构造函数的prototype对象里，并且永远使用父类的prototype来创造子类的prototype，这样才不会打乱类继承结构。</em></p>
<p>&emsp;&emsp;(3) Teacher构造函数添加新的greeting成员函数</p>
<pre><code>  Teacher.prototype.greeting = function()&#123;
    console.log(`hello, I am a teather, I teath $&#123;this.subject&#125;`)
  &#125;
</code></pre>
<p>&emsp;&emsp;(4) 生成对应的teacher实例</p>
<pre><code>  let t = new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath englis
</code></pre>
<p>&emsp;&emsp;所有代码：</p>
<pre><code>  function Person(name, age, gender, interests) &#123;    
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  &#125;;
  Person.prototype.greeting = function () &#123;
    console.log(`hello, I am $&#123;name&#125;!`);
  &#125;;
  function Teacher(name, age, gender, interests, subject) &#123;
    // 创建一个新的对象实例时同时指派其继承的所有属性（修正this指向Teacher()函数）
    Person.call(this, name, age, gender, interests);
    this.subject = subject;
    // Teacher.prototype现在会继承Person.prototype的所有属性和方法
    Teacher.prototype = Object.create(Person.prototype);
    // 修正Teacher()的prototype的constructor属性指向(修正前指向Person，不正确)
    Teacher.prototype.constructor = Teacher;
  &#125;
  Teacher.prototype.greeting = function()&#123;
    console.log(`hello, I am a teather, I teath $&#123;this.subject&#125;`)
  &#125;
  let t = new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath englis
</code></pre>
<p>&emsp;&emsp;<strong> ES6 类（class）</strong></p>
<p>&emsp;&emsp;(1) 类的定义方式<br>&emsp;&emsp;ES6 提供了更接近传统语言的写法，引入了class关键字（仅是一个‘语法糖’），可以定义类。可以使编码时逻辑更加清晰明了。在JavaScript中，类是一种“特殊的函数”。类本身就指向构造函数（即A == A.prototype.constructor）。</p>
<p><em>&emsp;&emsp;[注] 类都在严格模式下执行。类的内部所有定义的方法，都是不可枚举的（这点与ES5定义在prototype上的方法表现不一致）。类必须使用new关键字使用（不能像ES5中构造函数可直接调用）。</em></p>
<p>&emsp;&emsp;定义类有两种方式：<br>&emsp;&emsp;类声明：class A {}，<strong>类声明不会提升，需要先声明，再访问</strong><br>&emsp;&emsp;类表达式: let B = class [B2] {}，类表达式可以不命名，名称为局部名称，可使用类的name属性访问</p>
<p><em>&emsp;&emsp;<strong>[注] 类中的this：</strong></em><br>&emsp;&emsp;① 在构造函数constructor()中基类与派生类this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象（指向实例），所有非静态方法会被添加到this的原型中。在派生类（子类）中的构造函数没有初始的this绑定（undefined），在构造函数中调用super()才能生成一个this绑定（返回一个指向当前派生类的this）。<br>&emsp;&emsp;② 静态方法不是this的属性，它们只是类自身的属性，不会被子类继承。派生类在super()前调用this会抛出异常，派生类不能在调用super()前返回，除非没有构造函数或者构造函数返回了对象。<br>&emsp;&emsp;③ 使用super对象时，super 调用父类的方法时，super 会绑定子类的 this。</p>
<p>&emsp;&emsp;(2) constructor()构造函数<br>&emsp;&emsp;初始化一个由class创建的对象。一个类中只能有唯一的constructor()方法，若代码未显式的定义，会添加一个默认的该方法。在使用new关键字创建实例时，会执行该方法，其中的this指向创建的实例。默认会返回this实例，不过也可以显式的返回一个对象。</p>
<p>&emsp;&emsp;(3) super关键字<br>&emsp;&emsp;分为两种情况：<br>&emsp;&emsp;当做函数使用：super()，这个函数会调用父类的构造函数，返回一个指向当前派生类的this，相当于A.prototype.constructor.call(this, props)<br>&emsp;&emsp;当做对象使用：在普通方法中，super指向父类的原型对象；在静态方法中，super指向父类</p>
<p><em>&emsp;&emsp;[注] 静态方法，static修饰，可以被子类继承，但不会添加到类的实例上，方法名称可与其他方法重名。静态方法可以通过super调用。</em></p>
<p>&emsp;&emsp;(4) 取值函数（getter）和存值函数（setter）<br>&emsp;&emsp;在类中内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为（ES5可以提供getter、setter函数）。</p>
<p>&emsp;&emsp;(5) new.target属性<br>&emsp;&emsp;new命令的一个属性，只能在构造函数中使用。在类中使用时，返回当前类；在子类中使用时，返回当前子类。用途：可以限制类只能通过new命令调用；或者编写只能继承而不能实例化的基类。</p>
<p>&emsp;&emsp;通过ES6 Class关键字实现上面Teacher类与Person类的继承关系：</p>
<pre><code>  class Person&#123;    
    constructor(name, age, gender, interests)&#123;
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.interests = interests;
    &#125;
    greeting()&#123;
      console.log(&quot;hello, I am &quot; + this.name + &quot;!&quot;);
    &#125;
  &#125;
  class Teather extends Person&#123;
    constructor(name, age, gender, interests, subject)&#123;
      super(name, age, gender, interests);
      this.subject = subject;
    &#125;
    greeting()&#123;
      console.log(&quot;hello, I am a teather, I teath &quot; + this.subject + &quot;!&quot;);
    &#125;
  &#125;
  let t = new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting()
</code></pre>
<p>&emsp;&emsp;通过Babel.js将上面的ES6转换为ES5代码如下：</p>
<pre><code>  &quot;use strict&quot;;

  function _typeof(obj) &#123;
    &quot;@babel/helpers - typeof&quot;;
    if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) &#123; _typeof = function _typeof(obj) &#123; return typeof obj; &#125;; &#125;
    else &#123;
      _typeof = function _typeof(obj) &#123;
        return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;
      &#125;;
    &#125;
    return _typeof(obj);
  &#125;
  
  function _inherits(subClass, superClass) &#123;
    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123;
      throw new TypeError(&quot;Super expression must either be null or a function&quot;);
    &#125;
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125; &#125;);
    if (superClass) _setPrototypeOf(subClass, superClass);
  &#125;
  
  function _setPrototypeOf(o, p) &#123;
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123;
      o.__proto__ = p; return o;
    &#125;;
    return _setPrototypeOf(o, p);
  &#125;
  
  function _createSuper(Derived) &#123;
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() &#123;
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) &#123;
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      &#125; else &#123;
        result = Super.apply(this, arguments);
      &#125;
      return _possibleConstructorReturn(this, result);
    &#125;;
  &#125;
  
  function _possibleConstructorReturn(self, call) &#123;
    if (call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)) &#123;
      return call;
    &#125;
    return _assertThisInitialized(self);
  &#125;
  
  function _assertThisInitialized(self) &#123;
    if (self === void 0) &#123;
      throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
    &#125;
    return self;
  &#125;
  
  function _isNativeReflectConstruct() &#123;
    if (typeof Reflect === &quot;undefined&quot; || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === &quot;function&quot;) return true;
    try &#123;
      Date.prototype.toString.call(Reflect.construct(Date, [], function () &#123; &#125;));
      return true;
    &#125; catch (e) &#123;
      return false;
    &#125;
  &#125;
  
  function _getPrototypeOf(o) &#123;
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123;
      return o.__proto__ || Object.getPrototypeOf(o);
    &#125;;
    return _getPrototypeOf(o);
  &#125;
  
  function _instanceof(left, right) &#123;
    if (right != null &amp;&amp; typeof Symbol !== &quot;undefined&quot; &amp;&amp; right[Symbol.hasInstance]) &#123;
      return !!right[Symbol.hasInstance](left);
    &#125; else &#123;
      return left instanceof right;
    &#125;
  &#125;
  
  function _classCallCheck(instance, Constructor) &#123;
    if (!_instanceof(instance, Constructor)) &#123;
      throw new TypeError(&quot;Cannot call a class as a function&quot;);
    &#125;
  &#125;
  
  function _defineProperties(target, props) &#123;
    for (var i = 0; i &lt; props.length; i++) &#123;
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if (&quot;value&quot; in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    &#125;
  &#125;
  
  function _createClass(Constructor, protoProps, staticProps) &#123;
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  &#125;
  
  var Person = /*#__PURE__*/function () &#123;
    function Person(name, age, gender, interests) &#123;
      _classCallCheck(this, Person);
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.interests = interests;
    &#125;
    _createClass(Person, [&#123;
      key: &quot;greeting&quot;,
      value: function greeting() &#123;
        console.log(&quot;hello, I am &quot;.concat(this.name, &quot;!&quot;));
      &#125;
    &#125;]);
    return Person;
  &#125;();
  
  var Teather = /*#__PURE__*/function (_Person) &#123;
    _inherits(Teather, _Person);
    var _super = _createSuper(Teather);
    function Teather(name, age, gender, interests, subject) &#123;
      var _this;
      _classCallCheck(this, Teather);
      _this = _super.call(this, name, age, gender, interests);
      _this.subject = subject;
      return _this;
    &#125;
    _createClass(Teather, [&#123;
      key: &quot;greeting&quot;,
      value: function greeting() &#123;
        console.log(&quot;hello, I am a teather, I teath &quot;.concat(this.subject));
      &#125;
    &#125;]);
    return Teather;
  &#125;(Person);
  
  var t = new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting();
</code></pre>
<p>&emsp;&emsp;ES6转换后的ES5代码与原来的ES5代码实现原理一致。我们来简单分析一下转换后的代码：<br>&emsp;&emsp;① 可以看到，定义Person和Teacher时，使用了立即执行函数，代码会立即执行，执行后返回Person构造函数以及继承于Person的Teacher构造函数。<br>&emsp;&emsp;② 在定义Person变量的立即执行函数中，定义了Person函数，函数中设置了相关属性。然后调用_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法给Person函数的原型prototype上添加上方法，(还可以给Person函数添加静态属性，这里代码未添加）。即_createClass()实现了Person函数方法与属性的添加，最后将Person函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;③ 在定义Teacher变量的立即执行函数中，将定义好的Person构造函数函数作为了参数，先调用_inherits()方法，将定义的Teacher函数（预编译会进行函数提升）与传入的Person构造函数作为参数，其中使用Object.create()方法以Person构造函数的原型prototype作为原型，设置了Teacher函数的原型，同时Teacher函数的原型也继承了Person构造函数原型链上的属性和方法，然后调用_setPrototypeOf()方法修正Teacher函数原型对象__proto__的指向，也就是_inherits()方法实现了继承关系。然后再调用了_createSuper(Teather)方法定义了_super变量，其值是一个函数，里面追溯了Teacher构造函数的原型链，定义了调用父构造函数Person时，使用了apply（this, arguments）方法绑定了子构造函数Teacher的this，实现了Teacher函数属性的设置（<u>返回的_super方法这里只是定义，还未执行，要在Teacher构造函数执行到_super.call()的时候才会执行</u>）。最后同理，调用了_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法在Teacher函数的原型prototype上重写了greeting()方法，将Teacher函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;④ 调用new Teacher()创建t实例，执行Teacher构造函数，调用_classCallCheck()防止构造函数被直接调用（即ES6中的类是不能被直接调用的）。然后再调用上面说的定义的_super()方法实现了实例属性的设置（在执行_super()函数时，会执行里面定义的父构造函数Person的方法来实现属性的继承与设置），再设置了Teacher构造函数实例特有的subject属性，此时获得的_this实例的原型指向Teacher构造函数，Teacherr构造函数又继承于Person构造函数。此时_this实例已经继承了原型链上的属性与方法，包括Teahcer构造函数重写的greeting()方法。返回_this。<br>&emsp;&emsp;⑤ 执行t.greeting()方法，可以看到方法被成功执行且为执行的重写后的方法。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JS预解析、作用域、执行上下文、this"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/05/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/"
    >JS预解析、作用域、执行上下文、this</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/05/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/" class="article-date">
  <time datetime="2020-12-05T03:28:36.000Z" itemprop="datePublished">2020-12-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>这部分是JavaScript比较基础的部分。JS代码运行前的极短时间内会进行语法分析、代码预解析以及解释执行。其中预解析最重要。分为全局预解析和局部预解析，全局预解析发生在页面加载完成时执行，而局部预解析发生在函数执行的前一刻。会进行变量与函数申明（变量提升）、生成执行上下文（作用域）等工作。</p>
<h2 id="1、作用域（链）"><a href="#1、作用域（链）" class="headerlink" title="1、作用域（链）"></a>1、作用域（链）</h2><p>&emsp;&emsp;JavaScript采用词法作用域，作用域在代码定义时就确定，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限，执行时并且不会改变（作用域访问的变量是编写代码的结构确定的）。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。函数的原型（prototype）属性存在[[Scopes]]属性保存着当前函数的作用域链信息。</p>
<p>&emsp;&emsp;作用域分为全局作用域、函数(局部)作用域、块级作用域（ES6引入）。<br>&emsp;&emsp;① 在代码中任何地方都能访问到的对象拥有全局作用域。全局作用域的变量是全局对象的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，但加上全局对象，可以提供搜索效率。<br><em>&emsp;&emsp;[注] 隐式的申明变量，在最外层函数外部申明的变量，给window对象添加的属性都是全局变量</em><br>&emsp;&emsp;② 在函数内部用var关键字申明的变量，函数的参数会存在于该函数的局部作用域中。<br><em>&emsp;&emsp;[注] 局部变量的优先级高于全局变量</em><br>&emsp;&emsp;③ 用let、const申明的变量会存在于块级作用域中。</p>
<h2 id="2、预解析与执行上下文"><a href="#2、预解析与执行上下文" class="headerlink" title="2、预解析与执行上下文"></a>2、预解析与执行上下文</h2><p>&emsp;&emsp;JavaScript代码在执行前的瞬间会存在预解析的阶段，会对代码进行相应的处理，对申明的变量与函数进行变量提升，以及生成对应的执行上下文，执行上下文除了保存代码执行信息外，还会将当前作用域信息也保存在执行上下文中，他们有相应的存储关系。随着代码进行的进行，执行上下文会进行相应的改变，执行上下文是用于跟踪代码的运行情况。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p>
<p>&emsp;&emsp;预解析处理创建执行上下文的步骤：<br>&emsp;&emsp;① 隐式的创建GO（全局上下文）/AO（函数上下文）对象<br>&emsp;&emsp;② 找形参和变量声明，将变量和形参名作为GO/AO的属性名，值为undefined（这个过程也常称为变量提升）<br>&emsp;&emsp;③ 将实参值和形参统一<br>&emsp;&emsp;④ 在函数体里面找函数声明，作为GO/AO的属性，值赋予函数体（这个过程也常称为函数提升）<br><em>&emsp;&emsp;[注] 在全局预解析中，由于全局中没有参数的的概念，所以省去了第2步的找参数、第3步实参形参相统一这两处处理。GO全局上下文对象，它优于局部预解析AO局部上下文对象的创建与执行</em></p>
<p>&emsp;&emsp;例如下面的代码：</p>
<pre><code>  1  console.log(a) // undefined
  2  console.log(b) // Uncaught ReferenceError: b is not defined
  3  var a = 5
  4  console.log(a) // 5
  5  console.log(test) // undefined
  6  console.log(fn) // function fn () &#123;&#125;
  7  console.log(fn(3)) // 11
  8  var test = function () &#123;
  9     return 10
  10 &#125;
  11 function fn(x) &#123;
  12  console.log(a) // undefined
  13  var a = b = 8
  14  var c = 6
  15  return a + x
  16 &#125;
  17 console.log(a) // 5
  18 console.log(b) // 8
  19 console.log(c) // Uncaught ReferenceError: c is not defined
  20 console.log(test()) // 10
</code></pre>
<p>&emsp;&emsp;<strong>上面的代码在执行前的瞬间，会先进行全局预解析。过程如下：（这里只列举了执行上下文中的部分信息）</strong></p>
<p>&emsp;&emsp;(1) 进行全局预解析的第1步：创建全局上下文GO对象</p>
<pre><code>  GO: &#123;
  
  &#125;
</code></pre>
<p>&emsp;&emsp;(2) 进行全局预解析的第2步：找变量声明，将变量作为GO的属性名，值为undefined</p>
<pre><code>  GO: &#123;
    a: undefined,
    test: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(3) 进行全局预解析3步：在函数体里面找函数声明，作为GO的属性，值赋予函数体</p>
<pre><code>  GO: &#123;
    a: undefined,
    test: undefined
    fn: function fn () &#123;&#125;
  &#125;
</code></pre>
<p>&emsp;&emsp;<strong>全局预解析完成，代码开始执行，执行过程如下：</strong><br>&emsp;&emsp;执行第1行，输出a为undefined<br>&emsp;&emsp;执行第2行，因为全局上下文没有申明b变量，所以程序抛出异常：Uncaught ReferenceError: b is not defined<br>&emsp;&emsp;执行第3行，将全局上下文中a赋值为5</p>
<pre><code>  GO:&#123;
    a: 5,
    test: undefined
    fn: function fn () &#123;&#125;
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第4行，输出a为5<br>&emsp;&emsp;执行第5行，输出test为undefined<br>&emsp;&emsp;执行第6行，输出fn为function fn () {}</p>
<p>&emsp;&emsp;<strong>执行第7行，调用fn并传入参数3，在fn执行前瞬间，会进行局部预编译，过程如下：</strong></p>
<p>&emsp;&emsp;(1) 进行局部预解析的第1步： 创建对应的函数上下文AO对象</p>
<pre><code>  AO: &#123;
    
  &#125;
</code></pre>
<p>&emsp;&emsp;(2) 进行局部预解析的第2步：找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined</p>
<pre><code>  AO: &#123;
    x: undefined,
    a: undefined,
    c: undefined
  &#125;
</code></pre>
<p><em>&emsp;&emsp;[注] <u>在第13行’var a = b = 8’，这里隐式的申明了全局变量b，此时应该将变量b添加到GO对象中，</u>此时的GO对象为：</em></p>
<pre><code>  GO: &#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(3) 进行局部预解析第3步：将实参与形参统一</p>
<pre><code>  AO:&#123;
    x: 3,
    a: undefined,
    c: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(4) 对应fn函数，进行预解析第4步：在函数体里面找函数声明，作为AO的属性，值赋予函数体<br>&emsp;&emsp;fn函数内无函数申明，AO对象不变<br>&emsp;&emsp;<strong>fn函数执行前预解析完成，11-16行的<u>函数入栈执行！</u></strong><br>&emsp;&emsp;执行第12行，输出a为undefined（先在当前执行的函数上下文AO的作用域对象中查找变量a，若AO的作用域对象中没有，通过AO中的作用域链，再去全局上下文GO中去查找）<br>&emsp;&emsp;执行第13行，将变量b赋值为8，变量a赋值为8。其中变量b存在于全局上下文GO中，这里的a为当前执行的函数上下文AO中的a，此时的GO、AO对象为：</p>
<pre><code>  GO:&#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: 8
  &#125;
  AO:&#123;
      x: 3,
      a: 8,
      c:undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第14行，将AO中的c变量赋值为6，此时的AO为：</p>
<pre><code>  AO:&#123;
    x: 3,
    a: 8,
    c: 6
  &#125;
</code></pre>
<p>&emsp;&emsp;<strong>执行第15行，计算a+x的值为11，并返回函数调用的地方。所以第7行输出函数fn(3)的执行结果11。<u>函数执行完成，函数出栈，当前执行上下文AO对象被销毁。 </u></strong><br>&emsp;&emsp;执行第8行，将GO中test赋值为function () { return 10 }，此时的GO对象为：</p>
<pre><code>  GO: &#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: 8
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第17行，输出a为5<br>&emsp;&emsp;执行第18行，输出b为8<br>&emsp;&emsp;执行第19行，因为全局上下文没有申明c变量，所以程序抛出异常：Uncaught ReferenceError: c is not defined<br>&emsp;&emsp;执行第20行，<u>这里调用test()函数与上面调用fn(3)函数类似，执行前也会进行相应的局部预解析，然后执行函数，</u>这里输出函数返回的10<br>&emsp;&emsp;代码执行完成！</p>
<p><em>&emsp;&emsp;[注] 这里分析比较简单的一段代码的执行过程，这里在函数内部没有函数的申明，也没有异步处理。一般的，如果函数内部存在函数，在内部函数调用时也会进行对应的局部预处理以及入栈执行；如果代码内包含异步逻辑，会把异步逻辑放在异步队列里面进行相应的调度执行。</em><br><em>&emsp;&emsp;[注] 如果在某个作用域中使用了某变量，而该变量并未在对应的（静态）作用域中声明（在其它作用域中声明），该变量称为<u>自由变量。</u></em></p>
<h2 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h2><p>&emsp;&emsp;一个函数和对其周围状态（词法环境）的引用捆绑在一起，这样的组合就是闭包（closure）。闭包让你可以在一个内层函数中访问到其外层函数的作用域（即能够读取其他函数内部变量的函数）。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。<strong>函数就会形成闭包。</strong><u>闭包是由函数以及声明该函数的词法环境组合而成的。</u>该环境包含了这个闭包创建时作用域内的任何局部变量。</p>
<p>&emsp;&emsp;例如下面的代码：</p>
<pre><code>  function add(x) &#123;
    console.log(inner.__proto__)
    function inner(y) &#123;
        return x + y;
    &#125;
    return inner;
  &#125;
  console.log(add(3)(4))

  // 输出
  &#123;constructor: ƒ&#125;
  constructor: ƒ inner(y)
  arguments: null
  caller: null
  length: 1
  name: &quot;inner&quot;
  prototype: &#123;constructor: ƒ&#125;
  __proto__: ƒ ()
  [[FunctionLocation]]: scopes.html:14
  [[Scopes]]: Scopes[2]
  0: Closure (add) &#123;x: 3&#125;
  1: Global &#123;window: Window, self: Window, document: document, name: &quot;&quot;, location: Location, …&#125;
  __proto__: Object

  7
</code></pre>
<p>&emsp;&emsp;上面的代码中：add函数内部定义了inner函数，inner函数可以访问词法环境外部add函数作用域中变量，如这里的形参x。从打印的inner.prototype对象可以看出，在inner函数的作用域链的栈底为Global全局作用域，栈顶为inner函数所在的add函数的作用域，这里形成了Closure闭包。add(3)函数调用后返回的inner(y){ return x + y; }函数与inner函数的词法环境形成了闭包，inner函数中保留了对add函数内部变量x的应用，且此时x=3，所以在add(3)(4)继续调用inner函数时返回结果7。</p>
<p><em>&emsp;&emsp;[注] 这里是否形成闭包与内部的inner函数是否返回无关。</em></p>
<h2 id="4、this关键字"><a href="#4、this关键字" class="headerlink" title="4、this关键字"></a>4、this关键字</h2><p>&emsp;&emsp;在绝大多数情况下，<u>函数的调用方式决定了 this 的值（<strong>运行时绑定</strong>）。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同（<strong>与调用方式有关</strong>）。</u>ES5 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。ES2015 引入了箭头函数，箭头函数不提供自身的 this 绑定，此时this 的值将保持为闭合词法上下文的值。函数中this的取值为当前执行上下文（global、function 或 eval）的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。</p>
<p>&emsp;&emsp;① 在全局上下文中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。<br>&emsp;&emsp;② 在函数上下文中，this指向取决于函数被调用的方式：在非严格模式下，this的值不由调用者设置，this指向window。在严格模式下，this指向调用者，若执行前没有设置this的值，也没有作为对象的属性或方法而是直接调用，this为undefined。<br><em>&emsp;&emsp;[注] 可以通过call、apply方法修改this指向的环境。</em><br>&emsp;&emsp;③ 类上下文中，基类与派生类构造函数constructor()中this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象，所有非静态方法会被添加到this的原型中。在派生类中的构造函数没有初始的this绑定，在构造函数中调用super()才能生成一个this绑定。<u>注意的是，使用super对象时，super 调用父类的方法时，super 会绑定当前子类的 this。</u><br><em>&emsp;&emsp;[注] 静态方法不是this的属性，它们只是类自身的属性。派生类（子类）在super()前调用this会抛出异常，派生类不能在调用super前返回，除非没有构造函数或者构造函数返回了对象。</em></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JavaScript概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/03/JavaScript%E6%A6%82%E8%BF%B0/"
    >JavaScript概述</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/03/JavaScript%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2020-12-03T07:53:39.000Z" itemprop="datePublished">2020-12-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型，单线程的脚本语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态页面信息，而是实时的内容更新，交互式的地图，2D/3D 动画，滚动播放的视频等更加丰富的内容，也能实现用户界面与服务器相关的交互</p>
<h2 id="1、语言特性"><a href="#1、语言特性" class="headerlink" title="1、语言特性"></a>1、语言特性</h2><p>&emsp;&emsp;JavaScript是一门动态的、弱类型、基于原型（prototype）的脚本语言。在JavaScript中“一切皆对象”，在这一方面，它比其他的面向对象的语言来得更为彻底。即使作为代码本身载体的函数（function），也是对象。</p>
<h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><h4 id="1-向页面添加JavaScript"><a href="#1-向页面添加JavaScript" class="headerlink" title="1) 向页面添加JavaScript"></a>1) 向页面添加JavaScript</h4><p>&emsp;&emsp;在body标签结束前插入以下script标签引入JavaScript， <u>JavaScript 是区分大小写的</u></p>
<pre><code>  // 方式1：内联JavaScript
  &lt;script&gt;
      // 在此编写JavaScript代码
  &lt;/script&gt;

  // 方式2：外部引入JavaScript
  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><em>&emsp;&emsp;[注] 在外部引入JS时，在必要的时候（防止加载阻塞页面渲染问题或对多个有依赖关系的脚本加载顺序有要求），我们需要加上async或defer修饰符（解决脚本阻塞问题的两种方式）。<u>浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。</u>当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，async 是最理想的选择；<u>defer 属性的脚本将按照在页面中出现的顺序加载，可保证脚本的加载顺序</u></em></p>
<h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2) 变量"></a>2) 变量</h4><p>&emsp;&emsp;变量是用来存储数值的，那么有一个重要的概念需要区分。变量不是数值本身，它们仅仅是一个用于存储数值的容器，JS中使用var、let、const来定义变量</p>
<p>&emsp;&emsp;构造变量名称（唯一标识符）的通用规则是：<br>&emsp;&emsp;名称可包含字母、数字、下划线和美元符号<br>&emsp;&emsp;名称必须以字母、$或_开头<br>&emsp;&emsp;名称对大小写敏感<br>&emsp;&emsp;保留关键字不能作为变量名称</p>
<pre><code>  var a;
  let b;
  onst C = 100; // 定义常量必须进行初始化，常量一般用大写英文命名
</code></pre>
<p>&emsp;&emsp;变量类型：<br>&emsp;&emsp;值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol<br>&emsp;&emsp;引用数据类型：对象(Object，JavaScript 对象是键值对的容器)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）</p>
<h4 id="3-语句与表达式"><a href="#3-语句与表达式" class="headerlink" title="3) 语句与表达式"></a>3) 语句与表达式</h4><p>&emsp;&emsp;<u>JavaScript区分表达式和语句</u><br>&emsp;&emsp;表达式是输出值的，并且可以写在任何需要一个值的地方，例如函数的参数等。一般来讲，表达式由变量、操作符和约束条件等以能求得有意义的数值（非undefined）为目的排列所得的组合<br>&emsp;&emsp;语句表示执行了一个动作，例如循环控制语句(for、while…)和分支判断语句(if)等。一个程序基本上就是一系列的语句的集合。在JavaScript中需要语句的地方，也可以写入一个表达式。但不能够在需要表达式的地方写入一个语句。我们常用分号分语句，使得可以在一行编写多条语句。<br>&emsp;&emsp;常用运算符：=、+、-、*、/、==、!=、&gt;、&lt;、&amp;&amp;、||、……<br>&emsp;&emsp;常用语句：</p>
<pre><code>  // 赋值语句    
  let a = 5, b = 8;
  
  // if条件判断语句
  if (condition1) &#123;
    // 当条件 1 为 true 时执行的代码
  &#125;
  else if (condition2) &#123;
    // 当条件 2 为 true 时执行的代码
  &#125;
  else &#123;
    // 当条件 1 和 条件 2 都不为 true 时执行的代码
  &#125;
  
  // switch分支语句
  switch (n) &#123;
    case 1:
      // 执行代码块 1
      break; // 阻止代码向下一个case执行，有时为了逻辑需要（如累加等），switch语句中不会使用此关键字
    case 2:
      // 执行代码块 2
      break;
    default:
    // 与 case 1 和 case 2 不同时执行的代码
  &#125;
  
  // for、while、do while循环语句（break 语句用于跳出循环，continue 用于跳过循环中的一个迭代）
  for (语句 1; 语句 2; 语句 3)
  &#123;
    // 语句2为真执行的代码块
  &#125;
  while (条件) &#123;
    // 条件为真执行的代码块
  &#125;
  do &#123;
    // 代码块会在条件被测试前执行，代码块至少被执行一次
  &#125; while (条件);
</code></pre>
<h4 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4) 字符串模板"></a>4) 字符串模板</h4><p>&emsp;&emsp;模板字符串使用反引号<u>(` `)</u> 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${ expression } ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。<u>特别的，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。</u>注意，在模版字符串内使用反引号（`）时，需要在它前面加转义符（），<strong>字符串模板可以嵌套使用。</strong></p>
<pre><code>  let a = 4;
  console.log(`我有一个苹果$&#123;a&#125;s，哈哈哈~`) // 我有一个苹果6s，哈哈哈~
  function upgradePhone(str, a)&#123; // [注] 函数的第一个参数是数组（模板中各个原生字符串）。其余的参数为模板中的变量
    return &#39;升级手机，&#39; + str[0] + (a + 2) + str[1];
  &#125;
  console.log(upgradePhone`我有一个苹果$&#123;a&#125;s，哈哈哈~`) // 升级手机，我有一个苹果6s，哈哈哈~
</code></pre>
<h4 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5) 解构赋值"></a>5) 解构赋值</h4><p>&emsp;&emsp;解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。使得对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法<br>&emsp;&emsp;特别的：<u>赋值语句周围的圆括号()在使用对象字面量无声明解构赋值时是必须的</u>，否则左边被认为是一个块而不是对象字面量。<u>并且()表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行</u></p>
<pre><code>  let a, b, C;
  [a, b = 0] = [10, 20, 30, 40, 50]; // a:10, b:20 [注] 为了防止取出一个值为undefined，可以在表达式左边预设默认值
  [a, b, ...C] = [10, 20, 30, 40, 50]; // a:10，b:20, C: [30, 40, 50]
  (&#123; a, b = 0&#125; = &#123; a: 10, b: 20 &#125;); // a: 10, b: 20
  (&#123;a, b, ...C&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;); // a: 10, b: 20, C: &#123;c: 30, d: 40&#125;
</code></pre>
<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h4><p>&emsp;&emsp;函数就是包裹在花括号中的代码块，使用关键字function进行定义。当调用该函数时，会执行函数内的代码，在调用函数时，可以向其传递参数。这些参数可以在函数中使用，多个参数用逗号（,）分割。变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。有时，我们会希望函数将值返回调用的地方。通过使用return语句就可以实现。在使用return语句时，函数会停止执行(无论后面是否还存在语句)，并返回指定的值。</p>
<p><em>&emsp;&emsp;[注] <u>函数有作用域的概念，在函数内部定义的变量，只能在函数内部访问它（闭包情况除外），此时该变量的作用域是局部的。特别的，如果给未申明的变量赋值，该变量会被自动配置为全局变量（配置为window的属性）。</u></em></p>
<pre><code>  function functionname(var1, var2, ...) &#123;
    // 代码
    // return value;
  &#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CSS动画（过渡、关键帧、3次贝塞尔曲线）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/26/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/"
    >CSS动画（过渡、关键帧、3次贝塞尔曲线）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/26/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/" class="article-date">
  <time datetime="2020-11-26T03:03:30.000Z" itemprop="datePublished">2020-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>CSS 动画可以在不借助 Javascript 的情况下做出一些相对简单的动画效果，例如缩放、移动、2D/3D旋转等。CSS动画有浏览器控制，表现得很流畅。 <u>CSS动画的时序函数主要为3次贝塞尔曲线。</u></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>&emsp;&emsp;CSS动画是由浏览器按照一定的频率一帧一帧的绘制的，CSS实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新动画，不依赖于主线程，所以<u>CSS动画是很流畅的</u>。CSS过渡、关键帧相关知识在前面的文章<a href="/2020/09/24/CSS-3-%E6%A6%82%E8%BF%B0">《CSS(3)概述》</a>里已经讲到，这里摘抄相关知识如下：</p>
<p>&emsp;&emsp;2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你改变被转换元素的位置</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript来完成</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>&emsp;&emsp;您可以改变任意多的样式任意多的次数。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<pre><code>  @keyframes name
  &#123;
    0%   &#123; // 状态1 &#125;
    ...
    xx%  &#123; // 状态x &#125;
    ...
    100% &#123; // 状态n &#125;
  &#125;
  // 自定义动画的使用
  animation: name duration timing-function delay iteration-count direction;

  // timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)
  // iteration-count的取值: n(次数)、infinite
  // animation-direction的取值: normal、alternate
</code></pre>
<br/>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定 @keyframes 动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<strong>CSS动画时序函数(timing-function属性的值）：</strong><br>&emsp;&emsp;CSS动画的时序函数主要为3次贝塞尔曲线。3次贝塞尔曲线由4点个组成，CSS3贝塞尔曲线起点是 (0,0) ，终点是(1,1)，代表动画执行时间到达时动画刚好执行完成。所以CSS中的cubic-bezier()函数只需要传入其他的2个端点值（x1,y1,x2,y2）即可。</p>
<p>&emsp;&emsp;timing-function取值分别对应的贝尔塞曲线函数为：</p>
<p><img src="/images/css3/timing-function%E5%8F%96%E5%80%BC.png" alt="timing-function取值"></p>
<p><em>[注] 以上图片制作于<a target="_blank" rel="noopener" href="https://cubic-bezier.com/">https://cubic-bezier.com/</a>，这是一个贝尔塞曲线在线设置与查看的网站，其中紫色的点表示（x1, y1）,蓝色的点表示（x2, y2）。</em></p>
<p>&emsp;&emsp;<strong>其中横轴（x轴）表示时间，纵轴（y轴）表示随着时间推移动画完成情况，曲线的斜率表现为为动画完成的快慢（比如移动速度等）。浏览器会根据时序函数对动画完成情况进行对应的更新（即由时序函数来确定此刻动画中各元素的状态）。</strong>根据图片，可以看到：linear随着时间推移，同一时间间隔动画的完成进度一致，即匀速的完成动画；ease-in先慢后快，ease-out先快后慢；ease-in-out则开始和结束较慢，中间动画完成的进度较快。<br>&emsp;&emsp;特别的，我们也可以使用cubic-bezier自定义时序函数，例如cubic-bezier(.92 ,-0.44, .04, 1.44)，可以看到随着时间的推移，完成情况最先是反向的且完成情况小于0，先快后慢；到最慢时然后完成情况变为正向，呈现先慢后快再慢（类似于ease-in-out），到最慢时此时动画的完成情况是大于1的（也就是多完成了一部分），此时完成情况的方向又变为反向的，先慢后快直到动画完成。</p>
<p>&emsp;&emsp;将cubic-bezier(.92 ,-0.44, .04, 1.44)时序用到transition属性中（时序函数一般要求写在过渡时间的后面）：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
    .ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
      transition: all 3s cubic-bezier(.92, -0.44, .04, 1.44);
    &#125;
    .box:hover .ball &#123;
      margin-left: calc(100% - 50px);
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;具体动画的效果：</p>
<p><img src="/images/css3/%E8%BF%90%E5%8A%A8%E7%9A%84%E5%B0%8F%E7%90%83.gif" alt="运动的小球"></p>
<p>&emsp;&emsp;如代码所示，外层class为box的div宽300px，里面放置一个直径为50px的小球，初始位置为外层div里的最左侧。设置外层div变为hover状态时，小球向右移动到外层div里的最右侧的过渡，过渡时间3s，过渡的时序函数用我们自定义贝塞尔曲线。可以看到小球先向左（反方向）由快到慢的移动，移出了外层div左侧一部分；在向右由慢到快再到慢的移动，特别是中间移动速度极快，停下来时也已移出了外层div最右侧一部分；然后在向左（反方向）由慢到快直至小球停到外层div里的最右侧。外层div失去焦点时小球的移动方式与获得焦点相反。可以看到小球移动的状态与设置时序函数的贝塞尔曲线的状态一致。</p>
<p>&emsp;&emsp;在这里再做一些dome实例的补充：</p>
<h4 id="1）旋转的筛子"><a href="#1）旋转的筛子" class="headerlink" title="1）旋转的筛子"></a>1）旋转的筛子</h4><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AD%9B%E5%AD%90.gif" alt="旋转的筛子"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .cube &#123;
      width: 100px;
      height: 100px;
      perspective: 500px;
      margin: 100px;
      transform-style: preserve-3d;
      animation: rotate 20s infinite;
      animation-timing-function: linear;
    &#125;
    .cube div &#123;
      position: absolute;
      transition: all .4s;
      width: 100px;
      height: 100px;
      opacity: 0.9;
    &#125;
    .cube div img &#123;
      width: 100%;
      height: 100%;
    &#125;
    .front &#123;
      transform: translateZ(50px);
    &#125;
    .back &#123;
      transform: translateZ(-50px);
    &#125;
    .left &#123;
      transform: rotateY(90deg) translateZ(50px);
    &#125;
    .right &#123;
      transform: rotateY(-90deg) translateZ(50px);
    &#125;
    .top &#123;
      transform: rotateX(90deg) translateZ(50px);
    &#125;
    .bottom &#123;
      transform: rotateX(-90deg) translateZ(50px);
    &#125;
    @keyframes rotate &#123;
      from &#123;
        transform: rotateX(0deg) rotateY(0deg);
      &#125;
      to &#123;
        transform: rotateX(360deg) rotateY(360deg);
      &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;cube&quot;&gt;
    &lt;div class=&quot;front&quot;&gt;&lt;img src=&quot;img/3.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;back&quot;&gt;&lt;img src=&quot;img/5.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;img/2.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;img src=&quot;img/4.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;top&quot;&gt;&lt;img src=&quot;img/1.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;bottom&quot;&gt;&lt;img src=&quot;img/6.jpg&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：先在外层class为box的div上设置了观测视角。再对class为cube的div元素设置了transform-style: preserve-3d，使其可以进行3D变换。再对其内部的6个面（实现方式不止代码所示的一种，变换过程中旋转与平移先后顺序不同代码就会不同。这里用图片简单表示骰子的1-6，通过Flex或是Grid布局实现也比较容易）进行相应的3D平移与旋转，布局成为一个立方体。再对class为cube的div元素添加了自定义的关键帧rotate旋转动画。</p>
<h4 id="2）边框滚动动画"><a href="#2）边框滚动动画" class="headerlink" title="2）边框滚动动画"></a>2）边框滚动动画</h4><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E8%BE%B9%E6%A1%86%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB.gif" alt="边框滚动动画"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .outer-box &#123;
      width: 300px; height: 100px; box-sizing: border-box; padding: 2px;
      background: repeating-linear-gradient(45deg, #000, #000 3px, transparent, #000 8px);
      animation: line 1s infinite linear;
    &#125;
    .inner-box &#123;
      width: 100%; height: 100%;
      background-color: #fff;
      display: flex; justify-content: center; align-items: center;
    &#125;
    @keyframes line &#123;
      0% &#123; background-position: 1px -1px; &#125;
      100% &#123; background-position: 12px -12px; &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;outer-box&quot;&gt;
    &lt;div class=&quot;inner-box&quot;&gt;- (^_^) -&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：这里将外层div设置为渐变的背景图片，2px内间距。内部div宽高100%，背景为白色，此时只见外层div出现类似于虚线边框的样式。加入自定义动画line，线性向右上方移动背景图片，便出现了边框滚动的效果。</p>
<h4 id="3）元素沿着不规则路径运动"><a href="#3）元素沿着不规则路径运动" class="headerlink" title="3）元素沿着不规则路径运动"></a>3）元素沿着不规则路径运动</h4><p>&emsp;&emsp;这里我们会用到offset-path等相关属性来实现，这个属性相对较新（要注意浏览器兼容），先介绍常用的属性：<br>&emsp;&emsp;<strong>offset-path：指定元素要遵循的运动路径以及元素位置。</strong>取值为：<br>&emsp;&emsp;&emsp;&emsp;ray() ：定义的一条路径<br>&emsp;&emsp;&emsp;&emsp;url()：引用SVG图片的URL<br>&emsp;&emsp;&emsp;&emsp;形状：circle()、 ellipse()、inset()、polygon()等<br>&emsp;&emsp;&emsp;&emsp;path()：用SVG坐标语法定义的路径字符串<br>&emsp;&emsp;<strong>offset-distance：指定要放置的元素沿路径偏移的位置（px，%）。</strong><br>&emsp;&emsp;<strong>offset-rotate：元素运动的角度（deg），默认auto，表示沿当前路径的切线方向前进。</strong></p>
<p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E4%B8%8D%E8%A7%84%E5%88%99%E8%BF%90%E5%8A%A8.gif" alt="不规则运动"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .box &#123; position: relative; &#125;
    .car &#123;
      offset-path: path(&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot;);
      animation: move 3s linear infinite;
      position: absolute; width: 50px; height: auto;
    &#125;
    @keyframes move &#123;
      100% &#123; offset-distance: 100%; &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;img/car.png&quot; width=&quot;40&quot; height=&quot;43&quot; class=&quot;car&quot;&gt;
    &lt;svg width=&quot;290px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
      &lt;path d=&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot; /&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：这里路径使用SVG图片，设置汽车的图片offset-path偏移路径为SVG中path字符串。自定义动画move使汽车每3s沿SVG路径进行偏移直至100%，便出现了汽车元素沿不规则路径移动的效果。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CSS布局（自适应、响应式、Layout）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/02/CSS%E5%B8%83%E5%B1%80%EF%BC%88%E8%87%AA%E9%80%82%E5%BA%94%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%81Layout%EF%BC%89/"
    >CSS布局（自适应、响应式、Layout）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/02/CSS%E5%B8%83%E5%B1%80%EF%BC%88%E8%87%AA%E9%80%82%E5%BA%94%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%81Layout%EF%BC%89/" class="article-date">
  <time datetime="2020-11-02T06:22:39.000Z" itemprop="datePublished">2020-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于盒状模型，依赖 display、 position、float、margin、paddding等属性，采用绝对的单位px、相对单位em、vw、vh、rem以及百分比%等单位进行页面设计。本文将从静态布局、流式布局、自适应布局、响应式布局、弹性布局几个方面进行介绍。</p>
<h2 id="1、静态布局"><a href="#1、静态布局" class="headerlink" title="1、静态布局"></a>1、静态布局</h2><p>&emsp;&emsp;页面采用px单位，一般会设置min-width属性，当页面尺寸小于这个宽度时，出现滚动条进行相应显示，当页面尺寸大于这个宽度时，内容区域一般设置居中显示。使用浮动（float）、定位（position）对元素进行相应的布局<br>&emsp;&emsp;优点：设计简单，编码简单，不用考虑兼容性问题<br>&emsp;&emsp;缺点：有兼容性问题，针对不同的屏幕显示方式一致，对个别用户很不友好。有时也会JS动态修改标签的initial-scale使得页面相应等比缩放，效果有限</p>
<h2 id="2、流式布局"><a href="#2、流式布局" class="headerlink" title="2、流式布局"></a>2、流式布局</h2><p>&emsp;&emsp;页面宽度采用%（百分比）进行布局，高度一般使用px进行设置，或设置为auto并结合margin、paddding进行布局。宽度会随着浏览器宽度进行相应的调整，为了防止对应区域过大或过小使得内容超出区域，一般结合max-width与max-width进行设置。这种布局整体布局方式不变，即页面元素间相对位置不变，文字大小一般使用px，不随页面尺寸变化而变化。布局方式的代表如栅格系统（将网页页面按比例分成对应行列来排列页面中元素的分布）<br>&emsp;&emsp;优点：在一定范围内，能较好的应对不同的PC端页面<br>&emsp;&emsp;缺点：不适应与PC端到移动端较大的尺寸跨度，元素区域过大过小很导致显示不友好。文字大小不随页面宽度变化而变化，在不同屏幕会出现页面不协调的情况</p>
<h2 id="3、自适应布局"><a href="#3、自适应布局" class="headerlink" title="3、自适应布局"></a>3、自适应布局</h2><p>&emsp;&emsp;自适应网页设计的核心，就是CSS3引入的媒体查询模块（@media）。自动探测屏幕宽度，然后加载相应的CSS文件<br>&emsp;&emsp;采用媒体查询技术，为不同屏幕分辨率定义布局，即定义多个静态布局，每个静态布局对应一个屏幕范围，可对页面元素尺寸与位置进行相应的调整，对文字尺寸等也可以特殊设置或使用百分比%、em，rem，vh、vw等相对单位</p>
<p>&emsp;&emsp;特别的，其中：<br>&emsp;&emsp;百分比 %是相对于父元素大小的百分比大小<br>&emsp;&emsp;em是最常见的相对长度单位，基准值是当前元素的字号大小<br>&emsp;&emsp;rem代表“ root”：“ root em”，它等于固定在root元素上的字体大小<br>&emsp;&emsp;vh和vw更多是PC端响应式Web设计依赖百分比规则,尺寸vh等于视口高度的1/100，尺寸vw等于视口宽度的1/100。但CSS百分比度量并非始终是解决所有问题的最佳解决方案<br>&emsp;&emsp;<u>在移动设备中，物理设备上的1px一般不等于css的1px像素，在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px、1024px等值，带来的后果就是浏览器会出现横向滚动条。</u>为了避免这种情况，在移动端页面设计时，让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，使用下面的代码使viewport的宽度等于设备的宽度，即即网页初始大小占屏幕面积的100%</p>
<pre><code>  // 网页宽度等于屏幕宽度（width=device-width），原始缩放比例为1.0（initial-scale=1）
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
</code></pre>
<p>&emsp;&emsp;优点：对PC端、移动端不同屏幕尺寸变化时，页面元素都会进行相应的调整，有较好的适应能力<br>&emsp;&emsp;缺点：为了使不同设备达到较好的，对各个不同屏幕尺寸范围会进行长时间的设计与调整，过程中也会产生大量的冗余代码</p>
<h2 id="4、响应式布局"><a href="#4、响应式布局" class="headerlink" title="4、响应式布局"></a>4、响应式布局</h2><p>&emsp;&emsp;<u>个人认为，响应式布局是比适应布局更高级，是自适应布局的优化；自适应布局是响应式布局的一个子集。它们都会使用媒体查询（@media）根据不同的访问设备的宽度加载不同的样式。</u>如果要说区别的话，或许自适应式只考虑了屏幕尺寸大小，主要使用媒体查询技术来相应的适应性调整，而响应式布局可能还会考虑到移动设备的触屏操作、页面元素排版是否合理，是否需要对元素的位置重新进行调整等问题。</p>
<h2 id="5、弹性布局（Flex布局）"><a href="#5、弹性布局（Flex布局）" class="headerlink" title="5、弹性布局（Flex布局）"></a>5、弹性布局（Flex布局）</h2><p>&emsp;&emsp;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性,可以简便、完整、响应式地实现各种页面布局。具体布局方式在上一篇文章(CSS布局类型（Display、Flex、Grid）)已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-1-Flex%E5%B8%83%E5%B1%80">Display Flex 传送门</a></p>
<h2 id="6、网格布局（Grid布局）"><a href="#6、网格布局（Grid布局）" class="headerlink" title="6、网格布局（Grid布局）"></a>6、网格布局（Grid布局）</h2><p>&emsp;&emsp;Grid 布局是目前最强大的布局方案。Grid 布局与Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。Flex 布局是轴线布局，只能指定项目针对轴线(主轴、交叉轴)的位置，可以看作是一维布局。Grid 布局则是将容器划分成行与列，产生单元格，然后指定项目所在的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。具体布局方式在上一篇文章已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-2-Grid%E5%B8%83%E5%B1%80">Display Grid 传送门</a></p>
<p><em>[注] 在页面的实际设计中，为了使页面达到更合理的布局方式。我们往往会根据布局要求采用多种布局方式来达到我们的目的</em></p>
<h2 id="题外话1-格式化上下文"><a href="#题外话1-格式化上下文" class="headerlink" title="题外话1 格式化上下文"></a>题外话1 格式化上下文</h2><p>&emsp;&emsp;格式化上下文(Block Formatting Context，BFC)是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域<br>&emsp;&emsp;创建BFC的方式：<br>&emsp;&emsp;根元素（html）<br>&emsp;&emsp;浮动元素（元素的 float 不是 none）<br>&emsp;&emsp;绝对定位元素（元素的 position 为 absolute 或 fixed）<br>&emsp;&emsp;行内块元素（元素的 display 为 inline-block）<br>&emsp;&emsp;表格元素（元素的 display 为 table-cell、table-caption等，HTML表格单元格默认为该值）<br>&emsp;&emsp;overflow 值不为 visible 的块元素（一般这种方式用得最多：overflow: hidden/auto）<br>&emsp;&emsp;弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）<br>&emsp;&emsp;网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p>
<p>&emsp;&emsp;BFC布局规则：<br>&emsp;&emsp;① 内部的块级元素会在垂直方向，依次排列<br>&emsp;&emsp;② 外边距塌陷现象，属于同一个BFC的两个相邻元素的margin会发生重叠（在其中一个元素外面添加一个BFC区域来清除外边距塌陷）<br>&emsp;&emsp;③ 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此<br>&emsp;&emsp;④ BFC的区域不会与浮动元素重叠，即浮动不会影响其它BFC中元素的布局<br>&emsp;&emsp;&emsp;&emsp;应用：<u>自适应两栏布局</u><br>&emsp;&emsp;⑤ BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然<br>&emsp;&emsp;⑥ 计算BFC的高度时，浮动元素也参与计算，即浮动元素不会超出BFC区域的边界<br>&emsp;&emsp;&emsp;&emsp;应用：<u>利用BFC特性来清除浮动</u>、<u>布局文本环绕图像样式</u>（也可以通过clearfix清除浮动来实现）</p>
<h2 id="题外话2-clearfix清除浮动"><a href="#题外话2-clearfix清除浮动" class="headerlink" title="题外话2 clearfix清除浮动"></a>题外话2 clearfix清除浮动</h2><p>&emsp;&emsp;原理：clear <strong>属性定义了元素的哪边上不允许出现浮动元素。</strong> <u>如果声明为左边或右边清除(clear: both;)，会使父元素内部之前添加的伪元素的上外边框边界刚好在浮动元素的下外边距边界之下，使得父元素的高度能够超过浮动元素的高度，从而达到清除浮动的目的</u></p>
<p>&emsp;&emsp;代码：</p>
<pre><code>  .box:after &#123;
    content: &#39;&#39;;
    display: block;
    clear: both;
    *zoom: 1;
    // visibility: hidden;
    // height: 0;
    // font-size: 0;
  &#125;
</code></pre>
<h2 id="题外话3-CSS其他知识"><a href="#题外话3-CSS其他知识" class="headerlink" title="题外话3 CSS其他知识"></a>题外话3 CSS其他知识</h2><p>&emsp;&emsp;css模块化有css-in-js的概念，有BEM（block element modifier）命名规范，有less、sass预处理器等方面知识。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CSS布局类型（Display、Flex、Grid）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/"
    >CSS布局类型（Display、Flex、Grid）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/" class="article-date">
  <time datetime="2020-09-27T07:12:22.000Z" itemprop="datePublished">2020-09-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>display属性规定元素应该生成的框的类型。display 属性可以设置元素的内部和外部显示类型 display types。元素的外部显示类型 outer display types 将决定该元素在流式布局中的表现（块级或内联元素）；元素的内部显示类型 inner display types 可以控制其子元素的布局（如 flow layout，grid 或 flex）。</p>
<p>display 属性使用关键字取值来指定，关键字取值被分为六类：</p>
<pre><code>  &lt;display-outside&gt; = block | inline | run-in
  &lt;display-inside&gt; = flow | flow-root | table | flex | grid | ruby
  &lt;display-listitem&gt; = list-item
  &lt;display-internal&gt; = table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container
  &lt;display-box&gt; = contents | none
  &lt;display-legacy&gt; = inline-block | inline-list-item | inline-table | inline-flex | inline-grid
</code></pre>
<h2 id="1、display-outside类型"><a href="#1、display-outside类型" class="headerlink" title="1、display-outside类型"></a>1、display-outside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的外部显示类型，实际上就是其在流式布局中的角色（即在流式布局中的表现）。<br>&emsp;&emsp;block：此元素将显示为块级元素，此元素前后会带有换行符<br>&emsp;&emsp;inline：默认值，此元素会被显示为内联元素，元素前后没有换行符<br>&emsp;&emsp;run-in：此元素会根据上下文作为块级元素或内联元素显示</p>
<p><em>&emsp;&emsp;[注]如果 run-in box 包含 block box，那么这个 run-in box 也成为 block box；如果紧跟在 run-in box 之后的兄弟节点是 block box，那么这个 run-in box 就会做为此 block box 里的 inline box（run-in box 不能进入已经一个已经以 run-in box 开头的块内，也不能进入本身就是 display:run-in的块内）；否则，run-in box 都将成为 block box</em></p>
<h2 id="2、display-inside类型"><a href="#2、display-inside类型" class="headerlink" title="2、display-inside类型"></a>2、display-inside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的内部显示类型，它们定义了该元素内部内容的布局方式。<br>&emsp;&emsp;flow：元素使用流布局（块和内联布局）布局其内容<br><em>&emsp;&emsp;[注] 如果其外部显示类型为inline或run-in，并且它参与了块或内联格式设置上下文，则它将生成一个内联框。否则，它将生成一个块容器框</em><br>&emsp;&emsp;flow-root：该元素生成一个块元素框，该框将建立一个新的块格式化上下文，定义格式化根所在的位置<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 table ），表格前后带有换行符<br>&emsp;&emsp;flex：元素的行为类似于block元素，并根据flexbox模型布置其内容<br>&emsp;&emsp;grid: 元素的行为类似于块元素，并根据网格模型布置其内容<br>&emsp;&emsp;ruby: 元素的行为类似于内联元素，并根据ruby格式化模型布置其内容。它的行为类似于相应的HTML ruby元素</p>
<h4 id="emsp-emsp-1-Flex布局"><a href="#emsp-emsp-1-Flex布局" class="headerlink" title="&emsp;&emsp;1) Flex布局"></a>&emsp;&emsp;1) Flex布局</h4><p>&emsp;&emsp;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”，Flex 容器有主轴与交叉轴两个方向。<br><img src="/images/css3/Flex%E5%AE%B9%E5%99%A8.png" alt="Flex容器"></p>
<p>&emsp;&emsp;<strong>(1) Flex容器的属性：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</strong></p>
<p>&emsp;&emsp;① flex-direction属性决定主轴的方向（即项目的排列方向）</p>
<pre><code>  flex-direction: row | row-reverse | column | column-reverse;
</code></pre>
<p><img src="/images/css3/flex-direction%E5%B1%9E%E6%80%A7.png" alt="flex-direction属性"></p>
<p>&emsp;&emsp;row（默认值）：主轴为水平方向，起点在左端<br>&emsp;&emsp;row-reverse：主轴为水平方向，起点在右端<br>&emsp;&emsp;column：主轴为垂直方向，起点在上沿<br>&emsp;&emsp;column-reverse：主轴为垂直方向，起点在下沿</p>
<p>&emsp;&emsp;② flex-warp属性决定项目排列超过容器宽度时是否换行</p>
<pre><code>    flex-wrap: nowrap | wrap | wrap-reverse;
</code></pre>
<p><img src="/images/css3/flex-warp%E5%B1%9E%E6%80%A7.png" alt="flex-warp属性"></p>
<p>&emsp;&emsp;nowrap(默认)：不换行<br>&emsp;&emsp;wrap：换行，首行在上方<br>&emsp;&emsp;wrap-reserve：换行，首行在下方</p>
<p>&emsp;&emsp;③ flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>
<pre><code>    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;
</code></pre>
<p>&emsp;&emsp;④ justify-content属性定义了项目在主轴上的对齐方式</p>
<pre><code>    justify-content: flex-start | flex-end | center | space-between | space-around;
</code></pre>
<p><img src="/images/css3/justify-content%E5%B1%9E%E6%80%A7.png" alt="justify-content属性"></p>
<p>&emsp;&emsp;flex-start（默认值）：左对齐<br>&emsp;&emsp;flex-end：右对齐<br>&emsp;&emsp;center： 居中<br>&emsp;&emsp;space-between：两端对齐，项目之间的间隔都相等<br>&emsp;&emsp;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</p>
<p>&emsp;&emsp;⑤ align-items属性定义项目在交叉轴上如何对齐</p>
<pre><code>    align-items: flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p><img src="/images/css3/align-items%E5%B1%9E%E6%80%A7.png" alt="align-items属性"></p>
<p>&emsp;&emsp;flex-start：交叉轴的起点对齐<br>&emsp;&emsp;flex-end：交叉轴的终点对齐<br>&emsp;&emsp;center：交叉轴的中点对齐<br>&emsp;&emsp;baseline: 项目的第一行文字的基线对齐<br>&emsp;&emsp;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</p>
<p>&emsp;&emsp;⑥ align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>
<pre><code>    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
</code></pre>
<p>&emsp;&emsp;flex-start：与交叉轴的起点对齐<br>&emsp;&emsp;flex-end：与交叉轴的终点对齐<br>&emsp;&emsp;center：与交叉轴的中点对齐<br>&emsp;&emsp;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>&emsp;&emsp;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍<br>&emsp;&emsp;stretch（默认值）：轴线占满整个交叉轴</p>
<p>&emsp;&emsp;<strong>(2)Flex项目的属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self</strong></p>
<p>&emsp;&emsp;① order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<pre><code>  order: &lt;integer&gt;;
</code></pre>
<p>&emsp;&emsp;② flex-grow属性定义项目的放大比例（整体布局存在剩余空间），默认为0，即如果存在剩余空间，也不放大</p>
<pre><code>  flex-grow: &lt;number&gt;; /* default 0 */
</code></pre>
<p>&emsp;&emsp;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>&emsp;&emsp;③ flex-shrink属性定义了项目的缩小比例（整体布局空间不足），默认为1，即如果空间不足，该项目将缩小</p>
<pre><code>  flex-shrink: &lt;number&gt;; /* default 1 */
</code></pre>
<p>&emsp;&emsp;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>&emsp;&emsp;④ flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小</p>
<pre><code>  flex-basis: &lt;length&gt; | auto; /* default auto */
</code></pre>
<p>&emsp;&emsp;可设与width或height属性一样的值（比如200px，则项目将占据固定空间）。</p>
<p>&emsp;&emsp;⑤ flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选</p>
<pre><code>  flex: none | [ &lt;flex-grow&gt; || &lt;flex-shrink&gt;? || &lt;flex-basis&gt;? ]
</code></pre>
<p>&emsp;&emsp;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>&emsp;&emsp;⑥ align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
<pre><code>  align-self: auto | flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p>&emsp;&emsp;该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h4 id="emsp-emsp-2-Grid布局"><a href="#emsp-emsp-2-Grid布局" class="headerlink" title="&emsp;&emsp;2) Grid布局"></a>&emsp;&emsp;2) Grid布局</h4><p>&emsp;&emsp;将网页划分成一个个网格，可以任意组合不同的网格。Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可看作是二维布局。Grid 布局远比 Flex 布局强大。同样的，grid布局中也有容器与项目的概念。<br>&emsp;&emsp;grid布局将容器分为行和列，行和列的交叉区域称为单元格<strong>（区域）</strong>。正常情况下，n行和m列会产生n x m个单元格（可能有跨行与跨列等布局状态）。<br>&emsp;&emsp;容器中划分网格的线，称为”网格线”。水平网格线划分出行，垂直网格线划分出列。正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线。<br><img src="/images/css3/Grid%E5%AE%B9%E5%99%A8.png" alt="Grid容器"></p>
<p>&emsp;&emsp;<strong>(1) Grid容器的属性：</strong><br>&emsp;&emsp;grid-template-columns、grid-template-rows（容器划分行和列）<br>&emsp;&emsp;grid-row-gap、grid-columns-gap、grid-gap（行与行、列于列的间距）<br>&emsp;&emsp;grid-template-areas（网格布局给区域命名）<br>&emsp;&emsp;grid-auto-flow（容器中放置项目顺序设置，如先行后列，是否紧密填满）<br>&emsp;&emsp;justify-items、align-items、place-items（单元格内元素水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-content、align-content、place-content（容器中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;grid-auto-columns、grid-auto-rows（超出容器项目的行、列设置）<br>&emsp;&emsp;grid-template、grid（简写属性）</p>
<p>&emsp;&emsp;① grid-template-columns、grid-template-rows属性<br>&emsp;&emsp;容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。下面以列宽设置为例，行高设置同理。</p>
<pre><code>  .container &#123;
    display: grid;
    grid-template-rows: [R1]100px [R2]100px [R3]100px[R4]; // 设置网格线名称（网格线有多个名称，默认为1、2、3...)）
    // 1、px设置行宽
    grid-template-columns: [C1]100px [C2]100px [C3]100px[C4]; // 设置网格线名称
   // 2、百分比设置行宽
    grid-template-columns: 33.33% 33.33% 33.33%;
    // 3、repeat()重复行宽设置，也可重复某一模式
    grid-template-columns: repeat(3, 33.33%);
    // 4、auto-fill关键字自动填充列
    grid-template-columns: repeat(auto-fill, 100px);
    // 5、fr关键字按比例划分列宽
    grid-template-columns: 150px 1fr 2fr;
    // 6、minmax()函数设置某一列宽范围
    grid-template-columns: 1fr 1fr minmax(100px, 1fr);
    // 7、auto关键字列宽自适应
    grid-template-columns: 100px auto 100px;
  &#125;
</code></pre>
<p><img src="/images/css3/grid-template%E5%B1%9E%E6%80%A7.png" alt="grid-template属性"></p>
<p>&emsp;&emsp;② grid-row-gap、grid-columns-gap、grid-gap属性<br>&emsp;&emsp;grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。grid-gap为行列间距两属性的简写属性。</p>
<pre><code>  .container &#123;
    grid-row-gap: 20px;
    grid-column-gap: 20px;
 &#125;
</code></pre>
<p><img src="/images/css3/grid-gap%E5%B1%9E%E6%80%A7.png" alt="grid-gap属性"></p>
<p>&emsp;&emsp;③ grid-template-areas属性<br>&emsp;&emsp;网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。<br><em>&emsp;&emsp;[注] 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</em></p>
<pre><code>  grid-template-areas: &#39;A B C&#39; &#39;D . F&#39; &#39;G H I&#39;;
</code></pre>
<p><img src="/images/css3/grid-template-areas%E5%B1%9E%E6%80%A7.png" alt="grid-template-areas属性"></p>
<p>&emsp;&emsp;④ grid-auto-flow属性<br>&emsp;&emsp;划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。</p>
<p><img src="/images/css3/grid-auto-flow%E5%B1%9E%E6%80%A7.png" alt="grid-auto-flow属性"></p>
<p>&emsp;&emsp;⑤ justify-items 、align-items、place-items 属性（设置单元格内容的位置）<br>&emsp;&emsp;justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。place-items属性是align-items属性和justify-items属性的合并简写形式。</p>
<pre><code>  .container &#123; 
    justify-items: start | end | center | stretch;
    align-items: start | end | center | stretch;
  &#125;
</code></pre>
<p>&emsp;&emsp;start：对齐单元格的起始边缘<br>&emsp;&emsp;end：对齐单元格的结束边缘<br>&emsp;&emsp;center：单元格内部居中<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p>&emsp;&emsp;⑥ justify-content 、align-content、place-content属性（设置整个内容区域在容器里面的的位置）<br>&emsp;&emsp;justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。place-content属性是align-content属性和justify-content属性的合并简写形式。</p>
<pre><code>  .container &#123;
    justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
    align-content: start | end | center | stretch | space-around | space-between | space-evenly;
  &#125;
</code></pre>
<p>&emsp;&emsp;start - 对齐容器的起始边框<br>&emsp;&emsp;end - 对齐容器的结束边框<br>&emsp;&emsp;center - 容器内部居中<br>&emsp;&emsp;stretch - 项目大小没有指定时，拉伸占据整个网格容器<br>&emsp;&emsp;space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍<br>&emsp;&emsp;space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔<br>&emsp;&emsp;space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p>
<p>&emsp;&emsp;⑦ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;当项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。grid-auto-columns属性和grid-auto-rows属性用来设置浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>&emsp;&emsp;⑧ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。<br>&emsp;&emsp;grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<p>&emsp;&emsp;<strong>(2) Grid项目的属性：</strong><br>&emsp;&emsp;grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column、grid-row（设置项目位置简写属性）<br>&emsp;&emsp;grid-area（指定项目放置的区域）<br>&emsp;&emsp;justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）</p>
<p>&emsp;&emsp;① grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column-start属性：左边框所在的垂直网格线<br>&emsp;&emsp;grid-column-end属性：右边框所在的垂直网格线<br>&emsp;&emsp;grid-row-start属性：上边框所在的水平网格线<br>&emsp;&emsp;grid-row-end属性：下边框所在的水平网格线</p>
<pre><code>  .item_1&#123;
    grid-column-start: 2;
    grid-row-start: 2;
    grid-column-end: 3;
    grid-row-end: 3;
  &#125;
</code></pre>
<p><img src="/images/css3/Grid%E9%A1%B9%E7%9B%AE%E4%BD%8D%E7%BD%AE.png" alt="Grid项目位置"></p>
<p><em>&emsp;&emsp;[注] 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 如: grid-column-start:  span 2; 必要的时候，可使用z-index设置项目重叠顺序</em></p>
<p>&emsp;&emsp;② grid-column、grid-row属性<br>&emsp;&emsp;grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的简写形式，属性值取值用用’/‘分割</p>
<p>&emsp;&emsp;③ grid-area属性<br>&emsp;&emsp;grid-area属性指定项目放在哪一个区域</p>
<pre><code>  .item-1 &#123;
    grid-area: &#39;I&#39;; // I是grid-template-areas属性指定的区域
  &#125;
</code></pre>
<p><img src="/images/css3/grid-area%E5%B1%9E%E6%80%A7.png" alt="grid-area属性"></p>
<p><em>&emsp;&emsp;[注] grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的简写形式来指定项目位置。形如：grid-area: row-start / column-start / row-end / column-end; 属性值间取值用’/‘分割，上图的设置相当于：grid-area:  2 / 2 / 3 / 3;</em></p>
<p>&emsp;&emsp;④ justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目<br>&emsp;&emsp;align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目</p>
<pre><code>  .item &#123;
    justify-self: start | end | center | stretch;
    align-self: start | end | center | stretch;
  &#125;
</code></pre>
<p>&emsp;&emsp;start：对齐单元格的起始边缘。<br>&emsp;&emsp;end：对齐单元格的结束边缘。<br>&emsp;&emsp;center：单元格内部居中。<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p><em>&emsp;&emsp;[注] g place-self属性是align-self属性和justify-self属性的简写形式。当省略第二个值时，place会默认这两个属性值相等</em></p>
<h2 id="3、display-listitem类型"><a href="#3、display-listitem类型" class="headerlink" title="3、display-listitem类型"></a>3、display-listitem类型</h2><p>&emsp;&emsp;将这个元素的外部显示类型变为 block 盒子，并将内部显示类型变为多个 list-item inline盒子。<br>&emsp;&emsp;list-item：使元素的行为类似于列表项。可以与list-style-type和list-style-position一起使用，也可以与任何display-outside关键字和flow或flow-root display-inside关键字组合</p>
<h2 id="4、display-internal类型"><a href="#4、display-internal类型" class="headerlink" title="4、display-internal类型"></a>4、display-internal类型</h2><p>&emsp;&emsp;有些布局模型（如 table 和 ruby）有着复杂的内部结构，因此它们的子元素可能扮演着不同的角色。这一类关键字就是用来定义这些“内部”显示类型，并且只有在这些特定的布局模型中才有意义。<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 table），表格前后带有换行符<br>&emsp;&emsp;table-row-group：这些元素的行为类似于tbody HTML元素<br>&emsp;&emsp;table-header-group：这些元素的行为类似于thead HTML元素<br>&emsp;&emsp;table-footer-group：这些元素的行为类似于tfoot HTML元素<br>&emsp;&emsp;table-row：这些元素的行为类似于tr HTML元素<br>&emsp;&emsp;table-cell：这些元素的行为类似于td HTML元素<br>&emsp;&emsp;table-column-group：这些元素的行为类似于colgroup HTML元素<br>&emsp;&emsp;table-column：这些元素的行为类似于col HTML元素<br>&emsp;&emsp;table-caption：这些元素的行为类似于caption HTML元素<br>&emsp;&emsp;ruby-base：这些元素的行为类似于rb HTML元素<br>&emsp;&emsp;ruby-text：这些元素的行为类似于rt HTML元素<br>&emsp;&emsp;ruby-base-container：这些元素的行为类似于rbc生成为匿名框的HTML元素<br>&emsp;&emsp;ruby-text-container：这些元素的行为类似于rtc HTML元素</p>
<h2 id="5、display-inside类型"><a href="#5、display-inside类型" class="headerlink" title="5、display-inside类型"></a>5、display-inside类型</h2><p>&emsp;&emsp;这些值决定元素是否使用盒模型。<br>&emsp;&emsp;contents：这些元素本身不会产生特定的框。它们被伪框和子框替换<br>&emsp;&emsp;none：此元素不会被显示</p>
<h2 id="6、display-legacy类型"><a href="#6、display-legacy类型" class="headerlink" title="6、display-legacy类型"></a>6、display-legacy类型</h2><p>&emsp;&emsp;CSS 2 对于 display 属性使用单关键字语法，对于相同布局模式的 block 级和 inline 级变体需要使用单独的关键字。<br>&emsp;&emsp;inline-block：行内块元素，等同于inline flow-root<br>&emsp;&emsp;inline-table：此元素会作为内联表格来显示（类似 table），表格前后没有换行符，等同于inline table<br>&emsp;&emsp;<strong>inline-flex：元素的行为类似于内联元素，并根据flexbox模型布置其内容，等同于inline flex</strong><br>&emsp;&emsp;<strong>inline-grid：元素的行为类似于内联元素，并根据网格模型布置其内容，等同于inline grid</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CSS定位（Position）与3D坐标轴"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/27/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88Position%EF%BC%89%E4%B8%8E3D%E5%9D%90%E6%A0%87%E8%BD%B4/"
    >CSS定位（Position）与3D坐标轴</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/27/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88Position%EF%BC%89%E4%B8%8E3D%E5%9D%90%E6%A0%87%E8%BD%B4/" class="article-date">
  <time datetime="2020-09-27T06:59:46.000Z" itemprop="datePublished">2020-09-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>用于指定一个元素在文档中的定位方式（元素在网页上的位置），对应的属性top，right，bottom 和 left属性则决定了该元素的最终位置。</p>
<h2 id="1、平面空间坐标轴（2D）"><a href="#1、平面空间坐标轴（2D）" class="headerlink" title="1、平面空间坐标轴（2D）"></a>1、平面空间坐标轴（2D）</h2><p>&emsp;&emsp;在CSS平初始坐标系从屏幕左上角向右为X轴，从左上角向下为Y轴。在position定位方式中，其中top、right、bottom和left代表元素距离参考上方、右方、下方与左方的距离。</p>
<p><img src="/images/css3/%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="平面空间坐标轴"></p>
<h2 id="2、定位类型"><a href="#2、定位类型" class="headerlink" title="2、定位类型"></a>2、定位类型</h2><p>&emsp;&emsp;position的取值：static、relative, absolute, fixed，sticky与inherit<br>&emsp;&emsp;定位元素：是其计算后位置属性为relative,absolute,fixed或sticky的一个元素<br>&emsp;&emsp;(1) 默认定位(static)：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。<br>&emsp;&emsp;(2) 相对定位(relative)：相对于自己最初的位置进行定位，相对位置的坐标参考系是以自己定位前在文档流的位置（x，y）作为原点（0，0）。在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。而且position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p>
<p><img src="/images/css3/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D(relative).png" alt="相对定位(relative)"></p>
<p>&emsp;&emsp;(3) 绝对定位(absolute/fixed)：绝对定位的元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。特别的，fixed绝对定位-固定定位是相对于浏览器窗口（viewport）进行定位，元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p>
<p><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(absolute).png" alt="绝对定位(absolute)"><br><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(fixed).png" alt="绝对定位(fixed)"></p>
<p>&emsp;&emsp;(4) 粘性定位(sticky)：元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。粘性定位表现为相对定位和固定定位叠加的效果。元素在跨越特定阈值前为相对定位(relative)，之后为固定定位(fixed)。</p>
<p><img src="/images/css3/%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D(sticky).png" alt="粘性定位(sticky)"></p>
<h2 id="3、三维空间坐标轴（3D）"><a href="#3、三维空间坐标轴（3D）" class="headerlink" title="3、三维空间坐标轴（3D）"></a>3、三维空间坐标轴（3D）</h2><p>&emsp;&emsp;CSS中3D初始坐标系，其XYZ轴的正方向分别是：向右、向下、向屏幕外。如下图：</p>
<p><img src="/images/css3/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="三维空间坐标轴"></p>
<p>&emsp;&emsp;对一个元素设置属性 transform-style为preserve-3d ，便可对其进行3D变换，有translateX()，translateY()，translateZ()平移方法以及rotateX()，rotateY()，rotateZ()等旋转方法。一般会对元素设置 perspective 属性来调整元素观测的视角。默认旋转中心为左上角（0,0），可通过transform-origin对旋转中心进行移动。<u>当transform使用多个变换函数时，每一个变换函数不仅改变了元素，同时也会改变和元素关联的transform坐标系，当变换函数依次执行时，后一个变换函数总是基于前一个变换后的新transform坐标系执行，所有要注意变换函数的顺序。</u><br>&emsp;&emsp;(1) 对于平移，参照对应坐标轴方向进行相应的平移变换即可。<br>&emsp;&emsp;(2) 对于旋转，先要判断旋转方向，正对某一轴正，其顺时针方向就是该轴旋转的方向，或者采用左手法则判断旋转方向（即左手握住旋转轴，竖起拇指指向旋转轴正方向，其余手指卷曲方向为正方向）；再根据旋转中心的位置进行相应的旋转变换。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Xiong Gang
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="码农日志"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我吃个雪糕吧，谢谢~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay-payment-code.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat-payment-code.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>