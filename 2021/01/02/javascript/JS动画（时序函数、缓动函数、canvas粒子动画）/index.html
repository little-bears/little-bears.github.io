<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>JS动画（时序函数、缓动函数、canvas粒子动画） |  码农日志</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="码农日志" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-javascript/JS动画（时序函数、缓动函数、canvas粒子动画）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JS动画（时序函数、缓动函数、canvas粒子动画）
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/01/02/javascript/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/" class="article-date">
  <time datetime="2021-01-02T13:01:58.000Z" itemprop="datePublished">2021-01-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">22 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>CSS动画很强大，特别是CSS3动画。可以进行通过transform的2D/3D变换，以及改变高宽，方位，角度，透明度等，再结合transition过渡属性或者@keyframes规则，能做到几乎完美。但CSS动画也有一些局限，比如不能设置浏览器相关的属性，如scrollTop等。且对于canvas等动画（以及粒子动画），还是要利用计时器（setTimeout、setInterval）或者浏览器重绘回调函数（requestAnimationFrame），通过JavaScript动态更新元素状态来实现。此外，canvas小游戏的逻辑实现也必须使用JavaScript去处理用户鼠标键盘等交互事件，才能完成对应的动画以及功能。JavaScript动画还可以实现沿着其他<strong>自定义时序函数</strong>的进行移动与变化。</p>
<h2 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h2><h4 id="1）setTimeout（setInterval）与requestAnimationFrame对比"><a href="#1）setTimeout（setInterval）与requestAnimationFrame对比" class="headerlink" title="1）setTimeout（setInterval）与requestAnimationFrame对比"></a>1）setTimeout（setInterval）与requestAnimationFrame对比</h4><p>&emsp;&emsp;(1)setTimeout/setInterval：</p>
<p>&emsp;&emsp;① 计时器的回调的执行时是在内存中对元素属性进行相应的改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上（一般为16.7ms刷新一次）。setTimeout的执行步调和屏幕的刷新步调不一致。就会导致中间某些帧的更新被跳过，照成动画卡顿。比如计时器设置10ms更新一次（帧），而屏幕刷新时间间隔为16.7ms，此时就会出现丢帧现象(即有的内存中元素状态的更新（帧）没来得及被浏览器渲染就被覆盖了)。其实只要计时器设置的更新时间小于16.7ms，就会导致丢帧。<br>&emsp;&emsp;② setTimeout/setInterval 放在异步队列里执行，主线程同步任务会阻塞异步队列的任务，设置的间隔时间不一定是回调执行的时间间隔。同样会造成动画卡顿（停顿）的现象。</p>
<p><em>&emsp;&emsp;[注] 前面已讲过 <a href="/2020/12/25/javascript/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">定时器相关概念</a>，可点击查看~</em></p>
<p>&emsp;&emsp;③ 使用setTimeout等实现的动画，当页面被隐藏或最小化时，setTimeout仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画浪费 CPU 资源和电池寿命。</p>
<p>&emsp;&emsp;(2) requestAnimationFrame（标准动画时序，浏览器在下次重绘之前调用指定的回调函数来更新动画）：</p>
<p>&emsp;&emsp;① 与setTimeout等相比，requestAnimationFrame最大的优势是由浏览器来决定回调函数的执行时机，即紧跟浏览器的刷新步调，不会出现丢帧现象。</p>
<p>&emsp;&emsp;② 当页面处于未激活的状态下，该页面的屏幕绘制任务也会被浏览器暂停，跟着浏览器步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画才会恢复继续执行，有效节省了 CPU 资源与电池寿命。<br>&emsp;&emsp;③ 在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame 有节流的作用，可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。</p>
<p><em>&emsp;&emsp;[注] 通过对比，requestAnimationFrame 要比 setTimeout/setInterval 性能好。<u>特别的，requestAnimationFrame回调函数会被传入DOMHighResTimeStamp参数（一个double类型，用于存储毫秒级的时间值），DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳。</u></em></p>
<h4 id="2）JS动画中的时序函数"><a href="#2）JS动画中的时序函数" class="headerlink" title="2）JS动画中的时序函数"></a>2）JS动画中的时序函数</h4><p>&emsp;&emsp;<u>时序函数就是动画完成情况与时间的关系（一般时序函数的图像也是从（0,0）变化到（1,1），代表动画执行时间到达时动画刚好执行完成）。</u>在JS动画中我们可以更灵活的自定义这种关系，即定义更加多样的时序函数，例如n次幂等满足经过（0,0）变化到（1,1）的曲线都可以作为时序函数。</p>
<p>&emsp;&emsp;为了代码的结构以及代码的可复用，这里编写一个<u>通用的动画函数</u>，放在单独的animate.js文件中：（其中时序函数timing也作为参数传入）</p>
<pre><code>  // animate.js
  function animate(&#123; duration, timing, draw &#125;) &#123;
    let startTime = performance.now(); // 获得一个一个精确到毫秒的DOMHighResTimeStamp来标识动画开始时间
    requestAnimationFrame(function animate(executionTime) &#123; // executionTime为requestAnimationFrame的本次回调函数触发执行时间
      let time = (executionTime - startTime) / duration; // 计算当当前动画已经执行时间与动画延迟总时间的比值，
      // 其值为时序函数的x轴的值（为0代表动画开始执行，1代码动画执行结束）
      if (time &gt; 1) time = 1;
      let progress = timing(time) // 计算当前时间节点动画完成进度，其值为时序函数y轴的值
      draw(progress); // 根据当前动画完成进度更新动画
      if (time &lt; 1) &#123; // 动画未完成，继续更新
        requestAnimationFrame(animate); // 这里animate为function animate(executionTime)&#123;...&#125;函数
      &#125;
    &#125;);
  &#125;
</code></pre>
<p>&emsp;&emsp;其中duration，timing，draw分别代码动画执行时间（ms）,时序函数，元素状态更新函数。首先调用performance.now()获取动画开始执行的精确时间，然后再根据当前动画执行的时间根据时序函数计算出当前动画应完成的状态，然后调用draw方法更新元素状态。动画若未完成，继续执行。</p>
<p>&emsp;&emsp;还是用 <a href="/2020/11/26/css/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/#CSS%E5%8A%A8%E7%94%BB">《CSS动画》</a> 中小球移动的示例，这里我们采用一个 y=Math.pow(2, 10 * (x - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * x) 的时序函数来定义动画，时序函数的图像为：</p>
<p><img src="/images/javascript/Js%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0.png" alt="Js自定义时序函数"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
  
    #ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/animate.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    document.getElementById(&quot;ball&quot;).onclick = function () &#123;
      animate(&#123;
        duration: 3000,
        timing: function (time) &#123;
          return Math.pow(2, 10 * (time - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * time)
        &#125;,
        draw: function (progress) &#123;
          document.getElementById(&quot;ball&quot;).style.marginLeft = 250 * progress + &#39;px&#39;;
        &#125;
      &#125;);
    &#125;;
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;动画效果：</p>
<p><img src="/images/javascript/Js%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB.gif" alt="Js时序动画"></p>
<p>&emsp;&emsp;先引入我们animate.js文件，给小球添加onclick点击事件，事件回调函数里为小球创建动画：动画时长3s，时序函数为我们自定义较为复杂的函数（这个时序函数不是CSS里的3次贝塞尔曲线函数，这个动画仅使用CSS无法完成），然后再是小球状态更新的方法，根据动画的完成状态向右移动小球直至移动250px，即到达外层div最右侧时动画完成。</p>
<h4 id="3-JS动画中的缓动函数"><a href="#3-JS动画中的缓动函数" class="headerlink" title="3) JS动画中的缓动函数"></a>3) JS动画中的缓动函数</h4><p>&emsp;&emsp;与时序函数类似，在JS动画中，我们可以也用缓动公式来控制每帧动画中个元素的状态，来实现各种动画效果。<u>缓动函数是根据元素状态的初始值、变化量、当前时间与动画总持续时间按照一定的变化规则来控制元素的状态，比时序函数更加灵活，在实际使用应用中也更加常用。</u>著名的缓动公式算法是Tween.js缓动算法。部分代码如下：</p>
<pre><code>  /*
  * Tween.js
  * t: current time（当前时间）；
  * b: beginning value（初始值）；
  * c: change in value（总变化量）；
  * d: duration（持续时间）。
  */
  var Tween = &#123;
      Linear: function(t, b, c, d) &#123; 
          return c * t / d + b; 
      &#125;,
      Sine: &#123;
          easeIn: function(t, b, c, d) &#123;
              return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
          &#125;,
          easeOut: function(t, b, c, d) &#123;
              return c * Math.sin(t/d * (Math.PI/2)) + b;
          &#125;,
          easeInOut: function(t, b, c, d) &#123;
              return -c / 2 * (Math.cos(Math.PI * t/d) - 1) + b;
          &#125;
      &#125;
    // .....(其他代码省略）
  &#125;
  Math.tween = Tween;
  
  // 测试Tweem.js算法
  // 1、测试匀速运动
  console.log(&#39;1、匀速算法，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);
  console.log(Math.tween.Linear(5,0,100,10)); // 50
  // 2、测试正弦曲线
  console.log(&#39;2、测试正弦曲线，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);
  console.log(Math.tween.Sine.easeIn(5,0,100,10)); // 29.289321881345245
</code></pre>
<p>&emsp;&emsp;算法中的4个参数分别他，t，b，c，d分别表示动画执行到当前帧的时间，元素的初始状态，动画过程中元素状态的变化量以及动画持续时间。如添加的测试1代码所示：有一个小球从0px的位置要移动到100px的位置，初始状态的坐标为0px，坐标的总变化量为100px(100px - 0px = 100px)，假设动画持续时间为10s，传入动画当前帧的时间5s，调用Tween.js的线性渐变算法就能得到当前小球应该处于50px的位置；调用正弦曲线算法能得到当前小球处于约29px的位置。从而以此来控制流畅的动画。</p>
<p>&emsp;&emsp;在Tween.js中，常用的经典动画场景都已实现，除了Linear，其余每种场景都有easeIn、easeOut和easeInOut方法，具体动画场景如下：<br>&emsp;&emsp;Linear：线性匀速运动效果；<br>&emsp;&emsp;Quadratic：二次方的缓动（t^2）；<br>&emsp;&emsp;Cubic：三次方的缓动（t^3）；<br>&emsp;&emsp;Quartic：四次方的缓动（t^4）；<br>&emsp;&emsp;Quintic：五次方的缓动（t^5）；<br>&emsp;&emsp;Sinusoidal：正弦曲线的缓动（sin(t)）；<br>&emsp;&emsp;Exponential：指数曲线的缓动（2^t）；<br>&emsp;&emsp;Circular：圆形曲线的缓动（sqrt(1-t^2)）；<br>&emsp;&emsp;Elastic：指数衰减的正弦曲线缓动；<br>&emsp;&emsp;Back：超过范围的三次方缓动（(s+1)<em>t^3 – s</em>t^2）；<br>&emsp;&emsp;Bounce：指数衰减的反弹缓动。</p>
<p>&emsp;&emsp;还是小球移动的例子，这里简单应用一下Tween.js的方法，代码如下：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
    #ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt; // 引入Tween.js文件
  &lt;script&gt;
    let duration = 3000;
    let startTime = performance.now(); // 动画持续时间
    let currentMarginLeft = 0;
    requestAnimationFrame(function update(executionTime) &#123;
      currentMarginLeft = Math.tween.Linear(executionTime, 0, 250, duration);  // 匀速线性变化
      // currentMarginLeft = Math.tween.Elastic.easeInOut(executionTime, 0, 250, duration); // 衰减的正弦曲线变化
      // currentMarginLeft = Math.tween.Bounce.easeOut(executionTime, 0, 250, duration); // 指数衰减反弹变化
      document.getElementById(&quot;ball&quot;).style.marginLeft = currentMarginLeft + &#39;px&#39;;
      if (executionTime &lt;= duration) &#123;
        requestAnimationFrame(update)
      &#125;
    &#125;);
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;分别采用匀速、衰减正弦曲线以及指数衰减反弹对小球的margin-left属性进行相应变化，动画效果依次为：<br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB1.gif" alt="Tween时序动画1"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB2.gif" alt="Tween时序动画2"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB3.gif" alt="Tween时序动画3"></p>
<h4 id="4-canvas粒子动画"><a href="#4-canvas粒子动画" class="headerlink" title="4) canvas粒子动画"></a>4) canvas粒子动画</h4><p>&emsp;&emsp;canvas元素以及基础的动画，已在另一篇文章<a href="/2020/09/15/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89">《HTML Canvas（2D时序动画）》</a>讲到，canvas画布的上下文ctx对象有对应的API用，可以对相关元素进行旋转、缩放、位移、形变，也可以用martrix方式做更高级的变化。<u>canvas图像处理也可以用于图像压缩，图像裁剪，图像合成、图像滤镜、图像取色器、抠图等功能。</u>不过这里主要补充canvas粒子动画的实现：</p>
<p>&emsp;&emsp;canvas中的粒子，其实是对一个像素的抽象。它具有自己坐标，自己的色值，可以通过改变自身的属性使其按照一定的规律运动起来便可形成相应的粒子动画。<br>&emsp;&emsp;一般我们将粒子用一个对象抽象出来，形如：let particle = { x: 0, y: 0, rgba: ‘(0, 0, 0, 1)’ }，这个过程称为粒子对象化，实际制作粒子动画的过程是对这些粒子对象的属性（如位置，颜色等）进行相应的变化。<br>&emsp;&emsp;为了动画更加自然，我们一般不会采用匀速的变化，而是加入相应的时序函数来控制粒子运动效果，使粒子变化或快或慢，更加自然。<br>&emsp;&emsp;一般为了性能，我们不会把图像所有像素点都抽象出来，因为requestAnimationFrame，正常的情况下一般刷新频率在60HZ，能展现非常流畅的动画。但现在如果要处理庞大的粒子对象数据，浏览器处理压力太大，就会造成了降频现象，导致动画出现卡帧（卡顿）现象。一般我们选择性的来抽象粒子对象：抽象像素点r色值为155以上并且坐标为偶数的像素点；或隔一定距离(像素)用一个粒子来抽象一个像素块（连续多个像素组成）。这样抽象的粒子数量不会影响图像效果的展示，动画的处理过程来也比较流畅。</p>
<p>&emsp;&emsp;<strong>为了更好抽象粒子对象以及其色值信息，补充一个canvas图像滤镜处理的示例来引入<u>canvas像素图像信息</u>的概念：</strong></p>
<p>&emsp;&emsp;先介绍要用到的canvas的3个API：<br>&emsp;&emsp;① <strong>getImageData()</strong>：获得一个ImageData对象</p>
<pre><code>  ctx.getImageData(sx, sy, sw, sh); // 返回ImageData对象
</code></pre>
<p>&emsp;&emsp;ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：width、height、data，分别代表图片宽度(单位px)、高度(单位px)、像素数据（Uint8ClampedArray类型）。</p>
<p>&emsp;&emsp;其中data属性返回像素信息是一个 类型Uint8ClampedArray的一维数组。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份R的色值保存在数组的索引0位置。像素从左到右被处理，然后往下。Uint8ClampedArray  包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1，具体如下：</p>
<p><img src="/images/javascript/ImageData.png" alt="ImageData"></p>
<p>&emsp;&emsp;如图所示，ImgaeData的data属性保存了图片每个像素的RAGA色值信息。第一个像素点的色值RGBA分别保存在Uint8ClampedArray数组索引0到3的位置，第二个像素点的色值保存在数组索引4-7的位置，先行后列，以此类推…。能很容易得到第i行第j列像素点的色值R保存在ImageData.data数组索引 [(j - 1) * width + (i - 1) ] * 4的位置。若像素点色值R在数组的索引为index，则每个像素的位置(i, j)与index的关系为：index=[(j - 1) * width + (i - 1) ] * 4，色值G的索引为index+1，色值B的索引为index+2，透明度A的索引为index+3。 </p>
<p>&emsp;&emsp;② <strong>createImageData()</strong>：Canvas 2D API 创建一个新的、空白的、指定大小的 ImageData 对象。 所有的像素在新对象中都是透明的</p>
<pre><code>  ctx.createImageData(width, height); // 返回ImageData对象
  ctx.createImageData(imagedata); // 返回ImageData对象
</code></pre>
<p>&emsp;&emsp;③ <strong>putImageData()</strong>：Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法</p>
<pre><code>  ctx.putImageData(imagedata, dx, dy);
  ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
</code></pre>
<p>&emsp;&emsp;canvas图像滤镜处理效果：</p>
<p><img src="/images/javascript/canvas%E5%9B%BE%E5%83%8F%E6%BB%A4%E9%95%9C%E5%A4%84%E7%90%86.png" alt="canvas图像滤镜处理"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
  &lt;script&gt;
    const TYPE = &#39;grayscale&#39;; // grayscale - 灰度(默认)、sepia - 复古、inert - 反向
    let canvas = document.getElementById(&#39;canvas&#39;);
    let ctx = canvas.getContext(&#39;2d&#39;);
    const img = document.createElement(&#39;img&#39;);
    img.src = &#39;/img/filter.jpg&#39;;
    img.addEventListener(&#39;load&#39;, () =&gt; &#123;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0); // 将原图渲染到canvas画布上
      let originImage = ctx.getImageData(0, 0, canvas.width, canvas.height); // 获取图片像素信息
      let outputImage = filter(originImage, TYPE); // 按照滤镜风格处理像素信息
      ctx.putImageData(outputImage, 0, 0); // 将处理后的像素信息覆盖到canvas画布上
    &#125;)
    function filter(originImage, type) &#123; // 图像处理函数
      let index, r, g, b;
      let originImageData = originImage.data;
      let width = originImage.width;
      let height = originImage.height;
      let outputImage = ctx.createImageData(width, height);
      let outputImageData = outputImage.data;
      for (let x = 1; x &lt;= width; x++) &#123;
        for (let y = 1; y &lt;= height; y++) &#123;
          index = [(y - 1) * width + (x - 1)] * 4;
          r = originImageData[index];
          g = originImageData[index + 1];
          b = originImageData[index + 2];
          if (type == &#39;sepia&#39;) &#123; // 复古滤镜风格下对色值的处理
            outputImageData[index] = (r * 0.393) + (g * 0.769) + (b * 0.189);
            outputImageData[index + 1] = (r * 0.349) + (g * 0.686) + (b * 0.168);
            outputImageData[index + 2] = (r * 0.272) + (g * 0.534) + (b * 0.131);
          &#125; else if (type == &#39;inert&#39;) &#123; // 反向滤镜风格下对色值的处理
            outputImageData[index] = 255 - r;
            outputImageData[index + 1] = 255 - g;
            outputImageData[index + 2] = 255 - b;
          &#125; else &#123; // 灰度滤镜风格下对图像的处理
            outputImageData[index] = outputImageData[index + 1] = outputImageData[index + 2] = (r + g + b) / 3;
          &#125;
          outputImageData[index + 3] = 255;
        &#125;
      &#125;
      return outputImage;
    &#125;
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：思路就是先讲图片渲染到canvas画布上，再调用getImageData()方法获得canvas元素上的像素信息。根据滤镜风格分别对像素信息进行相应的处理，最后调用putImageData()方法将imageData对象渲染(覆盖)到canvas画布上即可。示例中我们已经获取到了画布上图像的像素信息，也以利用获取到的图片像素信息，监听鼠标指针相对于画布的水平垂直方向偏移的距离（px）获得当前鼠标指针指向的像素点(i, j)的位置，可以做<u>图像取色器</u>等功能。</p>
<p>&emsp;&emsp;正式介绍<u>粒子动画</u>，先看效果：</p>
<p><img src="/images/javascript/Js%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB.gif" alt="Js粒子动画"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;canvas粒子动画&lt;/title&gt;
    &lt;style&gt;
      body &#123; background: midnightblue; margin: 0; padding: 0; &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;!-- 使用Tween.js缓动函数控制动画 --&gt;
    &lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let cw = document.documentElement.clientWidth;
      let ch = document.documentElement.clientHeight;
      let maxDelay = 0; // 保存粒子动画开始最长延时时间，用于动画完成介绍requestAnimationFrame动画回调
      let canvas = document.getElementById(&#39;canvas&#39;);
      let ctx = canvas.getContext(&#39;2d&#39;);
      const img = document.createElement(&#39;img&#39;);
      img.src = &#39;/img/canvas-img.jpg&#39;;
      img.addEventListener(&#39;load&#39;, () =&gt; &#123;
        canvas.width = cw;
        canvas.height = ch;
        console.log(cw, ch)
        let sx = (cw / 2) - (img.width / 2); // 把图片画在canvas(屏幕)中间
        ctx.drawImage(img, sx, 0, img.width, img.height);
        let originImage = ctx.getImageData(0, 0, cw, ch);
        let particles = dataToObject(originImage.data, originImage.width, originImage.height);
        draw(particles);
      &#125;)
  
      function dataToObject(imageData, width, height) &#123; // 粒子对象化函数
        let inx;
        let particle = &#123;&#125;;
        let particles = [];
        let threshold = 50; // 设置色值阈值，颜色较浅的像素不进行粒子对象化操作
        let delay = 0;
        for (let x = 1; x &lt;= width; x += 2) &#123;
          for (let y = 1; y &lt;= height; y += 2) &#123;
            inx = [(y - 1) * width + (x - 1)] * 4;
            if ((imageData[inx] + imageData[inx + 1] + imageData[inx + 2]) / 3 &gt; threshold) &#123;
              delay = Math.random() * 3000;
              maxDelay &lt; delay &amp;&amp; (maxDelay = delay)
              particle = &#123;
                x0: 100,
                y0: ch,
                x1: x - 1,
                y1: y - 1,
                delay: delay,
                rgba: `rgba($&#123;imageData[inx]&#125;, $&#123;imageData[inx + 1]&#125;, $&#123;imageData[inx + 2]&#125;, $&#123;imageData[inx + 3]&#125;)`
              &#125;;
              particles.push(particle);
            &#125;
          &#125;
        &#125;
        return particles;
      &#125;
      
      function draw(particles) &#123; //画图
        let duration = 5000; // 动画持续时间
        let particle, cur_x, cur_y, cur_time;
        let startTime = performance.now(); // 动画开始时间
        let AnimationFrameId = requestAnimationFrame(function update(executionTime) &#123; // 每帧更新画布
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0, len = particles.length; i &lt; len; i++) &#123;
            particle = particles[i]
            if (executionTime &gt; particle.delay + duration) &#123;
              ctx.fillStyle = particle.rgba;
              ctx.fillRect(particle.x1, particle.y1, 1, 1)
            &#125; else if (executionTime &gt; particle.delay) &#123;
              ctx.fillStyle = particle.rgba;
              cur_time = executionTime - particle.delay;
              cur_x = Math.tween.Elastic.easeInOut(cur_time, particle.x0, particle.x1 - particle.x0, duration);
              cur_y = Math.tween.Bounce.easeOut(cur_time, particle.y0, particle.y1 - particle.y0, duration);
              ctx.fillRect(cur_x, cur_y, 1, 1)
            &#125;
          &#125;
          if (executionTime &gt; maxDelay + duration) &#123;
            cancelAnimationFrame(AnimationFrameId);
          &#125;else&#123;
            AnimationFrameId = requestAnimationFrame(update)
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
<p>&emsp;&emsp;实现思路：使用drawImage()方法将图片对象先放在画布上，然后调用getImageData()获取图片的像素信息。<u>根据将像素信息，生成对象来表示每个像素点的信息，对象属性包括初始位置，结束位置（像素点在canvas画布中原本的位置），颜色等信息。</u>这里为了然动画效果更加自然协调，加入了动画开始延迟时间delay属性。然后根据Tween.js缓动函数对粒子从初始位置移动到对应的结束位置的状态进行控制，调用requestAnimationFrame()方法设置回调来对粒子对象的状态进行刷新，便形成了动画。<br><em>&emsp;&emsp;[注] 有时我们会加入阈值（如代码中设置的阈值threshold为50）、增加对象化像素点的间距（如代码中循环粒子对象化操作时循环步长为2）来减少生成的对象数量，从而减少浏览器每一帧的处理压力，使动画更加流畅自然。</em></p>
<p>&emsp;&emsp;代码中的dataToObject()函数完成的功能就是用对象去标识图像的像素信息，每个对象表示一个像素点，即我们所说的‘粒子’。<u>实际上，粒子动画并不是总要使用getImageData()去抽象图片的信息，然后生成粒子对象。有时我们会直接构造出粒子类，按照我们的需求生成粒子对象，然后根据一定的规则使粒子运动起来即可。粒子动画本质是canvas动画，还可以与鼠标等输入设备交互，作出像放烟花、炫彩小球、小球自由落体、球体运动碰撞等有趣的动画。</u></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/01/02/javascript/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WEB%E6%8A%80%E6%9C%AF/" rel="tag">WEB技术</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/01/16/javascript/JS%E5%B8%B8%E7%94%A8API%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%97%A5%E6%9C%9F%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            JS常用API（字符串、数组、对象、正则、日期）
          
        </div>
      </a>
    
    
      <a href="/2020/12/25/javascript/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JS异步操作以及流程控制（串行、并行）</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Xiong Gang
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="码农日志"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我吃个雪糕吧，谢谢~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay-payment-code.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat-payment-code.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>