<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>JS异步操作以及流程控制（串行、并行） |  码农日志</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="码农日志" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JS异步操作以及流程控制（串行、并行）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JS异步操作以及流程控制（串行、并行）
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/25/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/" class="article-date">
  <time datetime="2020-12-25T07:59:04.000Z" itemprop="datePublished">2020-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">38 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>Javascript语言的执行环境是”单线程”（single thread），单个脚本只能在一个线程上运行（主线程）。原因在于浏览器内核中JavaScript引擎中负责解释和执行JavaScript代码的主线程是唯一的，同一时间只能执行一件任务。在浏览器内核中，GUI 渲染线程与 JavaScript 引擎线程是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。所以如果JavaScript执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步。”同步模式”指一个任务等待前一个任务执行结束再执行，程序的执行顺序与任务的排列顺序（即与程序的编码顺序）是一致的、同步的；”异步模式”是每一个任务有一个或多个回调函数，一个任务不用等待前一个任务执行完成就便开始执行，当前任务执行完成后，不是立即执行后一个任务，而是查询回调函数队列里，是否有前面的已任务的回调函数，会立即执行回调函数，回调函数执行完后再执行后一个任务。程序的执行顺序与任务的排列顺序是不一致的，同步的；而是异步的。（<u>此外，JS运行时还有宏任务、微任务、事件循环的概念。</u>）</p>
<h2 id="说在前面-进程（Process）与线程（Thread）"><a href="#说在前面-进程（Process）与线程（Thread）" class="headerlink" title="说在前面 - 进程（Process）与线程（Thread）"></a>说在前面 - 进程（Process）与线程（Thread）</h2><p>&emsp;&emsp;目前的操作系统都是多任务系统，操作系统接管了所有硬件资源并持有对硬件控制的最高权限。在操作系统中执行的程序，都以进程的方式运行在更低的权限中。所有的硬件资源，由操作系统根据进程的优先级以及进程的运行状况进行统一的调配，<u>即操作系统是以进程为单位去分配空间和执行的。</u></p>
<p><em>&emsp;&emsp;[注] 区分程序与进程：程序是一组指令集合，它本身没有任何运行的含义，它只是一个静态的实体，存储于磁盘之内的存储器中；当一个程序被操作系统执行时，会被载入内存并在逻辑上产生一个独立的实例，这就是进程。进程和程序并不是一 一对应的；一个程序有可能没有与之对应的进程(因为它并未执行)，也有可能有多个进程与之对应(程序运行在几个不同的数据集上)。<u>一个程序在运行时，至少有一个进程,一个进程至少有一个线程。</u></em></p>
<p>&emsp;&emsp;线程是操作系统进行任务调度的最小单元。<strong>线程存活于进程之中；同一个进程中的线程，共享一个虚拟内存空间以及其中的资源；</strong>线程之间各自持有自己的线程 ID、当前指令的指针（PC）、寄存器集合以及栈。</p>
<p>&emsp;&emsp;<strong>就浏览器来说，浏览器在运行时是多进程的：</strong><br>&emsp;&emsp;Browser进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等<br>&emsp;&emsp;PU 进程：用于3D 绘制等<br>&emsp;&emsp;第三方插件进程：每种类型的插件对应一个进程，仅当使用该浏览器插件时才创建<br>&emsp;&emsp;浏览器渲染进程（浏览器内核）：每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</p>
<p>&emsp;&emsp;<strong>每个渲染进程（浏览器内核）又分为多个线程：</strong><br>&emsp;&emsp;GUI渲染线程：负责渲染浏览器界面，当界面需要重绘或由于某种操作引发回流时，该线程就会执行<br>&emsp;&emsp;JavaScript引擎线程：也称为JavaScript内核，负责处理Javascript脚本程序、解析与运行Javascript代码等，例如 V8 引擎<br>&emsp;&emsp;事件触发线程：用来控制浏览器的事件循环，当事件被触发时，该线程才会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理<br>&emsp;&emsp;定时触发器线程：setInterval与setTimeout所在线程（<u>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</u>）<br>&emsp;&emsp;异步http请求线程：在XMLHttpRequest连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行</p>
<p><em>&emsp;&emsp;[注] <u>GUI 渲染线程与 JavaScript 引擎线程是互斥的。</u></em></p>
<h2 id="1、JS异步操作的几种方式"><a href="#1、JS异步操作的几种方式" class="headerlink" title="1、JS异步操作的几种方式"></a>1、JS异步操作的几种方式</h2><p>&emsp;&emsp;JavaScript中的任务分为同步任务和异步任务。<br>&emsp;&emsp;同步任务是那些没有被引擎挂起、<u>在主线程上排队执行的任务。</u>只有前一个任务执行完毕，才能执行后一个任务。<br>&emsp;&emsp;异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列（根据异步任务的类型，引擎实际上存在多个任务队列）的任务。只有引擎认为某个异步任务可以被执行了，该任务才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运。即异步任务不具有堵塞效应。</p>
<p>&emsp;&emsp;主线程会排队去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行。等到执行完，下一个异步任务再进入主线程开始执行。一旦同步与异步任务队列清空，程序就结束执行。</p>
<p>&emsp;&emsp;同步任务执行完成，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<u>事件循环（Event Loop）</u>。</p>
<p>&emsp;&emsp;异步操作的几种模式：回调函数、事件监听、发布/订阅模式、Generator 函数、Promise、async/await。</p>
<hr>
<p>&emsp;&emsp;<strong>由于在分析异步操时需要用到定时器来模拟异步操作，这里先补充定时器相关概念：</strong></p>
<p>&emsp;&emsp;JavaScript 提供定时执行代码的功能，叫做定时器，主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。<u>定时器的运行机制是，将指定的代码移出本轮事件循环（即使设置延迟执行为0ms)，等到下一轮事件循环，再检查是否到了指定时间。如果到了，再将对应代码放入主线程进行执行；如果没到，就继续等待。</u></p>
<p>&emsp;&emsp;<u>setTimeout()</u>：用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，可以将该编号作为参数调用clearTimeout()方法来取消这个定时器。setTimeout()可以接收多个参数，第一个参数为回调函数或字符串代码，会在定时时间到达时执行，第二个参数为延迟执行的时间（单位ms），后面的参数列表会作为第一个参数回调函数的参数传入。<u>特别的，回调函数是如果是某一对象的方法，内部this指向是是全局环境的而不是定义所在的那个对象。</u></p>
<pre><code>  let id = setTimeout(function | code, delay, [a, b, c...]);
</code></pre>
<p>&emsp;&emsp;示例代码：</p>
<pre><code>  console.log(&#39;定时任务开始执行，&#39; + new Date())
  let id =  setTimeout((a,b,c) =&gt; &#123;
    console.log(&#39;定时任务执行完成，&#39;+ new Date() +&#39;，回调函数已开始执行&#39;);
    console.log(&#39;回调函数计算结果为：&#39;+ (a+b+c));
  &#125;,1000, 1,2,3)

  输出：
  定时任务开始执行，Wed May 26 2021 16:40:09 GMT+0800 (中国标准时间)
  定时任务执行完成，Wed May 26 2021 16:40:10 GMT+0800 (中国标准时间)，回调函数已开始执行
  回调函数计算结果为：6
</code></pre>
<p>&emsp;&emsp;<u>setInterval()</u>：setInterval()函数的用法与setTimeout()完全一致，区别仅仅在于setInterval()指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。特别的，指定的是<u>“开始执行”</u>之间的间隔，并不考虑每次任务执行本身所消耗的时间。实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 1000ms 执行一次，每次执行需要 500ms，那么第一次执行结束后等待500毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要1500毫秒，那么它结束后，下一次任务执行才会立即开始。</p>
<pre><code>  let count = 0; // 计时器，控制任务执行5次    
  console.log(new Date() + &#39;，延迟2s后开始执行定时任务~&#39;);
  let id = setInterval(() =&gt; &#123;
    let delay = Math.floor(Math.random() * 5 + 1) * 1000;
    console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务开始执行，需要&#39; + delay + &#39;ms才能完成&#39;)
    sleep(delay);
    console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务执行完成&#39;)
    count++;
    if (count == 5) &#123;
      clearInterval(id)
      console.log(&#39;任务已执行5次，结束定时器任务~&#39;);
    &#125;
  &#125;, 2000)
  function sleep(ms) &#123; // 通过循环阻塞代码执行来模拟同步操作
    var start = Date.now();
    while ((Date.now() - start) &lt; ms) &#123; &#125;
  &#125;
  
  输出：
  Thu Nov 26 2020 13:13:39 GMT+0800 (中国标准时间)，延迟2s后开始执行定时任务~
  Thu Nov 26 2020 13:13:41 GMT+0800 (中国标准时间)，第1次任务开始执行，需要1000ms才能完成
  Thu Nov 26 2020 13:13:42 GMT+0800 (中国标准时间)，第1次任务执行完成
  Thu Nov 26 2020 13:13:43 GMT+0800 (中国标准时间)，第2次任务开始执行，需要4000ms才能完成
  Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第2次任务执行完成
  Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第3次任务开始执行，需要3000ms才能完成
  Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第3次任务执行完成
  Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第4次任务开始执行，需要3000ms才能完成
  Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第4次任务执行完成
  Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第5次任务开始执行，需要4000ms才能完成
  Thu Nov 26 2020 13:13:57 GMT+0800 (中国标准时间)，第5次任务执行完成
  任务已执行5次，结束定时器任务~
</code></pre>
<p>&emsp;&emsp;可以看到，第一次任务开始在13:13:41，需要执行1s，在13:13:42第一次任务就执行完成。由于设置的执行时间间隔是2s，等待1s后13:13:43才开始执行第二次任务。第二次任务需要执行4s，在13:13:47秒时第二次任务才执行完成；虽然设置的时间间隔为2s，但第二次任务执行时间大于设置的2s，第三次任务在第二次任务执行完后才开始执行。后面的任务执行情况同理。</p>
<p>&emsp;&emsp;注意，setTimeout()定时任务也会被阻塞：</p>
<pre><code>  console.log(new Date() + &#39;，延迟1s后开始执行定时任务~&#39;);
  setTimeout(() =&gt; &#123;
    console.log(new Date() + &#39;，延迟任务执行完成~&#39;)
  &#125;, 1000)
  sleep(2000);
  function sleep(ms) &#123; // 通过循环阻塞代码执行来模拟同步操作
    var start = Date.now();
    console.log(&#39;当前sleep任务要执行&#39; + ms + &#39;ms&#39;)
    while ((Date.now() - start) &lt; ms) &#123; &#125;
  &#125;
  
  输出：
  Thu Nov 26 2020 13:34:00 GMT+0800 (中国标准时间)，延迟1s后开始执行定时任务~
  当前sleep任务要执行2000ms
  Thu Nov 26 2020 13:34:02 GMT+0800 (中国标准时间)，延迟任务执行完成~
</code></pre>
<p>&emsp;&emsp;可以看到在13:34:00时，setTimeout()的回调函数本应该延迟1s执行，但sleep操作要执行2s。导致setTimeout()回调函数在13:34:02时才被执行。</p>
<p>&emsp;&emsp;<strong>setTimeout()与setInterval()可能会被同步任务阻塞，和定时器的运行机制有关。setTimeout和setInterval指定的回调函数，<u>必须等到本轮事件循环的所有同步任务都执行完成（上面代码中sleep()函数循环来模拟同步任务），才会被添加到主线程开始执行，而且此时的回调函数执行是同步的，只有回调函数执行完成，才会进行下一轮事件循环。</u>由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。<u>即使使用嵌套的setTimeout()来实现每两次任务执行之间有固定的间隔，也是有被阻塞的风险。</u></strong></p>
<hr>
<h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1) 回调函数"></a>1) 回调函数</h4><p>&emsp;&emsp;回调函数实现异步操作是指在开始执行的异步函数指定为参数的函数（回调函数不会立即被执行），当异步函数包含的异步操作执行完成时，再调用执行该回调函数。<u>回调函数是异步编程的最基本的方法。</u></p>
<p>&emsp;&emsp;将处理函数当做参数，在相关任务执行完成再调用执行，形如：</p>
<pre><code>  function f1&#123;
    // 相关代码
  &#125;
  function f2(cb)&#123;
    setTimeout(() =&gt; &#123;
      cb()
    &#125;, 2000)
  &#125;

  f2(f1);
</code></pre>
<p>&emsp;&emsp;下面模拟一个读取文件列表（3个文件）获取对应文件的总行数的示例，这里采用回调函数的方式进行依次读取（还有其他或更好的方式实现，这里只是为了用来说明回调函数）。</p>
<pre><code>  let fileLines = [];    
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      fileLines.push(lines)
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb();
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(&#39;代码执行完成，文件行数依次为：&#39;);
    console.log(fileLines)
  &#125;

  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  // 假设文件列表有3个文件，这里调用3次文件读取函数asyncFn()
  asyncFn(1, function () &#123;
    asyncFn(2, function () &#123;
      asyncFn(3, consoleResult)
    &#125;)
  &#125;)
  
  Mon Nov 30 2020 16:23:40 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 16:23:41 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 95
  Mon Nov 30 2020 16:23:42 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 88
  Mon Nov 30 2020 16:23:43 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 51
  代码执行完成，文件行数依次为：
  95,88,51
</code></pre>
<p>&emsp;&emsp;这里asyncFn()负责读取文件获取文件行数，里面使用了计时器来模拟异步操作，用随机数模拟获取的文件行数。假设文件列表只有3个文件，这里asyncFn()调用了3次，每次分别传入了一个函数，这个函数就是我们说的回调函数，在成功读取文件获得行数后立即被执行。第1个读取文件时，将读取第2个文件的任务放在了回调函数里，在第1个文件读取完成后，执行回调函数，开始了第2个文件的读取；同理，把读取第3个文件的任务放在了读取第2个文件的回调函数里，在第2个文件读取完成后，执行回调函数，第3个文件的读取开始执行。特别的，读取第3个文件的回调函数里放入了我们输出结果的函数consoleResult()，所以当第3个文件读取完成时，回调函数立即被执行，回调函数输出了依次读取到的文件行数信息。</p>
<p>&emsp;&emsp;<u>回调函数的比较好理解，就是在异步任务完成后，再继续执行后续的任务，比较容易理解与实现。但回调函数的代码是高度耦合的，执行取决于代码的结构（代码顺序），特别是多个异步任务作为回调函数嵌套执行的时候（例如上面的代码，这种现象也成‘回调地狱’），相关代码比较分散，不利于阅读和维护。</u></p>
<h4 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2) 事件监听"></a>2) 事件监听</h4><p>&emsp;&emsp;采用事件驱动的形式，任务被执行不取决于代码结构，取决于相关联的事件是否发生。</p>
<p>&emsp;&emsp;形如：</p>
<pre><code>  eventSource.on(&#39;done&#39;,fn); // eventSource对象监听done事件，并添加fn后续处理函数
  eventSource.tigger(&#39;done&#39;); // eventSource触发done事件
</code></pre>
<p>&emsp;&emsp;还是上面的示例，这里采用jQuery的自定义事件。输出结果也完全一致：</p>
<pre><code>  let times = 0;
  let fileLines = [];
  $(document).on(&#39;done&#39;, doneFn) // 给document绑定done事件，若document的done事件发生，执行doneFn()处理函数
  function doneFn(event, lines)&#123;
    console.log(new Date() + &#39; 第&#39; + times + &#39;次读取文件完成，文件总行数为 &#39; + lines);
    fileLines.push(lines)
  &#125;
  function asyncFn() &#123;
    let id = setInterval(() =&gt; &#123;
      times++;
      if (times &lt;= 3) &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
        $(document).trigger(&#39;done&#39;, lines) // 触发document done事件发生，驱动doneFn()处理函数执行
      &#125; else &#123;
        clearInterval(id)
        console.log(&#39;代码执行完成，文件行数依次为：&#39;);
        console.log(fileLines)
      &#125;
    &#125;, 1000)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  asyncFn()

  Wed May 26 2021 17:01:10 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Wed May 26 2021 17:01:11 GMT+0800 (中国标准时间) 第1次读取文件完成，文件总行数为 61
  Wed May 26 2021 17:01:12 GMT+0800 (中国标准时间) 第2次读取文件完成，文件总行数为 91
  Wed May 26 2021 17:01:13 GMT+0800 (中国标准时间) 第3次读取文件完成，文件总行数为 73
  代码执行完成，文件行数依次为：61 91 73
</code></pre>
<p>&emsp;&emsp;这里使用setInterval()来模拟3次读取文件任务，在第3次文件读取完成后清空计时器并输出结果。可以看到，在每次文件读取完成后，使用$(document).trigger(‘done’, lines)触发‘done’事件，通过事件监听器$(document).on(‘done’, doneFn)关联的doneFn()处理函数被执行。<u>其中，这里的document称为为事件源，‘done’称为为事件，‘on’称为事件监听器，doneFn()函数称为处理方法。</u></p>
<p>&emsp;&emsp;<u>事件驱动比较容易理解，就是在任务完成后继续触发后续任务的执行。可以绑定多个事件，每个事件可以指定多个回调函数，与回调函数相比，大大降低了代码的耦合度（但代码还是耦合的，绑定在同一个事件源上），有利于实现模块化。但事情驱动代码也较为分散，不利于阅读与维护。</u></p>
<h4 id="3-发布-订阅模式"><a href="#3-发布-订阅模式" class="headerlink" title="3) 发布/订阅模式"></a>3) 发布/订阅模式</h4><p>&emsp;&emsp;如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”一个信号，其他任务可以向信号中心“订阅”这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。</p>
<p>&emsp;&emsp;发布/订阅模式的性质与“事件监听”类似，但功能上优于事件监听的方式。因为可以通过查看“信号中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h4 id="4-Generator-函数（ES6新增）"><a href="#4-Generator-函数（ES6新增）" class="headerlink" title="4) Generator 函数（ES6新增）"></a>4) Generator 函数（<u>ES6新增</u>）</h4><p>&emsp;&emsp;Generator 函数是一直特殊的函数，最大特点就是可以交出函数的执行权（即暂停执行）。可以把理解成，Generator 函数是一个状态机，封装了多个内部状态。Generator 函数内部使用yield表达式定义内部状态，为了与普通函数区别，一般在function关键字与函数名直接添加‘*’来标识（非必须，在函数内部使用yield的关键字这个函数就是 Generator 函数）。<u>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的迭代对象。必须调用next方法依次对状态进行迭代（恢复代码执行），内部指针就从函数头部或上一次停下来的地方开始执行（暂停执行的地方），直到遇到下一个yield关键字定义的状态时又会停止执行。每次调用next()会返回本次迭代的结果对象，其中的value属性表示当前的内部状态（结果），done属性标识整个迭代对象的迭代是否完成。</u></p>
<p>&emsp;&emsp;举个简单例子：</p>
<pre><code>  function* gen() &#123;
    console.log(new Date() + &#39; status 1&#39;);
    yield &#39;status 1&#39;;
    console.log(new Date() + &#39; status 2&#39;);
    yield &#39;status 2&#39;;
    console.log(new Date() + &#39; status 3&#39;);
    yield &#39;status 3&#39;;
    console.log(new Date() + &#39; status 4&#39;);
    yield &#39;status 4&#39;;
    console.log(new Date() + &#39; status 5&#39;);
  &#125;
  let g = gen();
  let id = setInterval(() =&gt; &#123; // 用计时器进行迭代来模拟异步操作
    if(g.next().done)&#123;
      clearInterval(id);
      console.log(&#39;状态迭代完成~&#39;);
    &#125;
  &#125;, 1000)

  输出
  Mon Nov 30 2020 21:24:24 GMT+0800 (中国标准时间) status 1
  Mon Nov 30 2020 21:24:25 GMT+0800 (中国标准时间) status 2
  Mon Nov 30 2020 21:24:26 GMT+0800 (中国标准时间) status 3
  Mon Nov 30 2020 21:24:27 GMT+0800 (中国标准时间) status 4
  Mon Nov 30 2020 21:24:28 GMT+0800 (中国标准时间) status 5
  状态迭代完成~
</code></pre>
<p>&emsp;&emsp;用Generator函数来模拟上面异步读取文件行数示例的代码：（_[注] 这种实现方式并不是最优的，结合Promise来确定每次异步操作已执行完成再进行下一次迭代操作比这里简单使用计时器模拟更为合理；使用Thunk函数或者co函数库来实现状态自动迭代的流程管理更加优雅_）：</p>
<pre><code>  let fileLines = [];
  function readFile(inx) &#123;
    let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
    fileLines.push(lines)
    console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
  &#125;
  function* asyncFn() &#123;
    yield readFile(1);
    yield readFile(2);
    readFile(3);
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  let g = asyncFn();
  let id = setInterval(() =&gt; &#123; // 模拟异步
    if(g.next().done)&#123;
      clearInterval(id)
      console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
      console.log(fileLines)
    &#125;
  &#125;, 1000)

  Wed May 26 2021 17:04:39 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:04:40 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 69
  Wed May 26 2021 17:04:41 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 57
  Wed May 26 2021 17:04:42 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 86
  Wed May 26 2021 17:04:42 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：69 57 86
</code></pre>
<p>&emsp;&emsp;<u>Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即各个状态间的管理不方便）。不过使用thunk函数或者co函数库能够解决这个问题。</u></p>
<h4 id="5-Promise（ES6新增）"><a href="#5-Promise（ES6新增）" class="headerlink" title="5) Promise（ES6新增）"></a>5) Promise（<u>ES6新增</u>）</h4><p>&emsp;&emsp;promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。一个 promise 必然处于以下几种状态之一：pending（初始状态）、fulfilled（操作成功完成）、rejected（操作失败）。</p>
<p>&emsp;&emsp;<u>处理待定状态（pending）的 Promise 对象要么会通过一个值被成功执行（fulfilled），要么会通过一个原因或错误被拒绝（rejected）。当这些情况之一发生时，promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用。Promise.prototype.then 和  Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。</u></p>
<p>&emsp;&emsp;一般我们使用Promise()构造函数来创建一个 promise 对象，以此对还没有添加 promise 支持的函数进行相应的封装使用。<u>在适当的时候，调用resolve()方法将新的promise 对象的pending状态改变为fulfilled状态，或者调用reject()将pending状态改变为rejected状态。</u>若不使用这两个静态方法，新的 promise 对象的状态仍为pending初始化状态。</p>
<p>&emsp;&emsp;<strong>Promise有一些静态方法：</strong></p>
<p>&emsp;&emsp;all()：所有promise对象都完成且都成功（fulfilled）时触发（执行then()分支），会把所有promise返回值的数组作为成功回调的返回值，顺序跟promise的顺序保持一致，任意一个promise失败（rejected）则立即触发该失败（执行catch分支），第一个触发失败的promise对象的错误信息将作为它的失败错误信息，<u>此时，其他的pending状态的promise还是会执行直至完成（promise开始执行后不能被取消）。Promise.all方法常被用于处理多个promise对象的状态集合。</u></p>
<p>&emsp;&emsp;allSettled() ：所有promise对象都完成(fulfilled/rejected)时触发（执行then()分支），返回一个promise结果对象的数组，顺序与promise的顺序保持一致。每个promise结果对象包含status属性（状态），value属性（fulfilled状态时返回值）以及reason属性（rejected状态时返回的失败原因）等属性。</p>
<p>&emsp;&emsp;any()：promise对象的集合中当其中的一个 promise 成功（fulfilled）触发，就返回那个成功的promise的值（执行then分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;race()：promise对象的集合中当其中的一个 promise 成功（fulfilled）或失败（rejected）时触发，成功就返回那个成功的promise的值（执行then分支），失败就返回那个失败promise失败的原因（执行catch分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;reject()：返回一个失败状态的Promise对象，并将给定的失败信息传递给对应的处理方法。</p>
<p>&emsp;&emsp;resolve()：返回一个成功状态的Promise对象，其中value为返回结果。</p>
<p>&emsp;&emsp;Promise异步读取文件行数示例的代码如下：</p>
<pre><code>  let filelines =[];
  function readFile(inx) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  readFile(1).then(res =&gt; &#123;
    filelines.push(res);
    return readFile(2);
  &#125;).then(res =&gt; &#123;
    filelines.push(res);
    return readFile(3);
  &#125;).then(res =&gt; &#123;
    filelines.push(res);
    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
    console.log(filelines);
  &#125;)

  Wed May 26 2021 17:10:52 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:10:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 82
  Wed May 26 2021 17:10:54 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 90
  Wed May 26 2021 17:10:55 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 64
  Wed May 26 2021 17:10:55 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：82 90 64
</code></pre>
<p>&emsp;&emsp;<u><strong>Promise处理异步（特别是处理一次性结果）十分方便，也支持链式的进行调用，是目前较好的异步编程方式。</strong>特别是结合Array对象相关的方法如map()、filter()等。不过Promise也有一定的缺点，一但创建便会执行，不能取消，也无法得知目前进展到哪一个阶段；如果不设置回调函数，Promise内部抛出的错误，不会反应到外部等问题。</u></p>
<p>&emsp;&emsp;例如上面的Promise处理代码可以结合Array.map()方法生成promise对象集合（数组），由Promise.all()去并行执行（流程控制相关概念见后文）：</p>
<pre><code>  function readFile(inx)&#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  Promise.all([1, 2, 3].map((item) =&gt; readFile(item))).then(list =&gt; &#123;
    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
    console.log(list)
  &#125;)

  Wed May 26 2021 17:11:46 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 97
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 69
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 75
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：97 69 75
</code></pre>
<p>&emsp;&emsp;这两段代码相比，可以看到后面这段代码明显更加的简洁。更重要的是，前一种写法读取3个文件的任务需要3s时间才能完成，后一种并行执行写法只需要1s时间便可完成。</p>
<h4 id="5-async-await（ES7新增）"><a href="#5-async-await（ES7新增）" class="headerlink" title="5) async/await（ES7新增）"></a>5) async/await（<u>ES7新增</u>）</h4><p>&emsp;&emsp;async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。<br>&emsp;&emsp;async 函数是 Generator 函数的语法糖且async 函数自带执行器。async函数可能包含0个或者多个await表达式。<br>&emsp;&emsp;async函数一定会返回一个promise对象。如果一个async函数的返回值不是promise，那么它将会被隐式地包装在一个promise中。</p>
<p>&emsp;&emsp;await表达式会暂停整个async函数的执行进程并出让其控制权：<br>&emsp;&emsp;(1) 如果await后面是普通表达式， await 表达式的运算结果就是它等待的的结果。<br>&emsp;&emsp;(2) 如果await后面是promise对象，只有当其等待的promise的异步操作成功或失败之后才会恢复进程，promise的结果会被当作该await表达式的返回值，此时await会阻塞后面的代码执行。<u>所以把await放在async函数内部，因为async 函数的调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</u><br>&emsp;&emsp;(3) <u>await 命令后面的 promise 运行结果如果是 rejected，此时async/await无法处理，一般要把 await 命令放在 try…catch 代码块中。</u></p>
<p>&emsp;&emsp;async/await读取文件行数示例代码：</p>
<pre><code>  function readFile(inx) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  async function getLines()&#123;
    let line1 = await readFile(1); // 读取文件1
    let line2 = await readFile(2); // 读取文件2
    let line3 = await readFile(3); // 读取文件3
    console.log(new Date() + &#39; 代码执行完成，结果为：&#39; + [line1, line2, line3])
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  getLines();

  Wed May 26 2021 17:18:13 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:18:14 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 72
  Wed May 26 2021 17:18:15 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 82
  Wed May 26 2021 17:18:16 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 55
  Wed May 26 2021 17:18:16 GMT+0800 (中国标准时间) 代码执行完成，结果为：72,82,55
</code></pre>
<p>&emsp;&emsp;async/await的优点：<br>&emsp;&emsp;它做到了真正的串行的同步写法，代码阅读相对容易。<br>&emsp;&emsp;对于条件语句和其他流程语句比较友好，可以将await直接写到判断条件里。<br>&emsp;&emsp;处理复杂流程时，在代码更加清晰简洁。</p>
<p>&emsp;&emsp;async/await的缺点：<br>&emsp;&emsp;<u>无法处理promise返回的reject对象，要借助try…catch…捕获异常等。</u><br>&emsp;&emsp;<strong>await只能串行，做不到并行（因为await一定是阻塞的）等。</strong></p>
<h2 id="2、异步操作流程控制"><a href="#2、异步操作流程控制" class="headerlink" title="2、异步操作流程控制"></a>2、异步操作流程控制</h2><p>&emsp;&emsp;如果有多个异步操作，为了代码的执行效率与可维护性，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。<br>&emsp;&emsp;流程控制一般有串行执行、并行执行等方式。<br>&emsp;&emsp;串行执行：一个异步任务执行完成后在执行下一个任务。（上面异步读取文件行数的示例中，除了Promise处理中的第2种写法，其他全是串行执行的）<br>&emsp;&emsp;并行执行：所有异步任务同时执行（并行非并发）。（例如上面Promise处理中的第2种写法）</p>
<p>&emsp;&emsp;例如读取文件异步操作回调函数的写法：</p>
<pre><code>  // 其他代码省略
  asyncFn(1, function () &#123;
    asyncFn(2, function () &#123;
      asyncFn(3, consoleResult)
    &#125;)
  &#125;)
</code></pre>
<p>&emsp;&emsp;这段代码虽然也是串行执行的，但多次嵌套，不利于阅读与维护。我们编写一个流程控制函数来控制异步操作串行执行，代码如下：</p>
<pre><code>  let fileList = [1, 2, 3];
  let fileLines = [];
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb(lines)
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(&#39;代码执行完成，文件行数依次为：&#39;);
    console.log(fileLines)
  &#125;
  function series(item) &#123;
    if (item) &#123;
      asyncFn(item, function (lines) &#123;
        fileLines.push(lines)
        return series(fileList.shift());
      &#125;);
    &#125; else &#123;
      return consoleResult();
    &#125;
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  series(fileList.shift());

  输出
  Mon Nov 30 2020 21:48:41 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 21:48:42 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65
  Mon Nov 30 2020 21:48:43 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 70
  Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 70
  Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,70,70
</code></pre>
<p>&emsp;&emsp;上面的代码中，series为流程控制函数。每次读取一个文件，并将文件名从待读取文件f列表ileList中删除。再递归调用读取下一个文件，直至待读取文件列表为空则所有文件读取完成。这里串行执行读取文件完成需要3s时间。（_串行流程函数控制不止这一种方式实现_）</p>
<p>&emsp;&emsp;将流程控制改为并行执行（利用循环语句）：</p>
<pre><code>  let fileList = [1, 2, 3];
  let fileLines = [];
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb(lines)
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(new Date() + &#39;代码执行完成，文件行数依次为：&#39; + fileLines);
  &#125;
  function series(fileList) &#123;
    fileList.forEach((item, index) =&gt; &#123;
      asyncFn(item, function (lines) &#123;
        fileLines[index] = lines
        if (fileLines.length == fileList.length) &#123;
          consoleResult();
        &#125;
      &#125;);
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  series(fileList);

  输出
  Mon Nov 30 2020 21:49:52 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 94
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 57
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,94,57
</code></pre>
<p>&emsp;&emsp;上面的代码中，series中使用forEach()方法时读取文件同时进行，因为不知道各次读取文件完成的先后顺序，这里不能使用fileLines.push()方法保存结果，可能会得的结果与文件读取顺序不匹配。这里将结果赋值给fileLines[index]能保证结果的顺序与读取文件的顺序一致。当获得的结果的长度与读取文件的次数相同时，所有文件读取完成。这里并行执行读取文件完成需要1s时间。</p>
<p><em>&emsp;&emsp;[注] 并行流程函数控制不止这一种方式实现</em></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2020/12/25/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/01/02/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            JS动画（时序函数、缓动函数、canvas粒子动画）
          
        </div>
      </a>
    
    
      <a href="/2020/12/23/JS%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Class%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JS原型（prototype）链与继承（Class）</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Xiong Gang
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="码农日志"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我吃个雪糕吧，谢谢~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay-payment-code.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat-payment-code.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>