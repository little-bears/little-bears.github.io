<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS定位（Position）与3D坐标轴</title>
    <url>/2020/09/27/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88Position%EF%BC%89%E4%B8%8E3D%E5%9D%90%E6%A0%87%E8%BD%B4/</url>
    <content><![CDATA[<p>用于指定一个元素在文档中的定位方式（元素在网页上的位置），对应的属性top，right，bottom 和 left属性则决定了该元素的最终位置。</p>
<h2 id="1、平面空间坐标轴（2D）"><a href="#1、平面空间坐标轴（2D）" class="headerlink" title="1、平面空间坐标轴（2D）"></a>1、平面空间坐标轴（2D）</h2><p>&emsp;&emsp;在CSS平初始坐标系从屏幕左上角向右为X轴，从左上角向下为Y轴。在position定位方式中，其中top、right、bottom和left代表元素距离参考上方、右方、下方与左方的距离。</p>
<p><img src="/images/css3/%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="平面空间坐标轴"></p>
<h2 id="2、定位类型"><a href="#2、定位类型" class="headerlink" title="2、定位类型"></a>2、定位类型</h2><p>&emsp;&emsp;position的取值：static、relative, absolute, fixed，sticky与inherit<br>&emsp;&emsp;定位元素：是其计算后位置属性为relative,absolute,fixed或sticky的一个元素<br>&emsp;&emsp;(1) 默认定位(static)：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。<br>&emsp;&emsp;(2) 相对定位(relative)：相对于自己最初的位置进行定位，相对位置的坐标参考系是以自己定位前在文档流的位置（x，y）作为原点（0，0）。在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。而且position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p>
<p><img src="/images/css3/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D(relative).png" alt="相对定位(relative)"></p>
<p>&emsp;&emsp;(3) 绝对定位(absolute/fixed)：绝对定位的元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。特别的，fixed绝对定位-固定定位是相对于浏览器窗口（viewport）进行定位，元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p>
<p><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(absolute).png" alt="绝对定位(absolute)"><br><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(fixed).png" alt="绝对定位(fixed)"></p>
<p>&emsp;&emsp;(4) 粘性定位(sticky)：元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。粘性定位表现为相对定位和固定定位叠加的效果。元素在跨越特定阈值前为相对定位(relative)，之后为固定定位(fixed)。</p>
<p><img src="/images/css3/%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D(sticky).png" alt="粘性定位(sticky)"></p>
<h2 id="3、三维空间坐标轴（3D）"><a href="#3、三维空间坐标轴（3D）" class="headerlink" title="3、三维空间坐标轴（3D）"></a>3、三维空间坐标轴（3D）</h2><p>&emsp;&emsp;CSS中3D初始坐标系，其XYZ轴的正方向分别是：向右、向下、向屏幕外。如下图：</p>
<p><img src="/images/css3/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="三维空间坐标轴"></p>
<p>&emsp;&emsp;对一个元素设置属性 transform-style为preserve-3d ，便可对其进行3D变换，有translateX()，translateY()，translateZ()平移方法以及rotateX()，rotateY()，rotateZ()等旋转方法。一般会对元素设置 perspective 属性来调整元素观测的视角。默认旋转中心为左上角（0,0），可通过transform-origin对旋转中心进行移动。<u>当transform使用多个变换函数时，每一个变换函数不仅改变了元素，同时也会改变和元素关联的transform坐标系，当变换函数依次执行时，后一个变换函数总是基于前一个变换后的新transform坐标系执行，所有要注意变换函数的顺序。</u><br>&emsp;&emsp;(1) 对于平移，参照对应坐标轴方向进行相应的平移变换即可。<br>&emsp;&emsp;(2) 对于旋转，先要判断旋转方向，正对某一轴正，其顺时针方向就是该轴旋转的方向，或者采用左手法则判断旋转方向（即左手握住旋转轴，竖起拇指指向旋转轴正方向，其余手指卷曲方向为正方向）；再根据旋转中心的位置进行相应的旋转变换。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS动画（过渡、关键帧、3次贝塞尔曲线）</title>
    <url>/2020/11/26/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<p>CSS 动画可以在不借助 Javascript 的情况下做出一些相对简单的动画效果，例如缩放、移动、2D/3D旋转等。CSS动画有浏览器控制，表现得很流畅。 <u>CSS动画的时序函数主要为3次贝塞尔曲线。</u></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>&emsp;&emsp;CSS动画是由浏览器按照一定的频率一帧一帧的绘制的，CSS实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新动画，不依赖于主线程，所以<u>CSS动画是很流畅的</u>。CSS过渡、关键帧相关知识在前面的文章<a href="/2020/09/24/CSS-3-%E6%A6%82%E8%BF%B0">《CSS(3)概述》</a>里已经讲到，这里摘抄相关知识如下：</p>
<p>&emsp;&emsp;2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你改变被转换元素的位置</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript来完成</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>&emsp;&emsp;您可以改变任意多的样式任意多的次数。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<pre><code>  @keyframes name
  &#123;
    0%   &#123; // 状态1 &#125;
    ...
    xx%  &#123; // 状态x &#125;
    ...
    100% &#123; // 状态n &#125;
  &#125;
  // 自定义动画的使用
  animation: name duration timing-function delay iteration-count direction;

  // timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)
  // iteration-count的取值: n(次数)、infinite
  // animation-direction的取值: normal、alternate
</code></pre>
<br/>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定 @keyframes 动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<strong>CSS动画时序函数(timing-function属性的值）：</strong><br>&emsp;&emsp;CSS动画的时序函数主要为3次贝塞尔曲线。3次贝塞尔曲线由4点个组成，CSS3贝塞尔曲线起点是 (0,0) ，终点是(1,1)，代表动画执行时间到达时动画刚好执行完成。所以CSS中的cubic-bezier()函数只需要传入其他的2个端点值（x1,y1,x2,y2）即可。</p>
<p>&emsp;&emsp;timing-function取值分别对应的贝尔塞曲线函数为：</p>
<p><img src="/images/css3/timing-function%E5%8F%96%E5%80%BC.png" alt="timing-function取值"></p>
<p><em>[注] 以上图片制作于<a href="https://cubic-bezier.com/">https://cubic-bezier.com/</a>，这是一个贝尔塞曲线在线设置与查看的网站，其中紫色的点表示（x1, y1）,蓝色的点表示（x2, y2）。</em></p>
<p>&emsp;&emsp;<strong>其中横轴（x轴）表示时间，纵轴（y轴）表示随着时间推移动画完成情况，曲线的斜率表现为为动画完成的快慢（比如移动速度等）。浏览器会根据时序函数对动画完成情况进行对应的更新（即由时序函数来确定此刻动画中各元素的状态）。</strong>根据图片，可以看到：linear随着时间推移，同一时间间隔动画的完成进度一致，即匀速的完成动画；ease-in先慢后快，ease-out先快后慢；ease-in-out则开始和结束较慢，中间动画完成的进度较快。<br>&emsp;&emsp;特别的，我们也可以使用cubic-bezier自定义时序函数，例如cubic-bezier(.92 ,-0.44, .04, 1.44)，可以看到随着时间的推移，完成情况最先是反向的且完成情况小于0，先快后慢；到最慢时然后完成情况变为正向，呈现先慢后快再慢（类似于ease-in-out），到最慢时此时动画的完成情况是大于1的（也就是多完成了一部分），此时完成情况的方向又变为反向的，先慢后快直到动画完成。</p>
<p>&emsp;&emsp;将cubic-bezier(.92 ,-0.44, .04, 1.44)时序用到transition属性中（时序函数一般要求写在过渡时间的后面）：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
    .ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
      transition: all 3s cubic-bezier(.92, -0.44, .04, 1.44);
    &#125;
    .box:hover .ball &#123;
      margin-left: calc(100% - 50px);
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;具体动画的效果：</p>
<p><img src="/images/css3/%E8%BF%90%E5%8A%A8%E7%9A%84%E5%B0%8F%E7%90%83.gif" alt="运动的小球"></p>
<p>&emsp;&emsp;如代码所示，外层class为box的div宽300px，里面放置一个直径为50px的小球，初始位置为外层div里的最左侧。设置外层div变为hover状态时，小球向右移动到外层div里的最右侧的过渡，过渡时间3s，过渡的时序函数用我们自定义贝塞尔曲线。可以看到小球先向左（反方向）由快到慢的移动，移出了外层div左侧一部分；在向右由慢到快再到慢的移动，特别是中间移动速度极快，停下来时也已移出了外层div最右侧一部分；然后在向左（反方向）由慢到快直至小球停到外层div里的最右侧。外层div失去焦点时小球的移动方式与获得焦点相反。可以看到小球移动的状态与设置时序函数的贝塞尔曲线的状态一致。</p>
<p>&emsp;&emsp;在这里再做一些dome实例的补充：</p>
<h4 id="1）旋转的筛子"><a href="#1）旋转的筛子" class="headerlink" title="1）旋转的筛子"></a>1）旋转的筛子</h4><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AD%9B%E5%AD%90.gif" alt="旋转的筛子"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .cube &#123;
      width: 100px;
      height: 100px;
      perspective: 500px;
      margin: 100px;
      transform-style: preserve-3d;
      animation: rotate 20s infinite;
      animation-timing-function: linear;
    &#125;
    .cube div &#123;
      position: absolute;
      transition: all .4s;
      width: 100px;
      height: 100px;
      opacity: 0.9;
    &#125;
    .cube div img &#123;
      width: 100%;
      height: 100%;
    &#125;
    .front &#123;
      transform: translateZ(50px);
    &#125;
    .back &#123;
      transform: translateZ(-50px);
    &#125;
    .left &#123;
      transform: rotateY(90deg) translateZ(50px);
    &#125;
    .right &#123;
      transform: rotateY(-90deg) translateZ(50px);
    &#125;
    .top &#123;
      transform: rotateX(90deg) translateZ(50px);
    &#125;
    .bottom &#123;
      transform: rotateX(-90deg) translateZ(50px);
    &#125;
    @keyframes rotate &#123;
      from &#123;
        transform: rotateX(0deg) rotateY(0deg);
      &#125;
      to &#123;
        transform: rotateX(360deg) rotateY(360deg);
      &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;cube&quot;&gt;
    &lt;div class=&quot;front&quot;&gt;&lt;img src=&quot;img/3.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;back&quot;&gt;&lt;img src=&quot;img/5.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;img/2.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;img src=&quot;img/4.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;top&quot;&gt;&lt;img src=&quot;img/1.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;bottom&quot;&gt;&lt;img src=&quot;img/6.jpg&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：先在外层class为box的div上设置了观测视角。再对class为cube的div元素设置了transform-style: preserve-3d，使其可以进行3D变换。再对其内部的6个面（实现方式不止代码所示的一种，变换过程中旋转与平移先后顺序不同代码就会不同。这里用图片简单表示骰子的1-6，通过Flex或是Grid布局实现也比较容易）进行相应的3D平移与旋转，布局成为一个立方体。再对class为cube的div元素添加了自定义的关键帧rotate旋转动画。</p>
<h4 id="2）边框滚动动画"><a href="#2）边框滚动动画" class="headerlink" title="2）边框滚动动画"></a>2）边框滚动动画</h4><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E8%BE%B9%E6%A1%86%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB.gif" alt="边框滚动动画"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .outer-box &#123;
      width: 300px; height: 100px; box-sizing: border-box; padding: 2px;
      background: repeating-linear-gradient(45deg, #000, #000 3px, transparent, #000 8px);
      animation: line 1s infinite linear;
    &#125;
    .inner-box &#123;
      width: 100%; height: 100%;
      background-color: #fff;
      display: flex; justify-content: center; align-items: center;
    &#125;
    @keyframes line &#123;
      0% &#123; background-position: 1px -1px; &#125;
      100% &#123; background-position: 12px -12px; &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;outer-box&quot;&gt;
    &lt;div class=&quot;inner-box&quot;&gt;- (^_^) -&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：这里将外层div设置为渐变的背景图片，2px内间距。内部div宽高100%，背景为白色，此时只见外层div出现类似于虚线边框的样式。加入自定义动画line，线性向右上方移动背景图片，便出现了边框滚动的效果。</p>
<h4 id="3）元素沿着不规则路径运动"><a href="#3）元素沿着不规则路径运动" class="headerlink" title="3）元素沿着不规则路径运动"></a>3）元素沿着不规则路径运动</h4><p>&emsp;&emsp;这里我们会用到offset-path等相关属性来实现，这个属性相对较新（要注意浏览器兼容），先介绍常用的属性：<br>&emsp;&emsp;<strong>offset-path：指定元素要遵循的运动路径以及元素位置。</strong>取值为：<br>&emsp;&emsp;&emsp;&emsp;ray() ：定义的一条路径<br>&emsp;&emsp;&emsp;&emsp;url()：引用SVG图片的URL<br>&emsp;&emsp;&emsp;&emsp;形状：circle()、 ellipse()、inset()、polygon()等<br>&emsp;&emsp;&emsp;&emsp;path()：用SVG坐标语法定义的路径字符串<br>&emsp;&emsp;<strong>offset-distance：指定要放置的元素沿路径偏移的位置（px，%）。</strong><br>&emsp;&emsp;<strong>offset-rotate：元素运动的角度（deg），默认auto，表示沿当前路径的切线方向前进。</strong></p>
<p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E4%B8%8D%E8%A7%84%E5%88%99%E8%BF%90%E5%8A%A8.gif" alt="不规则运动"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .box &#123; position: relative; &#125;
    .car &#123;
      offset-path: path(&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot;);
      animation: move 3s linear infinite;
      position: absolute; width: 50px; height: auto;
    &#125;
    @keyframes move &#123;
      100% &#123; offset-distance: 100%; &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;img/car.png&quot; width=&quot;40&quot; height=&quot;43&quot; class=&quot;car&quot;&gt;
    &lt;svg width=&quot;290px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
      &lt;path d=&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot; /&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：这里路径使用SVG图片，设置汽车的图片offset-path偏移路径为SVG中path字符串。自定义动画move使汽车每3s沿SVG路径进行偏移直至100%，便出现了汽车元素沿不规则路径移动的效果。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局（自适应、响应式、Layout）</title>
    <url>/2020/11/02/CSS%E5%B8%83%E5%B1%80%EF%BC%88%E8%87%AA%E9%80%82%E5%BA%94%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%81Layout%EF%BC%89/</url>
    <content><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于盒状模型，依赖 display、 position、float、margin、paddding等属性，采用绝对的单位px、相对单位em、vw、vh、rem以及百分比%等单位进行页面设计。本文将从静态布局、流式布局、自适应布局、响应式布局、弹性布局几个方面进行介绍。</p>
<h2 id="1、静态布局"><a href="#1、静态布局" class="headerlink" title="1、静态布局"></a>1、静态布局</h2><p>&emsp;&emsp;页面采用px单位，一般会设置min-width属性，当页面尺寸小于这个宽度时，出现滚动条进行相应显示，当页面尺寸大于这个宽度时，内容区域一般设置居中显示。使用浮动（float）、定位（position）对元素进行相应的布局<br>&emsp;&emsp;优点：设计简单，编码简单，不用考虑兼容性问题<br>&emsp;&emsp;缺点：有兼容性问题，针对不同的屏幕显示方式一致，对个别用户很不友好。有时也会JS动态修改标签的initial-scale使得页面相应等比缩放，效果有限</p>
<h2 id="2、流式布局"><a href="#2、流式布局" class="headerlink" title="2、流式布局"></a>2、流式布局</h2><p>&emsp;&emsp;页面宽度采用%（百分比）进行布局，高度一般使用px进行设置，或设置为auto并结合margin、paddding进行布局。宽度会随着浏览器宽度进行相应的调整，为了防止对应区域过大或过小使得内容超出区域，一般结合max-width与max-width进行设置。这种布局整体布局方式不变，即页面元素间相对位置不变，文字大小一般使用px，不随页面尺寸变化而变化。布局方式的代表如栅格系统（将网页页面按比例分成对应行列来排列页面中元素的分布）<br>&emsp;&emsp;优点：在一定范围内，能较好的应对不同的PC端页面<br>&emsp;&emsp;缺点：不适应与PC端到移动端较大的尺寸跨度，元素区域过大过小很导致显示不友好。文字大小不随页面宽度变化而变化，在不同屏幕会出现页面不协调的情况</p>
<h2 id="3、自适应布局"><a href="#3、自适应布局" class="headerlink" title="3、自适应布局"></a>3、自适应布局</h2><p>&emsp;&emsp;自适应网页设计的核心，就是CSS3引入的媒体查询模块（@media）。自动探测屏幕宽度，然后加载相应的CSS文件<br>&emsp;&emsp;采用媒体查询技术，为不同屏幕分辨率定义布局，即定义多个静态布局，每个静态布局对应一个屏幕范围，可对页面元素尺寸与位置进行相应的调整，对文字尺寸等也可以特殊设置或使用百分比%、em，rem，vh、vw等相对单位</p>
<p>&emsp;&emsp;特别的，其中：<br>&emsp;&emsp;百分比 %是相对于父元素大小的百分比大小<br>&emsp;&emsp;em是最常见的相对长度单位，基准值是当前元素的字号大小<br>&emsp;&emsp;rem代表“ root”：“ root em”，它等于固定在root元素上的字体大小<br>&emsp;&emsp;vh和vw更多是PC端响应式Web设计依赖百分比规则,尺寸vh等于视口高度的1/100，尺寸vw等于视口宽度的1/100。但CSS百分比度量并非始终是解决所有问题的最佳解决方案<br>&emsp;&emsp;<u>在移动设备中，物理设备上的1px一般不等于css的1px像素，在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px、1024px等值，带来的后果就是浏览器会出现横向滚动条。</u>为了避免这种情况，在移动端页面设计时，让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，使用下面的代码使viewport的宽度等于设备的宽度，即即网页初始大小占屏幕面积的100%</p>
<pre><code>  // 网页宽度等于屏幕宽度（width=device-width），原始缩放比例为1.0（initial-scale=1）
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
</code></pre>
<p>&emsp;&emsp;优点：对PC端、移动端不同屏幕尺寸变化时，页面元素都会进行相应的调整，有较好的适应能力<br>&emsp;&emsp;缺点：为了使不同设备达到较好的，对各个不同屏幕尺寸范围会进行长时间的设计与调整，过程中也会产生大量的冗余代码</p>
<h2 id="4、响应式布局"><a href="#4、响应式布局" class="headerlink" title="4、响应式布局"></a>4、响应式布局</h2><p>&emsp;&emsp;<u>个人认为，响应式布局是比适应布局更高级，是自适应布局的优化；自适应布局是响应式布局的一个子集。它们都会使用媒体查询（@media）根据不同的访问设备的宽度加载不同的样式。</u>如果要说区别的话，或许自适应式只考虑了屏幕尺寸大小，主要使用媒体查询技术来相应的适应性调整，而响应式布局可能还会考虑到移动设备的触屏操作、页面元素排版是否合理，是否需要对元素的位置重新进行调整等问题。</p>
<h2 id="5、弹性布局（Flex布局）"><a href="#5、弹性布局（Flex布局）" class="headerlink" title="5、弹性布局（Flex布局）"></a>5、弹性布局（Flex布局）</h2><p>&emsp;&emsp;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性,可以简便、完整、响应式地实现各种页面布局。具体布局方式在上一篇文章(CSS布局类型（Display、Flex、Grid）)已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-1-Flex%E5%B8%83%E5%B1%80">Display Flex 传送门</a></p>
<h2 id="6、网格布局（Grid布局）"><a href="#6、网格布局（Grid布局）" class="headerlink" title="6、网格布局（Grid布局）"></a>6、网格布局（Grid布局）</h2><p>&emsp;&emsp;Grid 布局是目前最强大的布局方案。Grid 布局与Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。Flex 布局是轴线布局，只能指定项目针对轴线(主轴、交叉轴)的位置，可以看作是一维布局。Grid 布局则是将容器划分成行与列，产生单元格，然后指定项目所在的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。具体布局方式在上一篇文章已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-2-Grid%E5%B8%83%E5%B1%80">Display Grid 传送门</a></p>
<p><em>[注] 在页面的实际设计中，为了使页面达到更合理的布局方式。我们往往会根据布局要求采用多种布局方式来达到我们的目的</em></p>
<h2 id="题外话1-格式化上下文"><a href="#题外话1-格式化上下文" class="headerlink" title="题外话1 格式化上下文"></a>题外话1 格式化上下文</h2><p>&emsp;&emsp;格式化上下文(Block Formatting Context，BFC)是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域<br>&emsp;&emsp;创建BFC的方式：<br>&emsp;&emsp;根元素（html）<br>&emsp;&emsp;浮动元素（元素的 float 不是 none）<br>&emsp;&emsp;绝对定位元素（元素的 position 为 absolute 或 fixed）<br>&emsp;&emsp;行内块元素（元素的 display 为 inline-block）<br>&emsp;&emsp;表格元素（元素的 display 为 table-cell、table-caption等，HTML表格单元格默认为该值）<br>&emsp;&emsp;overflow 值不为 visible 的块元素（一般这种方式用得最多：overflow: hidden/auto）<br>&emsp;&emsp;弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）<br>&emsp;&emsp;网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p>
<p>&emsp;&emsp;BFC布局规则：<br>&emsp;&emsp;① 内部的块级元素会在垂直方向，依次排列<br>&emsp;&emsp;② 外边距塌陷现象，属于同一个BFC的两个相邻元素的margin会发生重叠（在其中一个元素外面添加一个BFC区域来清除外边距塌陷）<br>&emsp;&emsp;③ 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此<br>&emsp;&emsp;④ BFC的区域不会与浮动元素重叠，即浮动不会影响其它BFC中元素的布局<br>&emsp;&emsp;&emsp;&emsp;应用：<u>自适应两栏布局</u><br>&emsp;&emsp;⑤ BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然<br>&emsp;&emsp;⑥ 计算BFC的高度时，浮动元素也参与计算，即浮动元素不会超出BFC区域的边界<br>&emsp;&emsp;&emsp;&emsp;应用：<u>利用BFC特性来清除浮动</u>、<u>布局文本环绕图像样式</u>（也可以通过clearfix清除浮动来实现）</p>
<h2 id="题外话2-clearfix清除浮动"><a href="#题外话2-clearfix清除浮动" class="headerlink" title="题外话2 clearfix清除浮动"></a>题外话2 clearfix清除浮动</h2><p>&emsp;&emsp;原理：clear <strong>属性定义了元素的哪边上不允许出现浮动元素。</strong> <u>如果声明为左边或右边清除(clear: both;)，会使父元素内部之前添加的伪元素的上外边框边界刚好在浮动元素的下外边距边界之下，使得父元素的高度能够超过浮动元素的高度，从而达到清除浮动的目的</u></p>
<p>&emsp;&emsp;代码：</p>
<pre><code>  .box:after &#123;
    content: &#39;&#39;;
    display: block;
    clear: both;
    *zoom: 1;
    // visibility: hidden;
    // height: 0;
    // font-size: 0;
  &#125;
</code></pre>
<h2 id="题外话3-CSS其他知识"><a href="#题外话3-CSS其他知识" class="headerlink" title="题外话3 CSS其他知识"></a>题外话3 CSS其他知识</h2><p>&emsp;&emsp;css模块化有css-in-js的概念，有BEM（block element modifier）命名规范，有less、sass预处理器等方面知识。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML Canvas（2D时序动画）</title>
    <url>/2020/09/15/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>HTML5 canvas 标签用于绘制图像，但元素本身并没有绘制能力（它仅仅是图形的容器），您必须使用JavaScript脚本（相关API）来完成实际的绘图任务。</p>
<h2 id="1、坐标系"><a href="#1、坐标系" class="headerlink" title="1、坐标系"></a>1、坐标系</h2><h4 id="1-标准（初始）坐标系"><a href="#1-标准（初始）坐标系" class="headerlink" title="(1) 标准（初始）坐标系"></a>(1) 标准（初始）坐标系</h4><p><img src="/images/canvas/%E6%A0%87%E5%87%86%EF%BC%88%E5%88%9D%E5%A7%8B%EF%BC%89%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="标准（初始）坐标系"><br>&emsp;&emsp;canvas 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas 元素中的一像素。栅格的起点为左上角，坐标为 (0,0) 。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。</p>
<h4 id="2-偏移坐标原点（translate方法）"><a href="#2-偏移坐标原点（translate方法）" class="headerlink" title="(2) 偏移坐标原点（translate方法）"></a>(2) 偏移坐标原点（translate方法）</h4><p><img src="/images/canvas/%E5%81%8F%E7%A7%BB%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9.png" alt="偏移坐标原点"><br>&emsp;&emsp;translate 方法用来移动 canvas 的原点到指定的位置。接受两个参数。x 是左右偏移量，y 是上下偏移量。</p>
<h4 id="3-旋转坐标轴（rotate方法）"><a href="#3-旋转坐标轴（rotate方法）" class="headerlink" title="(3) 旋转坐标轴（rotate方法）"></a>(3) 旋转坐标轴（rotate方法）</h4><p><img src="/images/canvas/%E6%97%8B%E8%BD%AC%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="旋转坐标轴"><br>&emsp;&emsp;rotate方法用来旋转坐标轴，只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。</p>
<h2 id="2、绘图流程"><a href="#2、绘图流程" class="headerlink" title="2、绘图流程"></a>2、绘图流程</h2><h4 id="1-创建canvas元素（图形容器）"><a href="#1-创建canvas元素（图形容器）" class="headerlink" title="(1) 创建canvas元素（图形容器）"></a>(1) 创建canvas元素（图形容器）</h4><pre><code>  &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;
</code></pre>
<h4 id="2-获取canvas-DOM元素"><a href="#2-获取canvas-DOM元素" class="headerlink" title="(2) 获取canvas DOM元素"></a>(2) 获取canvas DOM元素</h4><pre><code>  let canvas=document.getElementById(&quot;myCanvas&quot;)
</code></pre>
<h4 id="3-获得canvas-context-对象"><a href="#3-获得canvas-context-对象" class="headerlink" title="(3) 获得canvas context 对象"></a>(3) 获得canvas context 对象</h4><pre><code>  let ctx=canvas.getContext(&quot;2d&quot;)
</code></pre>
<h4 id="4-调用相关绘图API定义要绘制的路径与图像"><a href="#4-调用相关绘图API定义要绘制的路径与图像" class="headerlink" title="(4) 调用相关绘图API定义要绘制的路径与图像"></a>(4) 调用相关绘图API定义要绘制的路径与图像</h4><pre><code>  // 画线    
  ctx.moveTo(0, 0);
  ctx.lineTo(100, 100);
  // 画圆
  ctx.arc(95, 50, 40, 2 * Math.PI, 0);
  // ...
  // 可添加对键盘鼠标键盘事件的处理，实现交互动画
</code></pre>
<h4 id="5-绘制已定义的路径及图像"><a href="#5-绘制已定义的路径及图像" class="headerlink" title="(5) 绘制已定义的路径及图像"></a>(5) 绘制已定义的路径及图像</h4><pre><code>  ctx.stroke(); // 有时会重新映射坐标原点或者旋转画布坐标轴，需要ctx.save()与ctx.restore()配合使用来存储于恢复画布状态
</code></pre>
<h4 id="6-定时刷新canvas从而实现动画效果"><a href="#6-定时刷新canvas从而实现动画效果" class="headerlink" title="(6) 定时刷新canvas从而实现动画效果"></a>(6) 定时刷新canvas从而实现动画效果</h4><pre><code>  // requestAnimationFrame()方法（推荐）或者setInterval()/递归调用setTimeout()方法进行刷新动画
</code></pre>
<h2 id="3、常用绘图属性与API方法"><a href="#3、常用绘图属性与API方法" class="headerlink" title="3、常用绘图属性与API方法"></a>3、常用绘图属性与API方法</h2><h4 id="1-颜色、样式、阴影属性与方法"><a href="#1-颜色、样式、阴影属性与方法" class="headerlink" title="(1) 颜色、样式、阴影属性与方法"></a>(1) 颜色、样式、阴影属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td>shadowOffsetX</td>
<td>设置或返回阴影与形状的水平距离</td>
</tr>
<tr>
<td>shadowOffsetY</td>
<td>设置或返回阴影与形状的垂直距离</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr>
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td>createRadialGradient()</td>
<td>创建放射状/环形的渐变（用在画布内容上）</td>
</tr>
<tr>
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody></table>
<h4 id="2-线条样式属性"><a href="#2-线条样式属性" class="headerlink" title="(2) 线条样式属性"></a>(2) 线条样式属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lineCap</td>
<td>设置或返回线条的结束端点样式(值为square、round，线条会稍稍变长)</td>
</tr>
<tr>
<td>lineJoin</td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td>lineWidth</td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td>miterLimit</td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody></table>
<h4 id="3-矩形方法"><a href="#3-矩形方法" class="headerlink" title="(3) 矩形方法"></a>(3) 矩形方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>rect()</td>
<td>创建矩形</td>
</tr>
<tr>
<td>fillRect()</td>
<td>绘制‘被填充’的矩形</td>
</tr>
<tr>
<td>strokeRect()</td>
<td>绘制矩形（无填充）</td>
</tr>
<tr>
<td>clearRect()</td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
</tbody></table>
<h4 id="4-路径方法"><a href="#4-路径方法" class="headerlink" title="(4) 路径方法"></a>(4) 路径方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fill()</td>
<td>填充当前绘图（路径）</td>
</tr>
<tr>
<td>stroke()</td>
<td>绘制已定义的路径</td>
</tr>
<tr>
<td>beginPath()</td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr>
<td>closePath()</td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr>
<td>lineTo()</td>
<td>添加一个新点，然后在画布中创建从该点到最后指定点的线条</td>
</tr>
<tr>
<td>clip()</td>
<td>原始画布剪切任意形状和尺寸的区域(裁剪路径的作用可制作遮罩)</td>
</tr>
<tr>
<td>quadraticCurveTo()</td>
<td>创建二次贝塞尔曲线</td>
</tr>
<tr>
<td>bezierCurveTo()</td>
<td>创建三次贝塞尔曲线</td>
</tr>
<tr>
<td>arc()</td>
<td>创建弧/曲线（用于创建圆形或部分圆）</td>
</tr>
<tr>
<td>arcTo()</td>
<td>创建两切线之间的弧/曲线</td>
</tr>
<tr>
<td>isPointInPath()</td>
<td>如果指定的点位于当前路径中，则返回true，否则返回false</td>
</tr>
<tr>
<td>setLineDash()</td>
<td>填充线时使用虚线模式（参数为数组，交替描述绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复）</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;注：一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）</em></p>
<h4 id="5-转换方法"><a href="#5-转换方法" class="headerlink" title="(5) 转换方法"></a>(5) 转换方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr>
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr>
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr>
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr>
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵。然后运行transform()</td>
</tr>
</tbody></table>
<h4 id="6-文本属性与方法"><a href="#6-文本属性与方法" class="headerlink" title="(6) 文本属性与方法"></a>(6) 文本属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>font</td>
<td>设置或返回文本内容的当前字体属性</td>
</tr>
<tr>
<td>textAlign</td>
<td>设置或返回文本内容的当前对齐方式</td>
</tr>
<tr>
<td>textBaseline</td>
<td>设置或返回在绘制文本时使用的当前文本基线</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillText()</td>
<td>在画布上绘制”被填充的”文本</td>
</tr>
<tr>
<td>strokeText()</td>
<td>在画布上绘制文本（无填充）</td>
</tr>
<tr>
<td>measureText()</td>
<td>返回包含指定文本宽度的对象</td>
</tr>
</tbody></table>
<h4 id="7-像素操作属性与方法"><a href="#7-像素操作属性与方法" class="headerlink" title="(7) 像素操作属性与方法"></a>(7) 像素操作属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>返回 ImageData 对象的宽度</td>
</tr>
<tr>
<td>height</td>
<td>返回 ImageData 对象的高度</td>
</tr>
<tr>
<td>data</td>
<td>返回一个对象，其包含指定的 ImageData 对象的图像数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createImageData()</td>
<td>创建新的、空白的 ImageData 对象</td>
</tr>
<tr>
<td>getImageData()</td>
<td>返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据</td>
</tr>
<tr>
<td>putImageData()</td>
<td>把图像数据（从指定的 ImageData 对象）放回画布上</td>
</tr>
</tbody></table>
<h4 id="8-图像绘制方法"><a href="#8-图像绘制方法" class="headerlink" title="(8) 图像绘制方法"></a>(8) 图像绘制方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>drawImage()</td>
<td>向画布上绘制图像、画布或视频</td>
</tr>
</tbody></table>
<pre><code>  context.drawImage(img,[sx,sy,swidth,sheight,]x,y,[width,height]); // 语法，其中img为Image实例
</code></pre>
<h4 id="9-其他属性与方法"><a href="#9-其他属性与方法" class="headerlink" title="(9) 其他属性与方法"></a>(9) 其他属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>globalAlpha</td>
<td>设置或返回绘图的当前 alpha 或透明值</td>
</tr>
<tr>
<td>globalCompositeOperation</td>
<td>设置或返回新图像如何绘制到已有的图像上</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>save()</td>
<td>保存当前环境的状态（可以调用任意多次save方法，类似数组的push）</td>
</tr>
<tr>
<td>restore()</td>
<td>返回之前保存过的路径状态和属性（调用restore方法，上一个保存的状态就从栈中弹出，类似于数组pop）</td>
</tr>
</tbody></table>
<h2 id="4、canvas小案例（时钟）"><a href="#4、canvas小案例（时钟）" class="headerlink" title="4、canvas小案例（时钟）"></a>4、canvas小案例（时钟）</h2><p>(1) 动画效果：<br><img src="/images/canvas/%E6%97%B6%E9%92%9F.gif" alt="时钟"><br>(2) 实现代码：</p>
<pre><code>  &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
      &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;title&gt;时钟&lt;/title&gt;
        &lt;style&gt;
            html,
            body &#123;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            &#125;
            body &#123;
                display: flex;
                justify-content: center;
                align-items: center;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id=&quot;clock&quot; height=&quot;250px&quot; width=&quot;250px&quot;&gt;&lt;/canvas&gt;
        &lt;script&gt;
            // 时钟
            let dom = document.getElementById(&#39;clock&#39;);
            let ctx = dom.getContext(&#39;2d&#39;);
            let width = ctx.canvas.width;
            let height = ctx.canvas.height;
            let r = width / 2;
            // 绘制时钟，定义计时器对其进行实时刷新
            draw();
            setInterval(draw, 1000);
            //绘制时钟圆环
            function drawBackground() &#123;
                ctx.save();
                ctx.translate(r, r);
                ctx.beginPath();
                ctx.lineWidth = 10;
                ctx.arc(0, 0, r - ctx.lineWidth / 2, 0, 2 * Math.PI, false);
                ctx.stroke();
            &#125;
            // 绘制时间数字
            function drawNumber() &#123;
                let hourNumbers = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2];
                hourNumbers.map(function (number, i) &#123;
                    let rad = 2 * Math.PI / 12 * i;
                    let x = Math.cos(rad) * (r - 30);
                    let y = Math.sin(rad) * (r - 30);
                    ctx.textAlign = &#39;center&#39;;
                    ctx.textBaseline = &#39;middle&#39;;
                    ctx.font = 16 + &quot;px Arial&quot;;
                    ctx.fillText(number, x, y)
                &#125;);
                ctx.stroke();
            &#125;
            // 绘制刻度
            function drawDots() &#123;
                let hourNumbers = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2];
                for (let i = 0; i &lt; 60; i++) &#123;
                    let rad = 2 * Math.PI / 60 * i;
                    let x = Math.cos(rad) * (r - 16);
                    let y = Math.sin(rad) * (r - 16) + 1;
                    ctx.textAlign = &#39;center&#39;;
                    ctx.textBaseline = &#39;middle&#39;;
                    ctx.font = 18 + &quot;px Arial&quot;;
                    if (i % 5 == 0) &#123;
                        ctx.fillStyle = &#39;black&#39;;
                    &#125; else &#123;
                        ctx.fillStyle = &#39;#d1d1d1&#39;;
                    &#125;
                    ctx.fillText(&#39; • &#39;, x, y)
                &#125;
                ctx.stroke();
            &#125;
            // 绘制时针
            function drawHour(hour, minute) &#123;
                ctx.save();
                ctx.beginPath();
                let rad = 2 * Math.PI / 12 * hour;
                let mrad = 2 * Math.PI / 12 / 60 * minute;
                ctx.rotate(rad + mrad);
                ctx.lineWidth = 6;
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -r / 2);
                ctx.lineCap = &#39;round&#39;;
                ctx.stroke();
                ctx.restore();
            &#125;
            // 绘制分针
            function drawMinute(minute, second) &#123;
                ctx.save()
                ctx.beginPath();
                let rad = 2 * Math.PI / 60 * minute;
                let mrad = 2 * Math.PI / 60 / 60 * second;
                ctx.rotate(rad + mrad);
                ctx.lineWidth = 4;
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -r / 2 - 10);
                ctx.lineCap = &#39;round&#39;;
                ctx.stroke();
                ctx.restore();
            &#125;
            // 绘制秒针
            function drawSecond(second) &#123;
                ctx.save();
                ctx.beginPath();
                let rad = 2 * Math.PI / 60 * second;
                ctx.rotate(rad);
                ctx.lineWidth = 2;
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -r / 2 - 20);
                let gnt1 = ctx.createLinearGradient(0, 0, 0, -r / 2 - 20);
                gnt1.addColorStop(0, &#39;red&#39;);
                gnt1.addColorStop(1, &#39;rgb(250, 94, 94)&#39;);
                ctx.strokeStyle = gnt1;
                ctx.lineCap = &#39;round&#39;;
                ctx.stroke();
                ctx.restore();
            &#125;
            // 主函数-绘制时钟
            function draw() &#123;
                ctx.clearRect(0, 0, 300, 300);
                let now = new Date();
                let hour = now.getHours() &lt; 10 ? &#39;0&#39; + now.getHours() : now.getHours();
                let minute = now.getMinutes() &lt; 10 ? &#39;0&#39; + now.getMinutes() : now.getMinutes();
                let second = now.getSeconds() &lt; 10 ? &#39;0&#39; + now.getSeconds() : now.getSeconds();
                drawBackground();
                drawNumber();
                drawDots();
                drawHour(hour, minute);
                drawMinute(minute, second);
                drawSecond(second);
                ctx.restore();
            &#125;
        &lt;/script&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML(5)概述</title>
    <url>/2020/09/14/HTML-5-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>HTML称为超文本标记语言（Hyper Text Markup Language），用来描述网页文档内容的含义和结构。</p>
<h2 id="1、标记语言和编程语言"><a href="#1、标记语言和编程语言" class="headerlink" title="1、标记语言和编程语言"></a>1、标记语言和编程语言</h2><p>&emsp;&emsp;标记语言，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的文字编码。标记语言是一套标记标签，HTML 文档使用标记标签来描述网页。HTML 文档包含 HTML 标签和纯文本。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p>
<p>&emsp;&emsp;编程语言，是一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。即编写语言是与计算机进行交互，是计算机执行相应计算的语言。例如Python、C、Java等程序语言。</p>
<h2 id="2、HTML-lt-DOCTYPE-gt"><a href="#2、HTML-lt-DOCTYPE-gt" class="headerlink" title="2、HTML &lt;!DOCTYPE&gt;"></a>2、HTML &lt;!DOCTYPE&gt;</h2><p>&emsp;&emsp;&lt;!DOCTYPE&gt;用来申明浏览器按照那个HTML版本来解析文档。它没有结束标签，对大小写不敏感，要写在文档第一行才有效；否则相当于没写这个申明。当没写这个申明时，支持HTML5的浏览器默认是<!DOCTYPE html>。特别的，HTML4及以前的版本，标记语言基于SGML，在申明HTML版本时，还需要申明DTD（文档类型定义）来告诉浏览器按照那个模式来解析HTML文档。</p>
<h2 id="3、常用标签"><a href="#3、常用标签" class="headerlink" title="3、常用标签"></a>3、常用标签</h2><p>&emsp;&emsp;HTML 标签（也称HTML元素）是由尖括号包围的关键词, 标签通常是成对出现的。标签对中第一个便签是开始标签（开放标签），第二个标签是结束标签（闭合标签）。大多数HTML元素可拥有属性，也可与其他HTML元素进行嵌套。HTML标签对大小写不明感，推荐小写。</p>
<p>&emsp;&emsp;浏览器会自动地在标题的前后添加空行。默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。</p>
<p>&emsp;&emsp;浏览器在显示页面时，会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。代码中的所有连续的换行（br）也被显示为一个空格。</p>
<p>&emsp;&emsp;段落（p）的行数依赖于浏览器窗口的大小。如果调节浏览器窗口的大小，将改变段落中的行数。</p>
<h4 id="1-基础标签"><a href="#1-基础标签" class="headerlink" title="(1) 基础标签"></a>(1) 基础标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>定义HTML文档结构</td>
</tr>
<tr>
<td>body</td>
<td>定义文档主体内容</td>
</tr>
<tr>
<td>h1-h6</td>
<td>定义HTML标题</td>
</tr>
<tr>
<td>p</td>
<td>定义段落</td>
</tr>
<tr>
<td>br</td>
<td>定义简单的换行（不产生一个新段落的情况下进行换行）</td>
</tr>
<tr>
<td>hr</td>
<td>定义水平线</td>
</tr>
</tbody></table>
<h4 id="2-格式化标签"><a href="#2-格式化标签" class="headerlink" title="(2) 格式化标签"></a>(2) 格式化标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>strong</td>
<td>语气更为强烈的文本（粗体，与b标签表现形式类似）</td>
</tr>
<tr>
<td>cite</td>
<td>引用</td>
</tr>
<tr>
<td>code</td>
<td>代码文本 ，不保留多余的空格和折行，需要则可与pre标签结合使用</td>
</tr>
<tr>
<td>del</td>
<td>定义删除文本（中划线）</td>
</tr>
<tr>
<td>em</td>
<td>强调文本（斜体，与i标签表现形式类似）</td>
</tr>
<tr>
<td>ins</td>
<td>插入文本（下划线）</td>
</tr>
<tr>
<td>kbd</td>
<td>键盘文本</td>
</tr>
<tr>
<td>mark</td>
<td>(HTML5新增) 有记号的文本（黄色背景）</td>
</tr>
<tr>
<td>meter</td>
<td>(HTML5新增) 预定义范围内的度量（进度条形式）</td>
</tr>
<tr>
<td>pre</td>
<td>(HTML5新增) 预格式文本（特殊符号会被转化为符号实体）</td>
</tr>
<tr>
<td>progress</td>
<td>(HTML5新增) 任何类型的任务的进度（进度条）</td>
</tr>
<tr>
<td>q</td>
<td>短引用（文本加上双引号）</td>
</tr>
<tr>
<td>blockquote</td>
<td>长的引用（文本整体进行缩进）</td>
</tr>
<tr>
<td>address</td>
<td>地址（斜体）</td>
</tr>
<tr>
<td>abbr</td>
<td>缩写</td>
</tr>
<tr>
<td>ruby</td>
<td>(HTML5新增) ruby注释</td>
</tr>
<tr>
<td>rt</td>
<td>显示中文注音或字符（嵌套在ruby元素内部）</td>
</tr>
<tr>
<td>rp</td>
<td>显示浏览器不支持ruby显示的内容（嵌套在ruby元素内部）</td>
</tr>
<tr>
<td>small</td>
<td>小号字体文本</td>
</tr>
<tr>
<td>sub</td>
<td>上标文本</td>
</tr>
<tr>
<td>sup</td>
<td>下标文本</td>
</tr>
</tbody></table>
<h4 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="(3) 表单标签"></a>(3) 表单标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>form</td>
<td>定义提供用户输入的HTML表单</td>
</tr>
<tr>
<td>input</td>
<td>定义输入控件</td>
</tr>
<tr>
<td>textarea</td>
<td>定义多行文本输入控件</td>
</tr>
<tr>
<td>button</td>
<td>定义按钮</td>
</tr>
<tr>
<td>select</td>
<td>定义下拉选择列表</td>
</tr>
<tr>
<td>optgroup</td>
<td>定义下拉列表相关选项组合</td>
</tr>
<tr>
<td>option</td>
<td>定义下拉列表中的选项</td>
</tr>
<tr>
<td>label</td>
<td>定义input元素标注</td>
</tr>
<tr>
<td>fieldset</td>
<td>定义围绕表单中元素的边框</td>
</tr>
<tr>
<td>legend</td>
<td>定义fieldset元素标题</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;input常用输入限制属性：</em><br><em>&emsp;&emsp;&emsp;accept、autocomplate、autofocus、value、checked、multiple、readonly、disabled、size、maxlength、min、max、pattern、required、size、step、placeholder、width…</em></p>
<p><em>&emsp;&emsp;&emsp;input type取值：</em><br><em>&emsp;&emsp;&emsp; text、password、file、hidden、reset、submit、radio、checkbox、button、number、date、color、range、month、week、time、datetime(IE、Firefox 或者 Chrome 不支持)、datetime-local、email、search、tel、url、image（定义图像形式的按钮）…</em></p>
<h4 id="4-图像标签"><a href="#4-图像标签" class="headerlink" title="(4) 图像标签"></a>(4) 图像标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>img</td>
<td>定义图像（alt 属性用来为图像定义一串预备的可替换的文本）</td>
</tr>
<tr>
<td>map</td>
<td>定义映射图像</td>
</tr>
<tr>
<td>area</td>
<td>定义图像地图内部区域（嵌套在map元素内部）</td>
</tr>
<tr>
<td>canvas</td>
<td>(HTML5新增) 定义图形</td>
</tr>
<tr>
<td>figure</td>
<td>(HTML5新增) 定义媒介内容的分组，以及他们的标题</td>
</tr>
<tr>
<td>figcaption</td>
<td>(HTML5新增) 定义figure元素的标题</td>
</tr>
</tbody></table>
<h4 id="5-音频视频标签"><a href="#5-音频视频标签" class="headerlink" title="(5) 音频视频标签"></a>(5) 音频视频标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>audio</td>
<td>(HTML5新增) 定义声音内容</td>
</tr>
<tr>
<td>source</td>
<td>(HTML5新增) 定义媒介源（嵌套在audio标签内部）</td>
</tr>
<tr>
<td>video</td>
<td>(HTML5新增) 定义视频</td>
</tr>
<tr>
<td>track</td>
<td>(HTML5新增) 定义媒体播放器的文本轨道（嵌套在video标签内部）</td>
</tr>
</tbody></table>
<h4 id="6-链接标签"><a href="#6-链接标签" class="headerlink" title="(6) 链接标签"></a>(6) 链接标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>定义锚</td>
</tr>
<tr>
<td>link</td>
<td>定义文档与外部资源的关系</td>
</tr>
<tr>
<td>nav</td>
<td>(HTML5新增) 定义导航链接</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;a标签的常用属性：</em><br><em>&emsp;&emsp;&emsp;1) href 规定链接指向的页面的 URL或者页面某一位置</em><br><em>&emsp;&emsp;&emsp;2) download  (HTML5新增) 使用download，规定被下载的超链接目标名称</em><br><em>&emsp;&emsp;&emsp;3) media (HTML5新增) 规定被链接文档是为何种媒介/设备优化的</em><br><em>&emsp;&emsp;&emsp;4) target 规定在何处打开链接文档</em><br><em>&emsp;&emsp;&emsp;5) type  (HTML5新增) 规定被链接文档的的 MIME 类型</em></p>
<h4 id="7-列表标签"><a href="#7-列表标签" class="headerlink" title="(7) 列表标签"></a>(7) 列表标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ul</td>
<td>定义无序列表</td>
</tr>
<tr>
<td>ol</td>
<td>定义有序列表</td>
</tr>
<tr>
<td>li</td>
<td>定义列表的项目（可嵌套其他HTML元素）</td>
</tr>
<tr>
<td>dl</td>
<td>定义列表</td>
</tr>
<tr>
<td>dt</td>
<td>定义列表中的项目</td>
</tr>
<tr>
<td>dd</td>
<td>定义列表中的项目描述</td>
</tr>
</tbody></table>
<h4 id="8-表格标签"><a href="#8-表格标签" class="headerlink" title="(8) 表格标签"></a>(8) 表格标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>table</td>
<td>定义表格</td>
</tr>
<tr>
<td>caption</td>
<td>定义表格标题</td>
</tr>
<tr>
<td>th</td>
<td>定义表格中的表头单元格</td>
</tr>
<tr>
<td>tr</td>
<td>定义表格中的行</td>
</tr>
<tr>
<td>td</td>
<td>定义表格中的单元格</td>
</tr>
<tr>
<td>thead</td>
<td>定义表格中的表头内容</td>
</tr>
<tr>
<td>tbody</td>
<td>定义表格中的主体内容</td>
</tr>
<tr>
<td>tfoot</td>
<td>定义表格中的表注内容（脚注）</td>
</tr>
<tr>
<td>col</td>
<td>定义表格中一个和多个列属性</td>
</tr>
<tr>
<td>colgroup</td>
<td>定义表格中供格式化的列组</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;表格标签的常用属性：</em><br><em>&emsp;&emsp;&emsp;1) table border（边框）、background（表格背景）、cellpadding（单元格边距）、cellspacing（单元格间距）、frame（框架-控制表格边框）</em><br><em>&emsp;&emsp;&emsp;2) th/td colspan（跨列）、rowspan（跨行）、background（单元格背景）、align（单元格对齐方式</em><br><em>&emsp;&emsp;&emsp;注: 空的单元格的边框不会显示，可使用 空格字符”&amp;nbsp;” 处理没有内容的单元格显示边框；单元格内可嵌套其他HTML元素</em></p>
<h4 id="9-布局标签"><a href="#9-布局标签" class="headerlink" title="(9) 布局标签"></a>(9) 布局标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>style</td>
<td>定义文档的样式信息</td>
</tr>
<tr>
<td>link</td>
<td>定义资源引用</td>
</tr>
<tr>
<td>div</td>
<td>定义文档中的节点，可用于组合其他 HTML 元素的容器（块级元素代表）</td>
</tr>
<tr>
<td>span</td>
<td>定义文档中的节点（内联元素代表）</td>
</tr>
<tr>
<td>header</td>
<td>(HTML5新增) 定义section或page的页眉</td>
</tr>
<tr>
<td>footer</td>
<td>(HTML5新增) 定义section或page的页脚</td>
</tr>
<tr>
<td>section</td>
<td>(HTML5新增) 定义section</td>
</tr>
<tr>
<td>article</td>
<td>(HTML5新增) 定义文章</td>
</tr>
<tr>
<td>aside</td>
<td>(HTML5新增) 定义页面内容之外的内容</td>
</tr>
<tr>
<td>details</td>
<td>(HTML5新增) 定义用户可查看或隐藏的额外细节</td>
</tr>
<tr>
<td>summary</td>
<td>(HTML5新增) 定义 details 元素的可见标题</td>
</tr>
</tbody></table>
<h4 id="10-元信息标签"><a href="#10-元信息标签" class="headerlink" title="(10) 元信息标签"></a>(10) 元信息标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>head</td>
<td>定义关于文档的信息</td>
</tr>
<tr>
<td>meta</td>
<td>定义HTML文档的元信息（name 和 content 描述页面的内容）</td>
</tr>
<tr>
<td>base</td>
<td>定义页面所有链接的默认地址或默认目标</td>
</tr>
</tbody></table>
<h4 id="11-编程标签"><a href="#11-编程标签" class="headerlink" title="(11) 编程标签"></a>(11) 编程标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>script</td>
<td>定义客户端脚本（HTML5已不支持type属性）</td>
</tr>
<tr>
<td>noscript</td>
<td>针对不支持脚本的客户端的替代内容（比如提示）</td>
</tr>
<tr>
<td>embed</td>
<td>(HTML5新增) 为外部应用（非HTML定义容器，比如插入音频），最好插入的音频的方法：HTML 5 audio + embed（或者引入第三方播放器）</td>
</tr>
<tr>
<td>object</td>
<td>定义嵌入的对象（支持 HTML 助手（插件），比如插入视频），最好插入视频的方法：HTML 5 video + object + embed</td>
</tr>
<tr>
<td>param</td>
<td>定义嵌入对象的参数</td>
</tr>
</tbody></table>
<h4 id="12-框架标签"><a href="#12-框架标签" class="headerlink" title="(12) 框架标签"></a>(12) 框架标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>frameset</td>
<td>定义框架结构（rows/columns 的值规定了每行或每列占据屏幕的面积）</td>
</tr>
<tr>
<td>frame</td>
<td>定义了放置在每个框架中的 HTML 文档（嵌套在frameset元素内部）</td>
</tr>
<tr>
<td>noframes</td>
<td>定义不支持frameset客户端的可替换文本</td>
</tr>
<tr>
<td>iframe</td>
<td>定义内联的子窗口（框架）</td>
</tr>
</tbody></table>
<h2 id="4、HTML标签属性"><a href="#4、HTML标签属性" class="headerlink" title="4、HTML标签属性"></a>4、HTML标签属性</h2><p>&emsp;&emsp;HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。属性总是以名称/值对的形式出现，属性总是在 HTML 元素的开始标签中规定。HTML标签属性对大小写不明感，推荐小写。</p>
<p>&emsp;&emsp;常用HTML标签属性：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>元素的类名（classname）</td>
</tr>
<tr>
<td>id</td>
<td>元素的唯一 id</td>
</tr>
<tr>
<td>style</td>
<td>元素的行内样式（inline style）</td>
</tr>
<tr>
<td>title</td>
<td>元素的额外信息（可在工具提示中显示）</td>
</tr>
<tr>
<td>contenteditable</td>
<td>(HTML5新增) 元素内容是否可编辑</td>
</tr>
<tr>
<td>data-*</td>
<td>(HTML5新增) 用于存储页面或程序自定义属性数据</td>
</tr>
<tr>
<td>dir</td>
<td>元素中内容的文本方向</td>
</tr>
<tr>
<td>draggable</td>
<td>(HTML5新增) 元素是否可拖动（链接和图像默认是可拖动的）</td>
</tr>
<tr>
<td>hidden</td>
<td>(HTML5新增) 元素仍未或不再相关（浏览器不显示 hidden 属性的元素）</td>
</tr>
<tr>
<td>tabindex</td>
<td>元素的 tab 键选中次序</td>
</tr>
</tbody></table>
<h2 id="5、HTML语义化"><a href="#5、HTML语义化" class="headerlink" title="5、HTML语义化"></a>5、HTML语义化</h2><p>HTML语义化的目的：用更合适的标签做更合适的事情，使文档内容结构化、代码语义化</p>
<p>优点：<br>&emsp;&emsp;(1) 提高代码可读性<br>&emsp;&emsp;(2) 利于浏览器解析与SEO搜索引擎优化<br>&emsp;&emsp;(3) 提高代码可维护性与重用性</p>
<p>提高代码语义化的方法：<br>&emsp;&emsp;(1) 减少使用没有语义的标签，例如div、span等<br>&emsp;&emsp;(2) 减少使用纯样式标签，例如b、i等<br>&emsp;&emsp;(3) 表单使用fieldset包裹；使用legend添加标题；使用label标签为input添加标注<br>&emsp;&emsp;(4) 表格使用caption添加标题，表头部分用thead、主体部分用tbody、脚注部分用tfoot包裹<br>&emsp;&emsp;(5) img元素附带alt信息，即对图片进行文本说明，当图像无法查看时会显示文本描述</p>
<h2 id="6、网站SEO搜索引擎优化"><a href="#6、网站SEO搜索引擎优化" class="headerlink" title="6、网站SEO搜索引擎优化"></a>6、网站SEO搜索引擎优化</h2><p>SEO目的：为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望搜索引擎能多多我们收录网站，并且在别人进行搜索时网站能排列在搜索结果的前面</p>
<p>实现方式：<br>&emsp;&emsp;(1) 提高网站代码的语义化<br>&emsp;&emsp;(2) 重要内容不使用JS输出<br>&emsp;&emsp;(3) 网站的标题（title）进行合理设置<br>&emsp;&emsp;(4) 对关键字、描述精心设计</p>
<pre><code>  &lt;meta name=&quot;description&quot; content=&quot;...&quot;&gt;
  &lt;meta name=&quot;keywords&quot; content=&quot;...&quot;&gt;
</code></pre>
<h2 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h2><h4 id="1-URL-统一资源定位器"><a href="#1-URL-统一资源定位器" class="headerlink" title="(1) URL-统一资源定位器"></a>(1) URL-统一资源定位器</h4><p>&emsp;&emsp;URL （Uniform Resource Locator）也被称为网址，由域名或IP地址、端口、路径等遵循一定的规则形成。</p>
<pre><code>  scheme://host.domain:port/path/filename
  // scheme - 定义因特网服务的类型。常见的类型http、https、ftp、file
  // host - 定义域主机（http 的默认主机是 www）
  // domain - 定义因特网域名，比如 w3school.com.cn
  // :port - 定义主机上的端口号（http 的默认端口号是 80，https的默认端口号443）
  // path - 定义服务器上的路径
  // filename - 定义文档/资源的名称
</code></pre>
<p>&emsp;&emsp;HTML URL 编码：<br>&emsp;&emsp;URL 会将字符转换为可通过因特网传输的格式，只能使用 ASCII 字符集来通过因特网进行发送。编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 编码不能包含空格，通常使用 + 来替换空格。</p>
<h4 id="2-文件路径"><a href="#2-文件路径" class="headerlink" title="(2) 文件路径"></a>(2) 文件路径</h4><p>&emsp;&emsp;文件路径描述了网站文件夹结构中某个文件的位置，文件路径会在链接外部文件时被用到。比如链接网页、图像、视频、样式表、JavaScript等。分为绝对路径（绝对文件路径是指向一个因特网文件的完整 URL）与相对路径（相对路径指向了相对于当前页面的文件）。</p>
<h4 id="3-字符实体"><a href="#3-字符实体" class="headerlink" title="(3) 字符实体"></a>(3) 字符实体</h4><p>&emsp;&emsp;在 HTML 中，某些字符是预留的，有特定的含义。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体，用&amp;entity_name（实体名称）或&amp;#entity_number（实体编号）表示。<br>&emsp;&emsp;常用的字符实体：</p>
<table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>实体名称</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td>&amp;nbsp;</td>
<td>&amp;#160;</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt;</td>
<td>&amp;#60;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt;</td>
<td>&amp;#62;</td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td>&amp;quot;</td>
<td>&amp;#34;</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp;</td>
<td>&amp;#38;</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
<td>&amp;times;</td>
<td>&amp;#215;</td>
</tr>
<tr>
<td>/</td>
<td>除号</td>
<td>&amp;divide;</td>
<td>&amp;#247;</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy;</td>
<td>&amp;#169;</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg;</td>
<td>&amp;#174;</td>
</tr>
<tr>
<td>™</td>
<td>商标</td>
<td>&amp;trade;</td>
<td>&amp;#8482;</td>
</tr>
</tbody></table>
<h4 id="4-颜色值"><a href="#4-颜色值" class="headerlink" title="(4) 颜色值"></a>(4) 颜色值</h4><p>&emsp;&emsp; 由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JS预解析、作用域、执行上下文、this</title>
    <url>/2020/12/05/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/</url>
    <content><![CDATA[<p>这部分是JavaScript比较基础的部分。JS代码运行前的极短时间内会进行语法分析、代码预解析以及解释执行。其中预解析最重要。分为全局预解析和局部预解析，全局预解析发生在页面加载完成时执行，而局部预解析发生在函数执行的前一刻。会进行变量与函数申明（变量提升）、生成执行上下文（作用域）等工作。</p>
<h2 id="1、作用域（链）"><a href="#1、作用域（链）" class="headerlink" title="1、作用域（链）"></a>1、作用域（链）</h2><p>&emsp;&emsp;JavaScript采用词法作用域，作用域在代码定义时就确定，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限，执行时并且不会改变（作用域访问的变量是编写代码的结构确定的）。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。函数的原型（prototype）属性存在[[Scopes]]属性保存着当前函数的作用域链信息。</p>
<p>&emsp;&emsp;作用域分为全局作用域、函数(局部)作用域、块级作用域（ES6引入）。<br>&emsp;&emsp;① 在代码中任何地方都能访问到的对象拥有全局作用域。全局作用域的变量是全局对象的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，但加上全局对象，可以提供搜索效率。<br><em>&emsp;&emsp;[注] 隐式的申明变量，在最外层函数外部申明的变量，给window对象添加的属性都是全局变量</em><br>&emsp;&emsp;② 在函数内部用var关键字申明的变量，函数的参数会存在于该函数的局部作用域中。<br><em>&emsp;&emsp;[注] 局部变量的优先级高于全局变量</em><br>&emsp;&emsp;③ 用let、const申明的变量会存在于块级作用域中。</p>
<h2 id="2、预解析与执行上下文"><a href="#2、预解析与执行上下文" class="headerlink" title="2、预解析与执行上下文"></a>2、预解析与执行上下文</h2><p>&emsp;&emsp;JavaScript代码在执行前的瞬间会存在预解析的阶段，会对代码进行相应的处理，对申明的变量与函数进行变量提升，以及生成对应的执行上下文，执行上下文除了保存代码执行信息外，还会将当前作用域信息也保存在执行上下文中，他们有相应的存储关系。随着代码进行的进行，执行上下文会进行相应的改变，执行上下文是用于跟踪代码的运行情况。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p>
<p>&emsp;&emsp;预解析处理创建执行上下文的步骤：<br>&emsp;&emsp;① 隐式的创建GO（全局上下文）/AO（函数上下文）对象<br>&emsp;&emsp;② 找形参和变量声明，将变量和形参名作为GO/AO的属性名，值为undefined（这个过程也常称为变量提升）<br>&emsp;&emsp;③ 将实参值和形参统一<br>&emsp;&emsp;④ 在函数体里面找函数声明，作为GO/AO的属性，值赋予函数体（这个过程也常称为函数提升）<br><em>&emsp;&emsp;[注] 在全局预解析中，由于全局中没有参数的的概念，所以省去了第2步的找参数、第3步实参形参相统一这两处处理。GO全局上下文对象，它优于局部预解析AO局部上下文对象的创建与执行</em></p>
<p>&emsp;&emsp;例如下面的代码：</p>
<pre><code>  1  console.log(a) // undefined
  2  console.log(b) // Uncaught ReferenceError: b is not defined
  3  var a = 5
  4  console.log(a) // 5
  5  console.log(test) // undefined
  6  console.log(fn) // function fn () &#123;&#125;
  7  console.log(fn(3)) // 11
  8  var test = function () &#123;
  9     return 10
  10 &#125;
  11 function fn(x) &#123;
  12  console.log(a) // undefined
  13  var a = b = 8
  14  var c = 6
  15  return a + x
  16 &#125;
  17 console.log(a) // 5
  18 console.log(b) // 8
  19 console.log(c) // Uncaught ReferenceError: c is not defined
  20 console.log(test()) // 10
</code></pre>
<p>&emsp;&emsp;<strong>上面的代码在执行前的瞬间，会先进行全局预解析。过程如下：（这里只列举了执行上下文中的部分信息）</strong></p>
<p>&emsp;&emsp;(1) 进行全局预解析的第1步：创建全局上下文GO对象</p>
<pre><code>  GO: &#123;
  
  &#125;
</code></pre>
<p>&emsp;&emsp;(2) 进行全局预解析的第2步：找变量声明，将变量作为GO的属性名，值为undefined</p>
<pre><code>  GO: &#123;
    a: undefined,
    test: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(3) 进行全局预解析3步：在函数体里面找函数声明，作为GO的属性，值赋予函数体</p>
<pre><code>  GO: &#123;
    a: undefined,
    test: undefined
    fn: function fn () &#123;&#125;
  &#125;
</code></pre>
<p>&emsp;&emsp;<strong>全局预解析完成，代码开始执行，执行过程如下：</strong><br>&emsp;&emsp;执行第1行，输出a为undefined<br>&emsp;&emsp;执行第2行，因为全局上下文没有申明b变量，所以程序抛出异常：Uncaught ReferenceError: b is not defined<br>&emsp;&emsp;执行第3行，将全局上下文中a赋值为5</p>
<pre><code>  GO:&#123;
    a: 5,
    test: undefined
    fn: function fn () &#123;&#125;
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第4行，输出a为5<br>&emsp;&emsp;执行第5行，输出test为undefined<br>&emsp;&emsp;执行第6行，输出fn为function fn () {}</p>
<p>&emsp;&emsp;<strong>执行第7行，调用fn并传入参数3，在fn执行前瞬间，会进行局部预编译，过程如下：</strong></p>
<p>&emsp;&emsp;(1) 进行局部预解析的第1步： 创建对应的函数上下文AO对象</p>
<pre><code>  AO: &#123;
    
  &#125;
</code></pre>
<p>&emsp;&emsp;(2) 进行局部预解析的第2步：找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined</p>
<pre><code>  AO: &#123;
    x: undefined,
    a: undefined,
    c: undefined
  &#125;
</code></pre>
<p><em>&emsp;&emsp;[注] <u>在第13行’var a = b = 8’，这里隐式的申明了全局变量b，此时应该将变量b添加到GO对象中，</u>此时的GO对象为：</em></p>
<pre><code>  GO: &#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(3) 进行局部预解析第3步：将实参与形参统一</p>
<pre><code>  AO:&#123;
    x: 3,
    a: undefined,
    c: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(4) 对应fn函数，进行预解析第4步：在函数体里面找函数声明，作为AO的属性，值赋予函数体<br>&emsp;&emsp;fn函数内无函数申明，AO对象不变<br>&emsp;&emsp;<strong>fn函数执行前预解析完成，11-16行的<u>函数入栈执行！</u></strong><br>&emsp;&emsp;执行第12行，输出a为undefined（先在当前执行的函数上下文AO的作用域对象中查找变量a，若AO的作用域对象中没有，通过AO中的作用域链，再去全局上下文GO中去查找）<br>&emsp;&emsp;执行第13行，将变量b赋值为8，变量a赋值为8。其中变量b存在于全局上下文GO中，这里的a为当前执行的函数上下文AO中的a，此时的GO、AO对象为：</p>
<pre><code>  GO:&#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: 8
  &#125;
  AO:&#123;
      x: 3,
      a: 8,
      c:undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第14行，将AO中的c变量赋值为6，此时的AO为：</p>
<pre><code>  AO:&#123;
    x: 3,
    a: 8,
    c: 6
  &#125;
</code></pre>
<p>&emsp;&emsp;<strong>执行第15行，计算a+x的值为11，并返回函数调用的地方。所以第7行输出函数fn(3)的执行结果11。<u>函数执行完成，函数出栈，当前执行上下文AO对象被销毁。 </u></strong><br>&emsp;&emsp;执行第8行，将GO中test赋值为function () { return 10 }，此时的GO对象为：</p>
<pre><code>  GO: &#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: 8
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第17行，输出a为5<br>&emsp;&emsp;执行第18行，输出b为8<br>&emsp;&emsp;执行第19行，因为全局上下文没有申明c变量，所以程序抛出异常：Uncaught ReferenceError: c is not defined<br>&emsp;&emsp;执行第20行，<u>这里调用test()函数与上面调用fn(3)函数类似，执行前也会进行相应的局部预解析，然后执行函数，</u>这里输出函数返回的10<br>&emsp;&emsp;代码执行完成！</p>
<p><em>&emsp;&emsp;[注] 这里分析比较简单的一段代码的执行过程，这里在函数内部没有函数的申明，也没有异步处理。一般的，如果函数内部存在函数，在内部函数调用时也会进行对应的局部预处理以及入栈执行；如果代码内包含异步逻辑，会把异步逻辑放在异步队列里面进行相应的调度执行。</em><br><em>&emsp;&emsp;[注] 如果在某个作用域中使用了某变量，而该变量并未在对应的（静态）作用域中声明（在其它作用域中声明），该变量称为<u>自由变量。</u></em></p>
<h2 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h2><p>&emsp;&emsp;一个函数和对其周围状态（词法环境）的引用捆绑在一起，这样的组合就是闭包（closure）。闭包让你可以在一个内层函数中访问到其外层函数的作用域（即能够读取其他函数内部变量的函数）。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。<strong>函数就会形成闭包。</strong><u>闭包是由函数以及声明该函数的词法环境组合而成的。</u>该环境包含了这个闭包创建时作用域内的任何局部变量。</p>
<p>&emsp;&emsp;例如下面的代码：</p>
<pre><code>  function add(x) &#123;
    console.log(inner.__proto__)
    function inner(y) &#123;
        return x + y;
    &#125;
    return inner;
  &#125;
  console.log(add(3)(4))

  // 输出
  &#123;constructor: ƒ&#125;
  constructor: ƒ inner(y)
  arguments: null
  caller: null
  length: 1
  name: &quot;inner&quot;
  prototype: &#123;constructor: ƒ&#125;
  __proto__: ƒ ()
  [[FunctionLocation]]: scopes.html:14
  [[Scopes]]: Scopes[2]
  0: Closure (add) &#123;x: 3&#125;
  1: Global &#123;window: Window, self: Window, document: document, name: &quot;&quot;, location: Location, …&#125;
  __proto__: Object

  7
</code></pre>
<p>&emsp;&emsp;上面的代码中：add函数内部定义了inner函数，inner函数可以访问词法环境外部add函数作用域中变量，如这里的形参x。从打印的inner.prototype对象可以看出，在inner函数的作用域链的栈底为Global全局作用域，栈顶为inner函数所在的add函数的作用域，这里形成了Closure闭包。add(3)函数调用后返回的inner(y){ return x + y; }函数与inner函数的词法环境形成了闭包，inner函数中保留了对add函数内部变量x的应用，且此时x=3，所以在add(3)(4)继续调用inner函数时返回结果7。</p>
<p><em>&emsp;&emsp;[注] 这里是否形成闭包与内部的inner函数是否返回无关。</em></p>
<h2 id="4、this关键字"><a href="#4、this关键字" class="headerlink" title="4、this关键字"></a>4、this关键字</h2><p>&emsp;&emsp;在绝大多数情况下，<u>函数的调用方式决定了 this 的值（<strong>运行时绑定</strong>）。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同（<strong>与调用方式有关</strong>）。</u>ES5 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。ES2015 引入了箭头函数，箭头函数不提供自身的 this 绑定，此时this 的值将保持为闭合词法上下文的值。函数中this的取值为当前执行上下文（global、function 或 eval）的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。</p>
<p>&emsp;&emsp;① 在全局上下文中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。<br>&emsp;&emsp;② 在函数上下文中，this指向取决于函数被调用的方式：在非严格模式下，this的值不由调用者设置，this指向window。在严格模式下，this指向调用者，若执行前没有设置this的值，也没有作为对象的属性或方法而是直接调用，this为undefined。<br><em>&emsp;&emsp;[注] 可以通过call、apply方法修改this指向的环境。</em><br>&emsp;&emsp;③ 类上下文中，基类与派生类构造函数constructor()中this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象，所有非静态方法会被添加到this的原型中。在派生类中的构造函数没有初始的this绑定，在构造函数中调用super()才能生成一个this绑定。<u>注意的是，使用super对象时，super 调用父类的方法时，super 会绑定当前子类的 this。</u><br><em>&emsp;&emsp;[注] 静态方法不是this的属性，它们只是类自身的属性。派生类（子类）在super()前调用this会抛出异常，派生类不能在调用super前返回，除非没有构造函数或者构造函数返回了对象。</em></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript概述</title>
    <url>/2020/12/03/JavaScript%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型，单线程的脚本语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态页面信息，而是实时的内容更新，交互式的地图，2D/3D 动画，滚动播放的视频等更加丰富的内容，也能实现用户界面与服务器相关的交互</p>
<h2 id="1、语言特性"><a href="#1、语言特性" class="headerlink" title="1、语言特性"></a>1、语言特性</h2><p>&emsp;&emsp;JavaScript是一门动态的、弱类型、基于原型（prototype）的脚本语言。在JavaScript中“一切皆对象”，在这一方面，它比其他的面向对象的语言来得更为彻底。即使作为代码本身载体的函数（function），也是对象。</p>
<h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><h4 id="1-向页面添加JavaScript"><a href="#1-向页面添加JavaScript" class="headerlink" title="1) 向页面添加JavaScript"></a>1) 向页面添加JavaScript</h4><p>&emsp;&emsp;在body标签结束前插入以下script标签引入JavaScript， <u>JavaScript 是区分大小写的</u></p>
<pre><code>  // 方式1：内联JavaScript
  &lt;script&gt;
      // 在此编写JavaScript代码
  &lt;/script&gt;

  // 方式2：外部引入JavaScript
  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><em>&emsp;&emsp;[注] 在外部引入JS时，在必要的时候（防止加载阻塞页面渲染问题或对多个有依赖关系的脚本加载顺序有要求），我们需要加上async或defer修饰符（解决脚本阻塞问题的两种方式）。<u>浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。</u>当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，async 是最理想的选择；<u>defer 属性的脚本将按照在页面中出现的顺序加载，可保证脚本的加载顺序</u></em></p>
<h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2) 变量"></a>2) 变量</h4><p>&emsp;&emsp;变量是用来存储数值的，那么有一个重要的概念需要区分。变量不是数值本身，它们仅仅是一个用于存储数值的容器，JS中使用var、let、const来定义变量</p>
<p>&emsp;&emsp;构造变量名称（唯一标识符）的通用规则是：<br>&emsp;&emsp;名称可包含字母、数字、下划线和美元符号<br>&emsp;&emsp;名称必须以字母、$或_开头<br>&emsp;&emsp;名称对大小写敏感<br>&emsp;&emsp;保留关键字不能作为变量名称</p>
<pre><code>  var a;
  let b;
  onst C = 100; // 定义常量必须进行初始化，常量一般用大写英文命名
</code></pre>
<p>&emsp;&emsp;变量类型：<br>&emsp;&emsp;值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol<br>&emsp;&emsp;引用数据类型：对象(Object，JavaScript 对象是键值对的容器)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）</p>
<h4 id="3-语句与表达式"><a href="#3-语句与表达式" class="headerlink" title="3) 语句与表达式"></a>3) 语句与表达式</h4><p>&emsp;&emsp;<u>JavaScript区分表达式和语句</u><br>&emsp;&emsp;表达式是输出值的，并且可以写在任何需要一个值的地方，例如函数的参数等。一般来讲，表达式由变量、操作符和约束条件等以能求得有意义的数值（非undefined）为目的排列所得的组合<br>&emsp;&emsp;语句表示执行了一个动作，例如循环控制语句(for、while…)和分支判断语句(if)等。一个程序基本上就是一系列的语句的集合。在JavaScript中需要语句的地方，也可以写入一个表达式。但不能够在需要表达式的地方写入一个语句。我们常用分号分语句，使得可以在一行编写多条语句。<br>&emsp;&emsp;常用运算符：=、+、-、*、/、==、!=、&gt;、&lt;、&amp;&amp;、||、……<br>&emsp;&emsp;常用语句：</p>
<pre><code>  // 赋值语句    
  let a = 5, b = 8;
  
  // if条件判断语句
  if (condition1) &#123;
    // 当条件 1 为 true 时执行的代码
  &#125;
  else if (condition2) &#123;
    // 当条件 2 为 true 时执行的代码
  &#125;
  else &#123;
    // 当条件 1 和 条件 2 都不为 true 时执行的代码
  &#125;
  
  // switch分支语句
  switch (n) &#123;
    case 1:
      // 执行代码块 1
      break; // 阻止代码向下一个case执行，有时为了逻辑需要（如累加等），switch语句中不会使用此关键字
    case 2:
      // 执行代码块 2
      break;
    default:
    // 与 case 1 和 case 2 不同时执行的代码
  &#125;
  
  // for、while、do while循环语句（break 语句用于跳出循环，continue 用于跳过循环中的一个迭代）
  for (语句 1; 语句 2; 语句 3)
  &#123;
    // 语句2为真执行的代码块
  &#125;
  while (条件) &#123;
    // 条件为真执行的代码块
  &#125;
  do &#123;
    // 代码块会在条件被测试前执行，代码块至少被执行一次
  &#125; while (条件);
</code></pre>
<h4 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4) 字符串模板"></a>4) 字符串模板</h4><p>&emsp;&emsp;模板字符串使用反引号<u>(` `)</u> 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${ expression } ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。<u>特别的，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。</u>注意，在模版字符串内使用反引号（`）时，需要在它前面加转义符（），<strong>字符串模板可以嵌套使用。</strong></p>
<pre><code>  let a = 4;
  console.log(`我有一个苹果$&#123;a&#125;s，哈哈哈~`) // 我有一个苹果6s，哈哈哈~
  function upgradePhone(str, a)&#123; // [注] 函数的第一个参数是数组（模板中各个原生字符串）。其余的参数为模板中的变量
    return &#39;升级手机，&#39; + str[0] + (a + 2) + str[1];
  &#125;
  console.log(upgradePhone`我有一个苹果$&#123;a&#125;s，哈哈哈~`) // 升级手机，我有一个苹果6s，哈哈哈~
</code></pre>
<h4 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5) 解构赋值"></a>5) 解构赋值</h4><p>&emsp;&emsp;解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。使得对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法<br>&emsp;&emsp;特别的：<u>赋值语句周围的圆括号()在使用对象字面量无声明解构赋值时是必须的</u>，否则左边被认为是一个块而不是对象字面量。<u>并且()表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行</u></p>
<pre><code>  let a, b, C;
  [a, b = 0] = [10, 20, 30, 40, 50]; // a:10, b:20 [注] 为了防止取出一个值为undefined，可以在表达式左边预设默认值
  [a, b, ...C] = [10, 20, 30, 40, 50]; // a:10，b:20, C: [30, 40, 50]
  (&#123; a, b = 0&#125; = &#123; a: 10, b: 20 &#125;); // a: 10, b: 20
  (&#123;a, b, ...C&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;); // a: 10, b: 20, C: &#123;c: 30, d: 40&#125;
</code></pre>
<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h4><p>&emsp;&emsp;函数就是包裹在花括号中的代码块，使用关键字function进行定义。当调用该函数时，会执行函数内的代码，在调用函数时，可以向其传递参数。这些参数可以在函数中使用，多个参数用逗号（,）分割。变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。有时，我们会希望函数将值返回调用的地方。通过使用return语句就可以实现。在使用return语句时，函数会停止执行(无论后面是否还存在语句)，并返回指定的值。</p>
<p><em>&emsp;&emsp;[注] <u>函数有作用域的概念，在函数内部定义的变量，只能在函数内部访问它（闭包情况除外），此时该变量的作用域是局部的。特别的，如果给未申明的变量赋值，该变量会被自动配置为全局变量（配置为window的属性）。</u></em></p>
<pre><code>  function functionname(var1, var2, ...) &#123;
    // 代码
    // return value;
  &#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS(3)概述</title>
    <url>/2020/09/24/CSS-3-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>层叠样式表(Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>
<h2 id="1、文档流-CSS设计核心"><a href="#1、文档流-CSS设计核心" class="headerlink" title="1、文档流 - CSS设计核心"></a>1、文档流 - CSS设计核心</h2><p>&emsp;&emsp;文档流是文档中可显示对象在排列时所占用的位置。即将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素为文档流。</p>
<p>&emsp;&emsp;元素脱离文档流的原因：<br>&emsp;&emsp;(1) 浮动float<br>&emsp;&emsp;(2) 绝对定位（position: absolute/fixed）</p>
<p>&emsp;&emsp;元素脱离文档流的后果：<br>&emsp;&emsp;(1) 使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。（可结合BFC格式化上下文的特性，布局文本环绕图像的样式）<br>&emsp;&emsp;(2) 对于使用position：absolute脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它<br>&emsp;&emsp;(3) 元素脱离文本流后，父元素高度会塌陷，一般通过BFC的特性或者css clearfix属性（推荐使用伪元素清除浮动的方式）清除浮动</p>
<h2 id="2、CSS框模型"><a href="#2、CSS框模型" class="headerlink" title="2、CSS框模型"></a>2、CSS框模型</h2><p>&emsp;&emsp;框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。<br><img src="/images/css3/CSS%E6%A1%86%E6%A8%A1%E5%9E%8B.gif" alt="CSS框模型"><br>&emsp;&emsp;元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p>
<p>&emsp;&emsp;内边距、边框和外边距都是可选的，在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>&emsp;&emsp;内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。外边距可以是负值。</p>
<p>&emsp;&emsp;外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<p>&emsp;&emsp;[注] CSS框模型包含2种盒子：<br>&emsp;&emsp;(1) 标准盒模型（box-sizing：content-box），盒子的宽高只有内容的宽高<br>&emsp;&emsp;(2) IE盒模型（box-sizing：border-box），盒子的宽高=内容（content）+内边距（padding）+边框（border）的总宽高</p>
<h2 id="3、CSS基础"><a href="#3、CSS基础" class="headerlink" title="3、CSS基础"></a>3、CSS基础</h2><h4 id="1-选择器"><a href="#1-选择器" class="headerlink" title="(1) 选择器"></a>(1) 选择器</h4><table>
<thead>
<tr>
<th>选择器名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素选择器</td>
<td>通常选择某个 HTML 元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>允许以一种独立于文档元素的方式来指定样式，将类选择器的样式与元素关联，必须将元素class指定为一个对应的类名</td>
</tr>
<tr>
<td>ID选择器</td>
<td>允许以一种独立于文档元素的方式来指定样式，将ID选择器的样式与元素关联，必须将元素 id指定为一个对应的值</td>
</tr>
<tr>
<td>属性选择器</td>
<td>可以根据元素的属性及属性值来选择元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>可以选择作为某元素后代的元素</td>
</tr>
<tr>
<td>子元素选择器</td>
<td>只能选择作为某元素子元素的元素</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>可选择紧接在另一元素后的元素，且二者有相同父元素</td>
</tr>
<tr>
<td>伪类</td>
<td>用于向某些选择器添加特殊的效果</td>
</tr>
<tr>
<td>伪元素</td>
<td>用于向某些选择器设置特殊效果</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;[注] 选择器优先级：</em><br><em>&emsp;&emsp;&emsp; 1)不同选择器优先级：!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</em><br><em>&emsp;&emsp;&emsp; 2)不同一级别选择器优先级：同一级别中后写的会覆盖先写的样式；同一级别css引入方式不同，优先级不同：内联(行内)样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 导入样式(@import)</em></p>
<h4 id="2-样式"><a href="#2-样式" class="headerlink" title="(2) 样式"></a>(2) 样式</h4><p>&emsp;&emsp;HTML 的 style 属性，提供了一种改变所有 HTML 元素的样式的通用方法。<br>&emsp;&emsp;当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化。有以下三种方式来插入样式表：外部样式表、内部样式表、内联样式（后者优先级高于前者）。</p>
<p>&emsp;&emsp;1) 背景属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>背景设置简写属性</td>
</tr>
<tr>
<td>background-color</td>
<td>背景颜色</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图像（可设置多张图片，或者设置css3渐变效果）</td>
</tr>
<tr>
<td>background-repeat</td>
<td>背景图像是否及如何重复</td>
</tr>
<tr>
<td>background-position</td>
<td>背景图像的起始位置</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景图是否固定或者随着页面滚动</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;2) 文本属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>颜色</td>
</tr>
<tr>
<td>direction</td>
<td>文本方向</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>text-indent</td>
<td>缩进文本</td>
</tr>
<tr>
<td>text-align</td>
<td>水平对齐</td>
</tr>
<tr>
<td>word-spacing</td>
<td>字间隔</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>字母间隔</td>
</tr>
<tr>
<td>text-transform</td>
<td>字符转换，如大小写转换</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本装饰</td>
</tr>
<tr>
<td>white-space</td>
<td>处理空白字符</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;3) 字体属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>font</td>
<td>简写属性（HTML5已不支持此属性）</td>
</tr>
<tr>
<td>font-family</td>
<td>字体系列</td>
</tr>
<tr>
<td>font-size</td>
<td>字体尺寸</td>
</tr>
<tr>
<td>font-style</td>
<td>字体风格</td>
</tr>
<tr>
<td>font-variant</td>
<td>以小型大写字体或者正常字体显示文本</td>
</tr>
<tr>
<td>font-weight</td>
<td>字体粗细</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;4) 尺寸属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>height</td>
<td>元素的高度</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>max-height</td>
<td>元素的最大高度</td>
</tr>
<tr>
<td>max-width</td>
<td>元素的最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>元素的最小高度</td>
</tr>
<tr>
<td>min-width</td>
<td>元素的最小宽度</td>
</tr>
<tr>
<td>width</td>
<td>元素的宽度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;5) 显示属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clear</td>
<td>设置一个元素的侧面是否允许其他的浮动元素</td>
</tr>
<tr>
<td>cursor</td>
<td>规定当指向某元素之上时显示的指针类型</td>
</tr>
<tr>
<td>display</td>
<td>设置是否及如何显示元素</td>
</tr>
<tr>
<td>float</td>
<td>定义元素在哪个方向浮动</td>
</tr>
<tr>
<td>position</td>
<td>把元素放置到一个静态的、相对的、绝对的、或固定的位置中</td>
</tr>
<tr>
<td>visibility</td>
<td>设置元素是否可见或不可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;6) 链接属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>创建指向另一个文档的链接</td>
</tr>
<tr>
<td>name</td>
<td>创建文档内的书签</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;[注] 给链接设置样式时样注意合理的顺序：a:link、a:visited、a:hover、a:active</em></p>
<p>&emsp;&emsp;7) 列表属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>list-style</td>
<td>简写属性</td>
</tr>
<tr>
<td>list-style-image</td>
<td>列表项标志为图片</td>
</tr>
<tr>
<td>list-style-position</td>
<td>列表项标志的位置</td>
</tr>
<tr>
<td>list-style-type</td>
<td>列表项标志的类型</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;8) 表格属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>border-collapse</td>
<td>是否把表格边框合并为单一边框</td>
</tr>
<tr>
<td>border-spacing</td>
<td>分割单元格边框的距离</td>
</tr>
<tr>
<td>caption-side</td>
<td>表格标题的位置</td>
</tr>
<tr>
<td>empty-cells</td>
<td>是否显示表格中的空单元格</td>
</tr>
<tr>
<td>table-layout</td>
<td>设置显示单元、行和列的算法</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;9) 轮廓属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>outline</td>
<td>声明中设置所有的轮廓属性</td>
</tr>
<tr>
<td>outline-color</td>
<td>轮廓颜色</td>
</tr>
<tr>
<td>outline-style</td>
<td>轮廓样式</td>
</tr>
<tr>
<td>outline-width</td>
<td>轮廓宽度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;10) 框模型</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>padding</td>
<td>简写属性。作用是在一个声明中设置元素的所内边距属性</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>元素的下内边距</td>
</tr>
<tr>
<td>padding-left</td>
<td>元素的左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td>元素的右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td>元素的上内边距</td>
</tr>
<tr>
<td>border</td>
<td>简写属性，用于把针对四个边的属性设置在一个声明</td>
</tr>
<tr>
<td>border-style</td>
<td>用于设置元素所有边框的样式，或者单独地为各边设置边框样式</td>
</tr>
<tr>
<td>border-width</td>
<td>用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度</td>
</tr>
<tr>
<td>border-color</td>
<td>设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色</td>
</tr>
<tr>
<td>margin</td>
<td>简写属性。在一个声明中设置所有外边距属性</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>元素的下外边距</td>
</tr>
<tr>
<td>margin-left</td>
<td>元素的左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td>元素的右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td>元素的上外边距</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;11) 定位</p>
<p>&emsp;&emsp;CSS中三种定位机制：普通流、浮动与绝对定位。</p>
<p>&emsp;&emsp;① 在普通流中：<br>&emsp;&emsp;块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。<br>&emsp;&emsp;行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度，由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。</p>
<p>&emsp;&emsp;② 浮动与清除浮动：<br>&emsp;&emsp;浮动（float）的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。不论何种元素，浮动会生成一个块级框。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。文本会环绕在浮动元素周围但文本过少可能会导致父元素高度塌陷，一般清除父元素的浮动来实现文本环绕图像的样式。<br>&emsp;&emsp;清除浮动（clear）属性定义了元素的哪一侧不允许出现浮动元素，设置了 clear 属性的元素增加上外边距实现的，即在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下，从而达到清除浮动的目的。<br>&emsp;&emsp;利用BFC（块级格式化上下文）的特性（BFC区域不会与float box重叠），也可以达到清除浮动的目的。</p>
<p>&emsp;&emsp;③ 绝对定位：<br>&emsp;&emsp;设置为绝对定位（position: absolute/fixed）的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素绝对定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>display</td>
<td>改变元素生成框的类型</td>
</tr>
<tr>
<td>position</td>
<td>定位元素到静态的、相对的、绝对的、或固定的位置</td>
</tr>
<tr>
<td>top</td>
<td>定位元素的上外边距边界与其包含块上边界之间的偏移</td>
</tr>
<tr>
<td>right</td>
<td>定位元素右外边距边界与其包含块右边界之间的偏移</td>
</tr>
<tr>
<td>bottom</td>
<td>定义了定位元素下外边距边界与其包含块下边界之间的偏移</td>
</tr>
<tr>
<td>left</td>
<td>定义了定位元素左外边距边界与其包含块左边界之间的偏移</td>
</tr>
<tr>
<td>overflow</td>
<td>设置当元素的内容溢出其区域时发生的事情</td>
</tr>
<tr>
<td>clip</td>
<td>设置元素的形状。元素被剪入这个形状之中，然后显示出来</td>
</tr>
<tr>
<td>vertical-align</td>
<td>置元素的垂直对齐方式</td>
</tr>
<tr>
<td>z-index</td>
<td>设置元素的堆叠顺序</td>
</tr>
</tbody></table>
<h2 id="4、CSS进阶"><a href="#4、CSS进阶" class="headerlink" title="4、CSS进阶"></a>4、CSS进阶</h2><p>&emsp;&emsp;(1) 水平对齐<br>&emsp;&emsp;margin 属性：可通过将左和右外边距设置为 “auto”，来对齐块元素。把左和右外边距设置为 auto，规定的是均等地分配可用的外边距实现水平居中。<br>&emsp;&emsp;position属性：通过绝对定位使元素会被从正常流中删除，并且能够交叠元素进行水平居中布局。<br>&emsp;&emsp;float属性：通过浮动进行定位使元素水平居中布局。</p>
<p>&emsp;&emsp;(2) 图片滤镜（<u>注意浏览器兼容!!!</u>  -webkit-, -ms- 或 -moz- ）<br>&emsp;&emsp;filter 属性定义了元素(通常是img)的可视效果。常用函数：blur(px)、brightness(%)、contrast(%)、grayscale(%)、opacity(%)。</p>
<h2 id="5、CSS3新能力"><a href="#5、CSS3新能力" class="headerlink" title="5、CSS3新能力"></a>5、<u>CSS3新能力</u></h2><p>&emsp;&emsp;CSS3的新特征有很多，例如选择器的添加、圆角效果、图形化边界、块阴影与文字阴影、使用RGBA实现透明效果、渐变效果、使用@font-face实现定制字体、多背景图、文字或图像的效果与变形处理（旋转、缩放、倾斜、移动）、多栏布局、媒体查询等。</p>
<p>&emsp;&emsp;1) 选择器</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>用法示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=”https”]</td>
<td>选择每一个src属性的值以”https”开头的元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=”.pdf”]</td>
<td>选择每一个src属性的值以”.pdf”结尾的元素</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=”abc”]</td>
<td>选择每一个src属性的值包含子字符串”abc”的元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
</tr>
<tr>
<td>nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
</tr>
<tr>
<td><u>:target</u></td>
<td>#news:target</td>
<td>选择当前激活的#news元素（包含该锚名称的点击的URL）</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;2) 边框(圆角)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>border-image</td>
<td>设置所有边框图像的速记属性</td>
</tr>
<tr>
<td>box-shadow</td>
<td>附加一个或多个下拉框的阴影（可设置内/外阴影效果）</td>
</tr>
<tr>
<td>border-radius</td>
<td>用于设置所有四个边框圆角半径属性</td>
</tr>
<tr>
<td>border-top-left-radius</td>
<td>定义了左上角的弧度</td>
</tr>
<tr>
<td>border-top-right-radius</td>
<td>定义了右上角的弧度</td>
</tr>
<tr>
<td>border-bottom-right-radius</td>
<td>定义了右下角的弧度</td>
</tr>
<tr>
<td>border-bottom-left-radius</td>
<td>定义了左下角的弧度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;3) 背景</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background-clip</td>
<td>规定背景的绘制区域</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;4) 渐变<br>&emsp;&emsp;CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。（相关属性background-image）<br>&emsp;&emsp;CSS3 定义了两种类型的渐变（gradients）：<br>&emsp;&emsp;① 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</p>
<pre><code>  background-image: linear-gradient(direction, color-stop1, color-stop2, ...);
  background-image: linear-gradient(angle, color-stop1, color-stop2)
</code></pre>
<p>&emsp;&emsp;② 径向渐变（Radial Gradients）- 由它们的中心定义</p>
<pre><code>  background-image: radial-gradient(shape size at position, start-color, ..., last-color)
</code></pre>
<p>&emsp;&emsp;<u>利用repeating-linear-gradient函数可以实现线形重复渐变效果定义：</u></p>
<pre><code>  repeating-linear-gradient([ &lt;angle&gt; | to &lt;side-or-corner&gt; ,] ? &lt;color-stop&gt; [, &lt;color-stop&gt;]+)
</code></pre>
<p>&emsp;&emsp;5) 文本效果（文本字体可使用css3 @font-face属性自定义）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情</td>
</tr>
<tr>
<td>text-shadow</td>
<td>向文本添加阴影</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<em>[注1] 单行文本超出隐藏</em></p>
<pre><code>  .box &#123; // 有一定宽度的包含元素
    white-space: nowrap; // 如何处理包含元素内的空白：文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止
    text-overflow: ellipsis; // 文本溢出包含元素发生事情：显示省略符号来代表被修剪的文本
    overflow: hidden; // 内容溢出包含元素发生的事情：内容修剪且不可见
  &#125;
</code></pre>
<p>&emsp;&emsp;<em>[注2]  多行文本超出隐藏（适用于WebKit浏览器及移动端，有兼容问题）</em></p>
<p>&emsp;&emsp;<em>原理：利用了css弹性盒子模型flex-box，可以理解为flex弹性盒子旧的规则，有兼容性问题。在不同的浏览器中申明：display: -moz-box / -webkit-box / box。有box-orient（子元素的排列方向，有horizontal、vertical等取值）, box-direction（子元素的排列顺序，取值有normal、reverse、inherit）, box-align（垂直方向上的空间利用，即对齐方式，有start、end、center等取值）, box-pack（水平方向上的空间利用，即对齐方式，有start、end、center等取值）, box-lines（子元素是可以换行显示，取值有single、multiple）属性来设置子元素的排列方式。再结合-webkit-line-clamp属性（块元素显示的文本的行数，不规范属性，未在css规范草案中）等属性来实现多行显示省略号</em></p>
<pre><code>  .box &#123; 
    display: -webkit-box; // 布局方式：flex-box弹性盒子
    -webkit-box-orient: vertical; // 盒子内子元素排列方向：子元素纵向排列
    -webkit-line-clamp: 3; // css不规范属性-webkit-line-clamp：块元素显示的文本的行数为3 （有兼容问题）
    text-overflow: ellipsis; // 文本溢出包含元素发生事情：显示省略符号来代表被修剪的文本
    overflow: hidden; // 内容溢出包含元素发生的事情：内容修剪且不可见
  &#125;
</code></pre>
<p>&emsp;&emsp;<em>[注3] 多行文本超出隐藏（跨浏览器兼容方案）</em></p>
<p>&emsp;&emsp;<em>父元素使用相对高度，高度是文本行高的相应倍数来显示相应行数的文本，使用对位来放置 ‘…’ 的位置来达到超出隐藏的要求</em></p>
<p>&emsp;&emsp;6) 2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你改变被转换元素的位置</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;7) 过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript来完成</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;8) 动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>&emsp;&emsp;您可以改变任意多的样式任意多的次数。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<pre><code>  @keyframes name
  &#123;
    0%   &#123; // 状态1 &#125;
    ...
    xx%  &#123; // 状态x &#125;
    ...
    100% &#123; // 状态n &#125;
  &#125;
  // 自定义动画的使用
  animation: name duration timing-function delay iteration-count direction;

  // timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)
  // iteration-count的取值: n(次数)、infinite
  // animation-direction的取值: normal、alternate
</code></pre>
<br/>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定 @keyframes 动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;10) 多列布局  （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column-count</td>
<td>指定元素应该被分割的列数</td>
</tr>
<tr>
<td>column-gap</td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td>column-rule</td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td>column-rule-color</td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td>column-rule-style</td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td>column-rule-width</td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td>column-span</td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td>column-width</td>
<td>指定列的宽度</td>
</tr>
<tr>
<td>columns</td>
<td>column-width 与 column-count 的简写属性</td>
</tr>
</tbody></table>
<h2 id="6、其他CSS属性"><a href="#6、其他CSS属性" class="headerlink" title="6、其他CSS属性"></a>6、其他CSS属性</h2><p>&emsp;&emsp;(1) mask（通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域）<br>&emsp;&emsp;(2) clip-path（使用裁剪方式创建元素的可显示区域，结合transform、transition能作出惊艳的动画效果）<br>&emsp;&emsp;(3) offset （CSS快速定义元素沿相关路径运动）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局类型（Display、Flex、Grid）</title>
    <url>/2020/09/27/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/</url>
    <content><![CDATA[<p>display属性规定元素应该生成的框的类型。display 属性可以设置元素的内部和外部显示类型 display types。元素的外部显示类型 outer display types 将决定该元素在流式布局中的表现（块级或内联元素）；元素的内部显示类型 inner display types 可以控制其子元素的布局（如 flow layout，grid 或 flex）。</p>
<p>display 属性使用关键字取值来指定，关键字取值被分为六类：</p>
<pre><code>  &lt;display-outside&gt; = block | inline | run-in
  &lt;display-inside&gt; = flow | flow-root | table | flex | grid | ruby
  &lt;display-listitem&gt; = list-item
  &lt;display-internal&gt; = table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container
  &lt;display-box&gt; = contents | none
  &lt;display-legacy&gt; = inline-block | inline-list-item | inline-table | inline-flex | inline-grid
</code></pre>
<h2 id="1、display-outside类型"><a href="#1、display-outside类型" class="headerlink" title="1、display-outside类型"></a>1、display-outside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的外部显示类型，实际上就是其在流式布局中的角色（即在流式布局中的表现）。<br>&emsp;&emsp;block：此元素将显示为块级元素，此元素前后会带有换行符<br>&emsp;&emsp;inline：默认值，此元素会被显示为内联元素，元素前后没有换行符<br>&emsp;&emsp;run-in：此元素会根据上下文作为块级元素或内联元素显示</p>
<p><em>&emsp;&emsp;[注]如果 run-in box 包含 block box，那么这个 run-in box 也成为 block box；如果紧跟在 run-in box 之后的兄弟节点是 block box，那么这个 run-in box 就会做为此 block box 里的 inline box（run-in box 不能进入已经一个已经以 run-in box 开头的块内，也不能进入本身就是 display:run-in的块内）；否则，run-in box 都将成为 block box</em></p>
<h2 id="2、display-inside类型"><a href="#2、display-inside类型" class="headerlink" title="2、display-inside类型"></a>2、display-inside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的内部显示类型，它们定义了该元素内部内容的布局方式。<br>&emsp;&emsp;flow：元素使用流布局（块和内联布局）布局其内容<br><em>&emsp;&emsp;[注] 如果其外部显示类型为inline或run-in，并且它参与了块或内联格式设置上下文，则它将生成一个内联框。否则，它将生成一个块容器框</em><br>&emsp;&emsp;flow-root：该元素生成一个块元素框，该框将建立一个新的块格式化上下文，定义格式化根所在的位置<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 table ），表格前后带有换行符<br>&emsp;&emsp;flex：元素的行为类似于block元素，并根据flexbox模型布置其内容<br>&emsp;&emsp;grid: 元素的行为类似于块元素，并根据网格模型布置其内容<br>&emsp;&emsp;ruby: 元素的行为类似于内联元素，并根据ruby格式化模型布置其内容。它的行为类似于相应的HTML ruby元素</p>
<h4 id="emsp-emsp-1-Flex布局"><a href="#emsp-emsp-1-Flex布局" class="headerlink" title="&emsp;&emsp;1) Flex布局"></a>&emsp;&emsp;1) Flex布局</h4><p>&emsp;&emsp;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”，Flex 容器有主轴与交叉轴两个方向。<br><img src="/images/css3/Flex%E5%AE%B9%E5%99%A8.png" alt="Flex容器"></p>
<p>&emsp;&emsp;<strong>(1) Flex容器的属性：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</strong></p>
<p>&emsp;&emsp;① flex-direction属性决定主轴的方向（即项目的排列方向）</p>
<pre><code>  flex-direction: row | row-reverse | column | column-reverse;
</code></pre>
<p><img src="/images/css3/flex-direction%E5%B1%9E%E6%80%A7.png" alt="flex-direction属性"></p>
<p>&emsp;&emsp;row（默认值）：主轴为水平方向，起点在左端<br>&emsp;&emsp;row-reverse：主轴为水平方向，起点在右端<br>&emsp;&emsp;column：主轴为垂直方向，起点在上沿<br>&emsp;&emsp;column-reverse：主轴为垂直方向，起点在下沿</p>
<p>&emsp;&emsp;② flex-warp属性决定项目排列超过容器宽度时是否换行</p>
<pre><code>    flex-wrap: nowrap | wrap | wrap-reverse;
</code></pre>
<p><img src="/images/css3/flex-warp%E5%B1%9E%E6%80%A7.png" alt="flex-warp属性"></p>
<p>&emsp;&emsp;nowrap(默认)：不换行<br>&emsp;&emsp;wrap：换行，首行在上方<br>&emsp;&emsp;wrap-reserve：换行，首行在下方</p>
<p>&emsp;&emsp;③ flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>
<pre><code>    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;
</code></pre>
<p>&emsp;&emsp;④ justify-content属性定义了项目在主轴上的对齐方式</p>
<pre><code>    justify-content: flex-start | flex-end | center | space-between | space-around;
</code></pre>
<p><img src="/images/css3/justify-content%E5%B1%9E%E6%80%A7.png" alt="justify-content属性"></p>
<p>&emsp;&emsp;flex-start（默认值）：左对齐<br>&emsp;&emsp;flex-end：右对齐<br>&emsp;&emsp;center： 居中<br>&emsp;&emsp;space-between：两端对齐，项目之间的间隔都相等<br>&emsp;&emsp;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</p>
<p>&emsp;&emsp;⑤ align-items属性定义项目在交叉轴上如何对齐</p>
<pre><code>    align-items: flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p><img src="/images/css3/align-items%E5%B1%9E%E6%80%A7.png" alt="align-items属性"></p>
<p>&emsp;&emsp;flex-start：交叉轴的起点对齐<br>&emsp;&emsp;flex-end：交叉轴的终点对齐<br>&emsp;&emsp;center：交叉轴的中点对齐<br>&emsp;&emsp;baseline: 项目的第一行文字的基线对齐<br>&emsp;&emsp;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</p>
<p>&emsp;&emsp;⑥ align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>
<pre><code>    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
</code></pre>
<p>&emsp;&emsp;flex-start：与交叉轴的起点对齐<br>&emsp;&emsp;flex-end：与交叉轴的终点对齐<br>&emsp;&emsp;center：与交叉轴的中点对齐<br>&emsp;&emsp;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>&emsp;&emsp;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍<br>&emsp;&emsp;stretch（默认值）：轴线占满整个交叉轴</p>
<p>&emsp;&emsp;<strong>(2)Flex项目的属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self</strong></p>
<p>&emsp;&emsp;① order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<pre><code>  order: &lt;integer&gt;;
</code></pre>
<p>&emsp;&emsp;② flex-grow属性定义项目的放大比例（整体布局存在剩余空间），默认为0，即如果存在剩余空间，也不放大</p>
<pre><code>  flex-grow: &lt;number&gt;; /* default 0 */
</code></pre>
<p>&emsp;&emsp;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>&emsp;&emsp;③ flex-shrink属性定义了项目的缩小比例（整体布局空间不足），默认为1，即如果空间不足，该项目将缩小</p>
<pre><code>  flex-shrink: &lt;number&gt;; /* default 1 */
</code></pre>
<p>&emsp;&emsp;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>&emsp;&emsp;④ flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小</p>
<pre><code>  flex-basis: &lt;length&gt; | auto; /* default auto */
</code></pre>
<p>&emsp;&emsp;可设与width或height属性一样的值（比如200px，则项目将占据固定空间）。</p>
<p>&emsp;&emsp;⑤ flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选</p>
<pre><code>  flex: none | [ &lt;flex-grow&gt; || &lt;flex-shrink&gt;? || &lt;flex-basis&gt;? ]
</code></pre>
<p>&emsp;&emsp;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>&emsp;&emsp;⑥ align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
<pre><code>  align-self: auto | flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p>&emsp;&emsp;该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h4 id="emsp-emsp-2-Grid布局"><a href="#emsp-emsp-2-Grid布局" class="headerlink" title="&emsp;&emsp;2) Grid布局"></a>&emsp;&emsp;2) Grid布局</h4><p>&emsp;&emsp;将网页划分成一个个网格，可以任意组合不同的网格。Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可看作是二维布局。Grid 布局远比 Flex 布局强大。同样的，grid布局中也有容器与项目的概念。<br>&emsp;&emsp;grid布局将容器分为行和列，行和列的交叉区域称为单元格<strong>（区域）</strong>。正常情况下，n行和m列会产生n x m个单元格（可能有跨行与跨列等布局状态）。<br>&emsp;&emsp;容器中划分网格的线，称为”网格线”。水平网格线划分出行，垂直网格线划分出列。正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线。<br><img src="/images/css3/Grid%E5%AE%B9%E5%99%A8.png" alt="Grid容器"></p>
<p>&emsp;&emsp;<strong>(1) Grid容器的属性：</strong><br>&emsp;&emsp;grid-template-columns、grid-template-rows（容器划分行和列）<br>&emsp;&emsp;grid-row-gap、grid-columns-gap、grid-gap（行与行、列于列的间距）<br>&emsp;&emsp;grid-template-areas（网格布局给区域命名）<br>&emsp;&emsp;grid-auto-flow（容器中放置项目顺序设置，如先行后列，是否紧密填满）<br>&emsp;&emsp;justify-items、align-items、place-items（单元格内元素水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-content、align-content、place-content（容器中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;grid-auto-columns、grid-auto-rows（超出容器项目的行、列设置）<br>&emsp;&emsp;grid-template、grid（简写属性）</p>
<p>&emsp;&emsp;① grid-template-columns、grid-template-rows属性<br>&emsp;&emsp;容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。下面以列宽设置为例，行高设置同理。</p>
<pre><code>  .container &#123;
    display: grid;
    grid-template-rows: [R1]100px [R2]100px [R3]100px[R4]; // 设置网格线名称（网格线有多个名称，默认为1、2、3...)）
    // 1、px设置行宽
    grid-template-columns: [C1]100px [C2]100px [C3]100px[C4]; // 设置网格线名称
   // 2、百分比设置行宽
    grid-template-columns: 33.33% 33.33% 33.33%;
    // 3、repeat()重复行宽设置，也可重复某一模式
    grid-template-columns: repeat(3, 33.33%);
    // 4、auto-fill关键字自动填充列
    grid-template-columns: repeat(auto-fill, 100px);
    // 5、fr关键字按比例划分列宽
    grid-template-columns: 150px 1fr 2fr;
    // 6、minmax()函数设置某一列宽范围
    grid-template-columns: 1fr 1fr minmax(100px, 1fr);
    // 7、auto关键字列宽自适应
    grid-template-columns: 100px auto 100px;
  &#125;
</code></pre>
<p><img src="/images/css3/grid-template%E5%B1%9E%E6%80%A7.png" alt="grid-template属性"></p>
<p>&emsp;&emsp;② grid-row-gap、grid-columns-gap、grid-gap属性<br>&emsp;&emsp;grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。grid-gap为行列间距两属性的简写属性。</p>
<pre><code>  .container &#123;
    grid-row-gap: 20px;
    grid-column-gap: 20px;
 &#125;
</code></pre>
<p><img src="/images/css3/grid-gap%E5%B1%9E%E6%80%A7.png" alt="grid-gap属性"></p>
<p>&emsp;&emsp;③ grid-template-areas属性<br>&emsp;&emsp;网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。<br><em>&emsp;&emsp;[注] 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</em></p>
<pre><code>  grid-template-areas: &#39;A B C&#39; &#39;D . F&#39; &#39;G H I&#39;;
</code></pre>
<p><img src="/images/css3/grid-template-areas%E5%B1%9E%E6%80%A7.png" alt="grid-template-areas属性"></p>
<p>&emsp;&emsp;④ grid-auto-flow属性<br>&emsp;&emsp;划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。</p>
<p><img src="/images/css3/grid-auto-flow%E5%B1%9E%E6%80%A7.png" alt="grid-auto-flow属性"></p>
<p>&emsp;&emsp;⑤ justify-items 、align-items、place-items 属性（设置单元格内容的位置）<br>&emsp;&emsp;justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。place-items属性是align-items属性和justify-items属性的合并简写形式。</p>
<pre><code>  .container &#123; 
    justify-items: start | end | center | stretch;
    align-items: start | end | center | stretch;
  &#125;
</code></pre>
<p>&emsp;&emsp;start：对齐单元格的起始边缘<br>&emsp;&emsp;end：对齐单元格的结束边缘<br>&emsp;&emsp;center：单元格内部居中<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p>&emsp;&emsp;⑥ justify-content 、align-content、place-content属性（设置整个内容区域在容器里面的的位置）<br>&emsp;&emsp;justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。place-content属性是align-content属性和justify-content属性的合并简写形式。</p>
<pre><code>  .container &#123;
    justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
    align-content: start | end | center | stretch | space-around | space-between | space-evenly;
  &#125;
</code></pre>
<p>&emsp;&emsp;start - 对齐容器的起始边框<br>&emsp;&emsp;end - 对齐容器的结束边框<br>&emsp;&emsp;center - 容器内部居中<br>&emsp;&emsp;stretch - 项目大小没有指定时，拉伸占据整个网格容器<br>&emsp;&emsp;space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍<br>&emsp;&emsp;space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔<br>&emsp;&emsp;space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p>
<p>&emsp;&emsp;⑦ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;当项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。grid-auto-columns属性和grid-auto-rows属性用来设置浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>&emsp;&emsp;⑧ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。<br>&emsp;&emsp;grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<p>&emsp;&emsp;<strong>(2) Grid项目的属性：</strong><br>&emsp;&emsp;grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column、grid-row（设置项目位置简写属性）<br>&emsp;&emsp;grid-area（指定项目放置的区域）<br>&emsp;&emsp;justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）</p>
<p>&emsp;&emsp;① grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column-start属性：左边框所在的垂直网格线<br>&emsp;&emsp;grid-column-end属性：右边框所在的垂直网格线<br>&emsp;&emsp;grid-row-start属性：上边框所在的水平网格线<br>&emsp;&emsp;grid-row-end属性：下边框所在的水平网格线</p>
<pre><code>  .item_1&#123;
    grid-column-start: 2;
    grid-row-start: 2;
    grid-column-end: 3;
    grid-row-end: 3;
  &#125;
</code></pre>
<p><img src="/images/css3/Grid%E9%A1%B9%E7%9B%AE%E4%BD%8D%E7%BD%AE.png" alt="Grid项目位置"></p>
<p><em>&emsp;&emsp;[注] 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 如: grid-column-start:  span 2; 必要的时候，可使用z-index设置项目重叠顺序</em></p>
<p>&emsp;&emsp;② grid-column、grid-row属性<br>&emsp;&emsp;grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的简写形式，属性值取值用用’/‘分割</p>
<p>&emsp;&emsp;③ grid-area属性<br>&emsp;&emsp;grid-area属性指定项目放在哪一个区域</p>
<pre><code>  .item-1 &#123;
    grid-area: &#39;I&#39;; // I是grid-template-areas属性指定的区域
  &#125;
</code></pre>
<p><img src="/images/css3/grid-area%E5%B1%9E%E6%80%A7.png" alt="grid-area属性"></p>
<p><em>&emsp;&emsp;[注] grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的简写形式来指定项目位置。形如：grid-area: row-start / column-start / row-end / column-end; 属性值间取值用’/‘分割，上图的设置相当于：grid-area:  2 / 2 / 3 / 3;</em></p>
<p>&emsp;&emsp;④ justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目<br>&emsp;&emsp;align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目</p>
<pre><code>  .item &#123;
    justify-self: start | end | center | stretch;
    align-self: start | end | center | stretch;
  &#125;
</code></pre>
<p>&emsp;&emsp;start：对齐单元格的起始边缘。<br>&emsp;&emsp;end：对齐单元格的结束边缘。<br>&emsp;&emsp;center：单元格内部居中。<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p><em>&emsp;&emsp;[注] g place-self属性是align-self属性和justify-self属性的简写形式。当省略第二个值时，place会默认这两个属性值相等</em></p>
<h2 id="3、display-listitem类型"><a href="#3、display-listitem类型" class="headerlink" title="3、display-listitem类型"></a>3、display-listitem类型</h2><p>&emsp;&emsp;将这个元素的外部显示类型变为 block 盒子，并将内部显示类型变为多个 list-item inline盒子。<br>&emsp;&emsp;list-item：使元素的行为类似于列表项。可以与list-style-type和list-style-position一起使用，也可以与任何display-outside关键字和flow或flow-root display-inside关键字组合</p>
<h2 id="4、display-internal类型"><a href="#4、display-internal类型" class="headerlink" title="4、display-internal类型"></a>4、display-internal类型</h2><p>&emsp;&emsp;有些布局模型（如 table 和 ruby）有着复杂的内部结构，因此它们的子元素可能扮演着不同的角色。这一类关键字就是用来定义这些“内部”显示类型，并且只有在这些特定的布局模型中才有意义。<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 table），表格前后带有换行符<br>&emsp;&emsp;table-row-group：这些元素的行为类似于tbody HTML元素<br>&emsp;&emsp;table-header-group：这些元素的行为类似于thead HTML元素<br>&emsp;&emsp;table-footer-group：这些元素的行为类似于tfoot HTML元素<br>&emsp;&emsp;table-row：这些元素的行为类似于tr HTML元素<br>&emsp;&emsp;table-cell：这些元素的行为类似于td HTML元素<br>&emsp;&emsp;table-column-group：这些元素的行为类似于colgroup HTML元素<br>&emsp;&emsp;table-column：这些元素的行为类似于col HTML元素<br>&emsp;&emsp;table-caption：这些元素的行为类似于caption HTML元素<br>&emsp;&emsp;ruby-base：这些元素的行为类似于rb HTML元素<br>&emsp;&emsp;ruby-text：这些元素的行为类似于rt HTML元素<br>&emsp;&emsp;ruby-base-container：这些元素的行为类似于rbc生成为匿名框的HTML元素<br>&emsp;&emsp;ruby-text-container：这些元素的行为类似于rtc HTML元素</p>
<h2 id="5、display-inside类型"><a href="#5、display-inside类型" class="headerlink" title="5、display-inside类型"></a>5、display-inside类型</h2><p>&emsp;&emsp;这些值决定元素是否使用盒模型。<br>&emsp;&emsp;contents：这些元素本身不会产生特定的框。它们被伪框和子框替换<br>&emsp;&emsp;none：此元素不会被显示</p>
<h2 id="6、display-legacy类型"><a href="#6、display-legacy类型" class="headerlink" title="6、display-legacy类型"></a>6、display-legacy类型</h2><p>&emsp;&emsp;CSS 2 对于 display 属性使用单关键字语法，对于相同布局模式的 block 级和 inline 级变体需要使用单独的关键字。<br>&emsp;&emsp;inline-block：行内块元素，等同于inline flow-root<br>&emsp;&emsp;inline-table：此元素会作为内联表格来显示（类似 table），表格前后没有换行符，等同于inline table<br>&emsp;&emsp;<strong>inline-flex：元素的行为类似于内联元素，并根据flexbox模型布置其内容，等同于inline flex</strong><br>&emsp;&emsp;<strong>inline-grid：元素的行为类似于内联元素，并根据网格模型布置其内容，等同于inline grid</strong></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JS原型（prototype）链与继承（Class）</title>
    <url>/2020/12/23/JS%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Class%EF%BC%89/</url>
    <content><![CDATA[<p>在JavaScript中，每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>&emsp;&emsp;对象：对象是一个包含相关数据和方法的集合，通常由一些变量和函数组成，我们称之为对象里面的属性和方法。对象成员的值可以是任意的，例如Number，String，Function，null， undefined等。<br><em>&emsp;&emsp;[注] 可以使用点表示法或者括号表示法访问对象的成员（对象做了字符串到值的映射，而数组做的是数字到值的映射）。其中，括号表示法一个特别的地方是不仅可以动态的去设置对象成员的值，还可以动态的设置成员的名字。可以用一个对象来做另一个对象成员的值，这样，实际上创建了一个子命名空间，可以链式的使用点表示法或括号表示法去访问其中的成员变量。</em></p>
<p>&emsp;&emsp;<u>面向对象的JavaScript</u>（OOJS）：面向对象编程（OOP）的基本思想为，在程序里，我们通过使用对象去构建现实世界的模型，把原本很难（或不可）能被使用的功能，简单化并提供出来，以供访问。对象可以包含相关的数据和代码，去描述模型以及模型具有的行为和功能。对象包（命名空间）存储（封装）着对象的数据与方法，使数据的组织和访问变得更容易了；对象也常用作数据存储体，用于在网络上运输数据，十分便捷。</p>
<p>&emsp;&emsp;<u>构造函数创建对象</u>：JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。关键字 new 跟着一个含参构造函数，便能创建一个想要的对象（<u>对象的原型指向构建函数</u>）。其中，这个构建函数是 JavaScript 版本的类（ES6已提供class关键字的语法糖定义构建函数）。</p>
<p><em>&emsp;&emsp;[注] 其他创建对象的方式：</em><br><em>&emsp;&emsp;① 字面量定义对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;② Object()构造函数，即使用new Object()创建对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;③ Object.create()方法，允许您基于现有对象创建新的对象。（对象的原型指向创建时指定的对象）</em></p>
<h2 id="1、原型（链）"><a href="#1、原型（链）" class="headerlink" title="1、原型（链）"></a>1、原型（链）</h2><p>&emsp;&emsp;JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层，以此类推。这种关系常被称为原型链，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。<br>&emsp;&emsp;准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。</p>
<p><em>&emsp;&emsp;<strong>[注] 与传统OOP的区别：在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</strong></em><br><em>&emsp;&emsp;[注] 对象原型（可以通过Object.getPrototypeOf(obj)或者浏览器提供的__proto__属性获得）与构造函数的prototype属性是有区别的：前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Bool())和Bool.prototype指向着同一个对象。<u>特别的，没有官方的方法用于直接访问一个对象的原型——原型链中的“连接”被定义在一个内部属性中，</u>在 JavaScript 语言标准中用 [[prototype]] 表示，大多数现代浏览器还是提供了一个名为 __proto__ 属性，其包含了对象的原型。</em></p>
<p>&emsp;&emsp;(1) prototype属性：继承成员被定义的地方<br>&emsp;&emsp;继承的属性和方法是定义在 prototype 属性之上的（可以称之为子命名空间），prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。<br><em>&emsp;&emsp;[注] Object.create()可以指定一个对象作为原型对象创建一个实例对象。</em></p>
<p>&emsp;&emsp;(2) constructor属性：指向了用于构造此实例对象的构造函数<br>&emsp;&emsp;每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。<br>&emsp;&emsp;在某些情况下，没有原始构造器的引用，想要构造实例可以通过已有实例的constructor属性指向的构造函数来完成。即可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），只需在前面添加 new 关键字（let person2 = new person1.constructor()），便能将此函数作为构造器使用，从而调用这个构造器创建另一个对象实例。</p>
<p><em>&emsp;&emsp;[注] 构建函数前new关键字做了什么？</em><br><em>&emsp;&emsp;① 创建一个新对象</em><br><em>&emsp;&emsp;② 将新对象的__proto__属性指向了构建函数对象prototype对象</em><br><em>&emsp;&emsp;③ 将构建函数的this修正为指向新对象，执行构造函数中的代码，即为这个新对象添加对应属性</em><br><em>&emsp;&emsp;④ 返回新对象</em></p>
<pre><code>  var obj = &#123;&#125;;
  obj.__proto__ = Base.prototype;
  Base.call(obj);
</code></pre>
<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><p>&emsp;&emsp;<strong>JavaScript基于原型链继承（prototypal inheritance）</strong></p>
<p>&emsp;&emsp;如何实现继承：（这里以Teacher构造函数继承于Person构造函数的例子来说明）<br>&emsp;&emsp;(1) 定义构造器（构造函数），这里定义构造函数Person。</p>
<pre><code>  function Person(name, age, gender, interests) &#123;
    this.name =name;
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  &#125;;
  Person.prototype.greeting = function() &#123;
    console.log(`hello, I am $&#123;name&#125;!`)
  &#125;;
</code></pre>
<p>&emsp;&emsp;(2) 创建继承于Person构造函数的Teacher构造函数，并为Teacher 构造函数添加特有的subject（所授学科科目）属性。</p>
<pre><code>  function Teacher(name, age, gender, interests, subject) &#123;
    // 创建一个新的对象实例时同时指派其继承的属性（修正this指向Teacher()函数）
    Person.call(this, name, age, gender, interests);
    this.subject = subject;
    
    // 利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，从而继承其属性与方法
    Teacher.prototype = Object.create(Person.prototype);
    
    // 修正Teacher构造器指向，使之与Teacher关联(修正前指向Person)
    Teacher.prototype.constructor = Teacher;
  &#125;
</code></pre>
<p><em>&emsp;&emsp;[注] 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。其中Person()函数是Person.prototype的构造函数，即Person===Person.prototype.constructor。任何您想要被继承的方法都应该定义在构造函数的prototype对象里，并且永远使用父类的prototype来创造子类的prototype，这样才不会打乱类继承结构。</em></p>
<p>&emsp;&emsp;(3) Teacher构造函数添加新的greeting成员函数</p>
<pre><code>  Teacher.prototype.greeting = function()&#123;
    console.log(`hello, I am a teather, I teath $&#123;this.subject&#125;`)
  &#125;
</code></pre>
<p>&emsp;&emsp;(4) 生成对应的teacher实例</p>
<pre><code>  let t = new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath englis
</code></pre>
<p>&emsp;&emsp;所有代码：</p>
<pre><code>  function Person(name, age, gender, interests) &#123;    
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  &#125;;
  Person.prototype.greeting = function () &#123;
    console.log(`hello, I am $&#123;name&#125;!`);
  &#125;;
  function Teacher(name, age, gender, interests, subject) &#123;
    // 创建一个新的对象实例时同时指派其继承的所有属性（修正this指向Teacher()函数）
    Person.call(this, name, age, gender, interests);
    this.subject = subject;
    // Teacher.prototype现在会继承Person.prototype的所有属性和方法
    Teacher.prototype = Object.create(Person.prototype);
    // 修正Teacher()的prototype的constructor属性指向(修正前指向Person，不正确)
    Teacher.prototype.constructor = Teacher;
  &#125;
  Teacher.prototype.greeting = function()&#123;
    console.log(`hello, I am a teather, I teath $&#123;this.subject&#125;`)
  &#125;
  let t = new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath englis
</code></pre>
<p>&emsp;&emsp;<strong> ES6 类（class）</strong></p>
<p>&emsp;&emsp;(1) 类的定义方式<br>&emsp;&emsp;ES6 提供了更接近传统语言的写法，引入了class关键字（仅是一个‘语法糖’），可以定义类。可以使编码时逻辑更加清晰明了。在JavaScript中，类是一种“特殊的函数”。类本身就指向构造函数（即A == A.prototype.constructor）。</p>
<p><em>&emsp;&emsp;[注] 类都在严格模式下执行。类的内部所有定义的方法，都是不可枚举的（这点与ES5定义在prototype上的方法表现不一致）。类必须使用new关键字使用（不能像ES5中构造函数可直接调用）。</em></p>
<p>&emsp;&emsp;定义类有两种方式：<br>&emsp;&emsp;类声明：class A {}，<strong>类声明不会提升，需要先声明，再访问</strong><br>&emsp;&emsp;类表达式: let B = class [B2] {}，类表达式可以不命名，名称为局部名称，可使用类的name属性访问</p>
<p><em>&emsp;&emsp;<strong>[注] 类中的this：</strong></em><br>&emsp;&emsp;① 在构造函数constructor()中基类与派生类this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象（指向实例），所有非静态方法会被添加到this的原型中。在派生类（子类）中的构造函数没有初始的this绑定（undefined），在构造函数中调用super()才能生成一个this绑定（返回一个指向当前派生类的this）。<br>&emsp;&emsp;② 静态方法不是this的属性，它们只是类自身的属性，不会被子类继承。派生类在super()前调用this会抛出异常，派生类不能在调用super()前返回，除非没有构造函数或者构造函数返回了对象。<br>&emsp;&emsp;③ 使用super对象时，super 调用父类的方法时，super 会绑定子类的 this。</p>
<p>&emsp;&emsp;(2) constructor()构造函数<br>&emsp;&emsp;初始化一个由class创建的对象。一个类中只能有唯一的constructor()方法，若代码未显式的定义，会添加一个默认的该方法。在使用new关键字创建实例时，会执行该方法，其中的this指向创建的实例。默认会返回this实例，不过也可以显式的返回一个对象。</p>
<p>&emsp;&emsp;(3) super关键字<br>&emsp;&emsp;分为两种情况：<br>&emsp;&emsp;当做函数使用：super()，这个函数会调用父类的构造函数，返回一个指向当前派生类的this，相当于A.prototype.constructor.call(this, props)<br>&emsp;&emsp;当做对象使用：在普通方法中，super指向父类的原型对象；在静态方法中，super指向父类</p>
<p><em>&emsp;&emsp;[注] 静态方法，static修饰，可以被子类继承，但不会添加到类的实例上，方法名称可与其他方法重名。静态方法可以通过super调用。</em></p>
<p>&emsp;&emsp;(4) 取值函数（getter）和存值函数（setter）<br>&emsp;&emsp;在类中内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为（ES5可以提供getter、setter函数）。</p>
<p>&emsp;&emsp;(5) new.target属性<br>&emsp;&emsp;new命令的一个属性，只能在构造函数中使用。在类中使用时，返回当前类；在子类中使用时，返回当前子类。用途：可以限制类只能通过new命令调用；或者编写只能继承而不能实例化的基类。</p>
<p>&emsp;&emsp;通过ES6 Class关键字实现上面Teacher类与Person类的继承关系：</p>
<pre><code>  class Person&#123;    
    constructor(name, age, gender, interests)&#123;
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.interests = interests;
    &#125;
    greeting()&#123;
      console.log(&quot;hello, I am &quot; + this.name + &quot;!&quot;);
    &#125;
  &#125;
  class Teather extends Person&#123;
    constructor(name, age, gender, interests, subject)&#123;
      super(name, age, gender, interests);
      this.subject = subject;
    &#125;
    greeting()&#123;
      console.log(&quot;hello, I am a teather, I teath &quot; + this.subject + &quot;!&quot;);
    &#125;
  &#125;
  let t = new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting()
</code></pre>
<p>&emsp;&emsp;通过Babel.js将上面的ES6转换为ES5代码如下：</p>
<pre><code>  &quot;use strict&quot;;

  function _typeof(obj) &#123;
    &quot;@babel/helpers - typeof&quot;;
    if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) &#123; _typeof = function _typeof(obj) &#123; return typeof obj; &#125;; &#125;
    else &#123;
      _typeof = function _typeof(obj) &#123;
        return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;
      &#125;;
    &#125;
    return _typeof(obj);
  &#125;
  
  function _inherits(subClass, superClass) &#123;
    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123;
      throw new TypeError(&quot;Super expression must either be null or a function&quot;);
    &#125;
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125; &#125;);
    if (superClass) _setPrototypeOf(subClass, superClass);
  &#125;
  
  function _setPrototypeOf(o, p) &#123;
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123;
      o.__proto__ = p; return o;
    &#125;;
    return _setPrototypeOf(o, p);
  &#125;
  
  function _createSuper(Derived) &#123;
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() &#123;
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) &#123;
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      &#125; else &#123;
        result = Super.apply(this, arguments);
      &#125;
      return _possibleConstructorReturn(this, result);
    &#125;;
  &#125;
  
  function _possibleConstructorReturn(self, call) &#123;
    if (call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)) &#123;
      return call;
    &#125;
    return _assertThisInitialized(self);
  &#125;
  
  function _assertThisInitialized(self) &#123;
    if (self === void 0) &#123;
      throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
    &#125;
    return self;
  &#125;
  
  function _isNativeReflectConstruct() &#123;
    if (typeof Reflect === &quot;undefined&quot; || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === &quot;function&quot;) return true;
    try &#123;
      Date.prototype.toString.call(Reflect.construct(Date, [], function () &#123; &#125;));
      return true;
    &#125; catch (e) &#123;
      return false;
    &#125;
  &#125;
  
  function _getPrototypeOf(o) &#123;
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123;
      return o.__proto__ || Object.getPrototypeOf(o);
    &#125;;
    return _getPrototypeOf(o);
  &#125;
  
  function _instanceof(left, right) &#123;
    if (right != null &amp;&amp; typeof Symbol !== &quot;undefined&quot; &amp;&amp; right[Symbol.hasInstance]) &#123;
      return !!right[Symbol.hasInstance](left);
    &#125; else &#123;
      return left instanceof right;
    &#125;
  &#125;
  
  function _classCallCheck(instance, Constructor) &#123;
    if (!_instanceof(instance, Constructor)) &#123;
      throw new TypeError(&quot;Cannot call a class as a function&quot;);
    &#125;
  &#125;
  
  function _defineProperties(target, props) &#123;
    for (var i = 0; i &lt; props.length; i++) &#123;
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if (&quot;value&quot; in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    &#125;
  &#125;
  
  function _createClass(Constructor, protoProps, staticProps) &#123;
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  &#125;
  
  var Person = /*#__PURE__*/function () &#123;
    function Person(name, age, gender, interests) &#123;
      _classCallCheck(this, Person);
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.interests = interests;
    &#125;
    _createClass(Person, [&#123;
      key: &quot;greeting&quot;,
      value: function greeting() &#123;
        console.log(&quot;hello, I am &quot;.concat(this.name, &quot;!&quot;));
      &#125;
    &#125;]);
    return Person;
  &#125;();
  
  var Teather = /*#__PURE__*/function (_Person) &#123;
    _inherits(Teather, _Person);
    var _super = _createSuper(Teather);
    function Teather(name, age, gender, interests, subject) &#123;
      var _this;
      _classCallCheck(this, Teather);
      _this = _super.call(this, name, age, gender, interests);
      _this.subject = subject;
      return _this;
    &#125;
    _createClass(Teather, [&#123;
      key: &quot;greeting&quot;,
      value: function greeting() &#123;
        console.log(&quot;hello, I am a teather, I teath &quot;.concat(this.subject));
      &#125;
    &#125;]);
    return Teather;
  &#125;(Person);
  
  var t = new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting();
</code></pre>
<p>&emsp;&emsp;ES6转换后的ES5代码与原来的ES5代码实现原理一致。我们来简单分析一下转换后的代码：<br>&emsp;&emsp;① 可以看到，定义Person和Teacher时，使用了立即执行函数，代码会立即执行，执行后返回Person构造函数以及继承于Person的Teacher构造函数。<br>&emsp;&emsp;② 在定义Person变量的立即执行函数中，定义了Person函数，函数中设置了相关属性。然后调用_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法给Person函数的原型prototype上添加上方法，(还可以给Person函数添加静态属性，这里代码未添加）。即_createClass()实现了Person函数方法与属性的添加，最后将Person函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;③ 在定义Teacher变量的立即执行函数中，将定义好的Person构造函数函数作为了参数，先调用_inherits()方法，将定义的Teacher函数（预编译会进行函数提升）与传入的Person构造函数作为参数，其中使用Object.create()方法以Person构造函数的原型prototype作为原型，设置了Teacher函数的原型，同时Teacher函数的原型也继承了Person构造函数原型链上的属性和方法，然后调用_setPrototypeOf()方法修正Teacher函数原型对象__proto__的指向，也就是_inherits()方法实现了继承关系。然后再调用了_createSuper(Teather)方法定义了_super变量，其值是一个函数，里面追溯了Teacher构造函数的原型链，定义了调用父构造函数Person时，使用了apply（this, arguments）方法绑定了子构造函数Teacher的this，实现了Teacher函数属性的设置（<u>返回的_super方法这里只是定义，还未执行，要在Teacher构造函数执行到_super.call()的时候才会执行</u>）。最后同理，调用了_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法在Teacher函数的原型prototype上重写了greeting()方法，将Teacher函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;④ 调用new Teacher()创建t实例，执行Teacher构造函数，调用_classCallCheck()防止构造函数被直接调用（即ES6中的类是不能被直接调用的）。然后再调用上面说的定义的_super()方法实现了实例属性的设置（在执行_super()函数时，会执行里面定义的父构造函数Person的方法来实现属性的继承与设置），再设置了Teacher构造函数实例特有的subject属性，此时获得的_this实例的原型指向Teacher构造函数，Teacherr构造函数又继承于Person构造函数。此时_this实例已经继承了原型链上的属性与方法，包括Teahcer构造函数重写的greeting()方法。返回_this。<br>&emsp;&emsp;⑤ 执行t.greeting()方法，可以看到方法被成功执行且为执行的重写后的方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
</search>
