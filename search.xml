<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS定位（Position）与3D坐标轴</title>
    <url>/2020/09/27/css/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88Position%EF%BC%89%E4%B8%8E3D%E5%9D%90%E6%A0%87%E8%BD%B4/</url>
    <content><![CDATA[<p>用于指定一个元素在文档中的定位方式（元素在网页上的位置），对应的属性top，right，bottom 和 left属性则决定了该元素的最终定位的位置。</p>
<h2 id="1、平面空间坐标轴（2D）"><a href="#1、平面空间坐标轴（2D）" class="headerlink" title="1、平面空间坐标轴（2D）"></a>1、平面空间坐标轴（2D）</h2><p>&emsp;&emsp;在CSS平初始坐标系从屏幕左上角向右为X轴，从左上角向下为Y轴。在position定位方式中，其中top、right、bottom和left代表元素距离参考上、右、下，左方向上的距离。</p>
<p><img src="/images/css3/%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="平面空间坐标轴"></p>
<h2 id="2、定位类型"><a href="#2、定位类型" class="headerlink" title="2、定位类型"></a>2、定位类型</h2><p>&emsp;&emsp;position的取值：static、relative、 absolute、fixed，sticky与inherit</p>
<p>&emsp;&emsp;定位元素：是其计算后位置属性为relative、absolute，fixed或sticky的一个元素</p>
<p>&emsp;&emsp;(1) 默认定位(static)：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p>
<p>&emsp;&emsp;(2) 相对定位(relative)：相对于自己最初的位置进行定位，相对位置的坐标参考系是以自己定位前在文档流的位置(x, y)作为原点(0, 0)。<u>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</u>而且position: relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p>
<p><img src="/images/css3/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D(relative).png" alt="相对定位(relative)"></p>
<p>&emsp;&emsp;(3) 绝对定位(absolute/fixed)：绝对定位的元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位父级(祖先)元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。特别的，fixed绝对定位（固定定位）是相对于浏览器窗口（viewport）进行定位，元素的位置在屏幕滚动时不会改变。元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p>
<p><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(absolute).png" alt="绝对定位(absolute)"><br><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(fixed).png" alt="绝对定位(fixed)"></p>
<p>&emsp;&emsp;(4) 粘性定位(sticky)：元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。粘性定位表现为相对定位和固定定位叠加的效果。元素在跨越特定阈值前为相对定位(relative)，之后为固定定位(fixed)。</p>
<p><img src="/images/css3/%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D(sticky).png" alt="粘性定位(sticky)"></p>
<h2 id="3、三维空间坐标轴（3D）"><a href="#3、三维空间坐标轴（3D）" class="headerlink" title="3、三维空间坐标轴（3D）"></a>3、三维空间坐标轴（3D）</h2><p>&emsp;&emsp;CSS中3D初始坐标系，其XYZ轴的正方向分别是：向右、向下、向屏幕外。如下图：</p>
<p><img src="/images/css3/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="三维空间坐标轴"></p>
<p>&emsp;&emsp;对一个元素设置属性 transform-style为preserve-3d ，便可对其进行3D变换，有translateX()，translateY()，translateZ()平移方法以及rotateX()，rotateY()，rotateZ()等旋转方法。一般会对元素设置 perspective 属性来调整元素观测的视角。默认旋转中心为左上角（0,0）（如上图），可通过transform-origin对旋转中心进行移动。<u>当transform使用多个变换函数时，每一个变换函数不仅改变了元素，同时也会改变和元素关联的transform坐标系，当变换函数依次执行时，后一个变换函数总是基于前一个变换后的新transform坐标系执行，所有要注意变换函数的顺序。</u><br>&emsp;&emsp;(1) 对于平移，参照对应坐标轴方向进行相应的平移变换即可。<br>&emsp;&emsp;(2) 对于旋转，先要判断旋转方向，正对某一轴正，其顺时针方向就是该轴旋转的方向，或者采用左手法则判断旋转方向（即左手握住旋转轴，竖起拇指指向旋转轴正方向，其余手指卷曲方向为旋转正方向）；再根据旋转中心的位置进行相应的旋转变换。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS动画（过渡、关键帧、3次贝塞尔曲线）</title>
    <url>/2020/11/26/css/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<p>CSS 动画可以在不借助 Javascript 的情况下做出一些相对简单的动画效果，例如缩放、移动、2D/3D旋转等。CSS动画有浏览器控制，表现得很流畅。 <u>CSS动画的时序函数主要为3次贝塞尔曲线。</u></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>&emsp;&emsp;CSS动画是由浏览器按照一定的频率一帧一帧的绘制的，CSS实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新动画，不依赖于主线程，所以<u>CSS动画是很流畅的</u>。CSS过渡、关键帧相关知识在前面的文章<a href="/2020/09/24/css/CSS-3-%E6%A6%82%E8%BF%B0">《CSS(3)概述》</a>里已经讲到，这里摘抄相关知识如下：</p>
<p>&emsp;&emsp;2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你更改一个元素变形的原点(该属性必须与transform属性一同使用)</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript来完成</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线(时序函数)，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>&emsp;&emsp;您可以改变任意多的样式任意多的次数。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes name</span><br><span class="line">&#123;</span><br><span class="line">  0%   &#123; &#x2F;&#x2F; 状态1 &#125;</span><br><span class="line">  ...</span><br><span class="line">  xx%  &#123; &#x2F;&#x2F; 状态x &#125;</span><br><span class="line">  ...</span><br><span class="line">  100% &#123; &#x2F;&#x2F; 状态n &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 自定义动画的使用</span><br><span class="line">animation: name duration timing-function delay iteration-count direction;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)</span><br><span class="line">&#x2F;&#x2F; iteration-count的取值: n(次数)、infinite</span><br><span class="line">&#x2F;&#x2F; animation-direction的取值: normal、alternate</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容应添加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>对应@keyframes定义的动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<strong>CSS动画时序函数(timing-function属性的值）：</strong><br>&emsp;&emsp;CSS动画的时序函数主要为3次贝塞尔曲线。3次贝塞尔曲线由4点个组成，CSS3贝塞尔曲线起点是 (0,0) ，终点是(1,1)，代表动画执行时间到达时动画刚好执行完成。所以CSS中的cubic-bezier()函数只需要传入其他的2个端点值（x1,y1,x2,y2）即可。</p>
<p>&emsp;&emsp;timing-function取值分别对应的贝尔塞曲线函数为：</p>
<p><img src="/images/css3/timing-function%E5%8F%96%E5%80%BC.png" alt="timing-function取值"></p>
<p><em>[注] 以上图片制作于<a href="https://cubic-bezier.com/">https://cubic-bezier.com/</a>，这是一个贝尔塞曲线在线设置与查看的网站，其中紫色的点表示（x1, y1）,蓝色的点表示（x2, y2）。</em></p>
<p>&emsp;&emsp;<strong>其中横轴（x轴）表示时间，纵轴（y轴）表示随着时间推移动画完成情况，曲线的斜率表现为为动画完成的快慢（比如移动速度等）。浏览器会根据时序函数对动画完成情况进行对应的更新（即由时序函数来确定此刻动画中各元素的状态）。</strong>根据图片，可以看到：linear随着时间推移，同一时间间隔动画的完成进度一致，即匀速的完成动画；ease-in先慢后快，ease-out先快后慢；ease-in-out则开始和结束较慢，中间动画完成的进度较快。<br>&emsp;&emsp;特别的，我们也可以使用cubic-bezier自定义时序函数，例如cubic-bezier(.92 ,-0.44, .04, 1.44)，可以看到随着时间的推移，完成情况最先是反向的且完成情况小于0，先快后慢；到最慢时然后完成情况变为正向，呈现先慢后快再慢（类似于ease-in-out），到最慢时此时动画的完成情况是大于1的（也就是多完成了一部分），此时完成情况的方向又变为反向的，先慢后快直到动画完成。</p>
<p>&emsp;&emsp;将cubic-bezier(.92 ,-0.44, .04, 1.44)时序用到transition属性中（时序函数一般要求写在过渡时间的后面）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">  &#125;</span><br><span class="line">  .ball &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: chocolate;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">    transition: all 3s cubic-bezier(.92, -0.44, .04, 1.44);</span><br><span class="line">  &#125;</span><br><span class="line">  .box:hover .ball &#123;</span><br><span class="line">    margin-left: calc(100% - 50px);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ball&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;具体动画的效果：</p>
<p><img src="/images/css3/%E8%BF%90%E5%8A%A8%E7%9A%84%E5%B0%8F%E7%90%83.gif" alt="运动的小球"></p>
<p>&emsp;&emsp;如代码所示，外层class为box的div宽300px，里面放置一个直径为50px的小球，初始位置为外层div里的最左侧。设置外层div变为hover状态时，小球向右移动到外层div里的最右侧的过渡，过渡时间3s，过渡的时序函数用我们自定义贝塞尔曲线。可以看到小球先向左（反方向）由快到慢的移动，移出了外层div左侧一部分；在向右由慢到快再到慢的移动，特别是中间移动速度极快，停下来时也已移出了外层div最右侧一部分；然后在向左（反方向）由慢到快直至小球停到外层div里的最右侧。外层div失去焦点时小球的移动方式与获得焦点相反。可以看到小球移动的状态与设置时序函数的贝塞尔曲线的状态一致。</p>
<p>&emsp;&emsp;在这里再做一些dome实例的补充：</p>
<h2 id="1、旋转的筛子"><a href="#1、旋转的筛子" class="headerlink" title="1、旋转的筛子"></a>1、旋转的筛子</h2><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AD%9B%E5%AD%90.gif" alt="旋转的筛子"></p>
<p>&emsp;&emsp;代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .cube &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    perspective: 500px;</span><br><span class="line">    margin: 100px;</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    animation: rotate 20s infinite;</span><br><span class="line">    animation-timing-function: linear;</span><br><span class="line">  &#125;</span><br><span class="line">  .cube div &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    transition: all .4s;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    opacity: 0.9;</span><br><span class="line">  &#125;</span><br><span class="line">  .cube div img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">  .front &#123;</span><br><span class="line">    transform: translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line">  .back &#123;</span><br><span class="line">    transform: translateZ(-50px);</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    transform: rotateY(90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    transform: rotateY(-90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line">  .top &#123;</span><br><span class="line">    transform: rotateX(90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line">  .bottom &#123;</span><br><span class="line">    transform: rotateX(-90deg) translateZ(50px);</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes rotate &#123;</span><br><span class="line">    from &#123;</span><br><span class="line">      transform: rotateX(0deg) rotateY(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      transform: rotateX(360deg) rotateY(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;cube&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;front&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;3.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;back&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;5.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;left&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;2.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;right&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;4.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;top&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;1.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bottom&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;6.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;简单说明：先在外层class为box的div上设置了观测视角。再对class为cube的div元素设置了transform-style: preserve-3d，使其可以进行3D变换。再对其内部的6个面（实现方式不止代码所示的一种，变换过程中旋转与平移先后顺序不同代码就会不同。这里用图片简单表示骰子的1-6，通过Flex或是Grid布局实现骰子6个面的布局也比较容易）进行相应的3D平移与旋转，布局成为一个立方体。再对class为cube的div元素添加了自定义的关键帧rotate旋转动画。</p>
<h2 id="2、边框滚动动画"><a href="#2、边框滚动动画" class="headerlink" title="2、边框滚动动画"></a>2、边框滚动动画</h2><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E8%BE%B9%E6%A1%86%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB.gif" alt="边框滚动动画"></p>
<p>&emsp;&emsp;代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .outer-box &#123;</span><br><span class="line">    width: 300px; height: 100px; box-sizing: border-box; padding: 2px;</span><br><span class="line">    background: repeating-linear-gradient(45deg, #000, #000 3px, transparent, #000 8px);</span><br><span class="line">    animation: line 1s infinite linear;</span><br><span class="line">  &#125;</span><br><span class="line">  .inner-box &#123;</span><br><span class="line">    width: 100%; height: 100%;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    display: flex; justify-content: center; align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes line &#123;</span><br><span class="line">    0% &#123; background-position: 1px -1px; &#125;</span><br><span class="line">    100% &#123; background-position: 12px -12px; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;outer-box&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;inner-box&quot;&gt;- (^_^) -&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;简单说明：这里将外层div设置为渐变的背景图片，2px内间距。内部div宽高100%，背景为白色，此时只见外层div出现类似于虚线边框的样式。加入自定义动画line，线性向右上方移动背景图片，便出现了边框滚动的效果。</p>
<h2 id="3、元素沿着不规则路径运动"><a href="#3、元素沿着不规则路径运动" class="headerlink" title="3、元素沿着不规则路径运动"></a>3、元素沿着不规则路径运动</h2><p>&emsp;&emsp;这里我们会用到offset-path等相关属性来实现，这个属性相对较新（要注意浏览器兼容），先介绍常用的属性：<br>&emsp;&emsp;<strong>offset-path：指定元素要遵循的运动路径以及元素位置。</strong>取值为：<br>&emsp;&emsp;&emsp;&emsp;ray() ：定义的一条路径<br>&emsp;&emsp;&emsp;&emsp;url()：引用SVG图片的URL<br>&emsp;&emsp;&emsp;&emsp;形状：circle()、 ellipse()、inset()、polygon()等<br>&emsp;&emsp;&emsp;&emsp;path()：用SVG坐标语法定义的路径字符串<br>&emsp;&emsp;<strong>offset-distance：指定要放置的元素沿路径偏移的位置（px，%）。</strong><br>&emsp;&emsp;<strong>offset-rotate：元素运动的角度（deg），默认auto，表示沿当前路径的切线方向前进。</strong></p>
<p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E4%B8%8D%E8%A7%84%E5%88%99%E8%BF%90%E5%8A%A8.gif" alt="不规则运动"></p>
<p>&emsp;&emsp;代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123; position: relative; &#125;</span><br><span class="line">  .car &#123;</span><br><span class="line">    offset-path: path(&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot;);</span><br><span class="line">    animation: move 3s linear infinite;</span><br><span class="line">    position: absolute; width: 50px; height: auto;</span><br><span class="line">  &#125;</span><br><span class="line">  @keyframes move &#123;</span><br><span class="line">    100% &#123; offset-distance: 100%; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">  &lt;img src&#x3D;&quot;img&#x2F;car.png&quot; width&#x3D;&quot;40&quot; height&#x3D;&quot;43&quot; class&#x3D;&quot;car&quot;&gt;</span><br><span class="line">  &lt;svg width&#x3D;&quot;290px&quot; height&#x3D;&quot;160px&quot; version&#x3D;&quot;1.1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;&gt;</span><br><span class="line">    &lt;path d&#x3D;&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot; stroke&#x3D;&quot;black&quot; fill&#x3D;&quot;transparent&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;svg&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;简单说明：这里路径使用SVG图片，设置汽车的图片offset-path偏移路径为SVG中path字符串一致。自定义动画move使汽车每3s沿SVG路径进行偏移直至100%，便出现了汽车元素沿不规则路径移动的效果。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML Canvas（2D时序动画）</title>
    <url>/2020/09/15/html/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>HTML5 &lt;canvas&gt; 标签用于绘制图像，但元素本身并没有绘制能力（它仅仅是图形的容器），您必须使用JavaScript脚本（相关API）来完成实际的绘图任务。</p>
<h2 id="1、坐标系"><a href="#1、坐标系" class="headerlink" title="1、坐标系"></a>1、坐标系</h2><h3 id="1-标准（初始）坐标系"><a href="#1-标准（初始）坐标系" class="headerlink" title="(1) 标准（初始）坐标系"></a>(1) 标准（初始）坐标系</h3><p><img src="/images/canvas/%E6%A0%87%E5%87%86%EF%BC%88%E5%88%9D%E5%A7%8B%EF%BC%89%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="标准（初始）坐标系"><br>&emsp;&emsp;canvas 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas 元素中的一像素。栅格的起点为左上角，坐标为 (0,0) 。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。</p>
<h3 id="2-偏移坐标原点（translate方法）"><a href="#2-偏移坐标原点（translate方法）" class="headerlink" title="(2) 偏移坐标原点（translate方法）"></a>(2) 偏移坐标原点（translate方法）</h3><p><img src="/images/canvas/%E5%81%8F%E7%A7%BB%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9.png" alt="偏移坐标原点"><br>&emsp;&emsp;translate 方法用来移动 canvas 的原点到指定的位置。接受两个参数。x 是左右的偏移量，y 是上下的偏移量。</p>
<h3 id="3-旋转坐标轴（rotate方法）"><a href="#3-旋转坐标轴（rotate方法）" class="headerlink" title="(3) 旋转坐标轴（rotate方法）"></a>(3) 旋转坐标轴（rotate方法）</h3><p><img src="/images/canvas/%E6%97%8B%E8%BD%AC%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="旋转坐标轴"><br>&emsp;&emsp;rotate方法用来旋转坐标轴，只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。</p>
<h2 id="2、绘图流程"><a href="#2、绘图流程" class="headerlink" title="2、绘图流程"></a>2、绘图流程</h2><h3 id="1-创建canvas元素（图形容器）"><a href="#1-创建canvas元素（图形容器）" class="headerlink" title="(1) 创建canvas元素（图形容器）"></a>(1) 创建canvas元素（图形容器）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;500&quot; height&#x3D;&quot;500&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-获取canvas-DOM元素"><a href="#2-获取canvas-DOM元素" class="headerlink" title="(2) 获取canvas DOM元素"></a>(2) 获取canvas DOM元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let canvas&#x3D;document.getElementById(&quot;myCanvas&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="3-获得canvas-context-对象"><a href="#3-获得canvas-context-对象" class="headerlink" title="(3) 获得canvas context 对象"></a>(3) 获得canvas context 对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ctx&#x3D;canvas.getContext(&quot;2d&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="4-调用相关绘图API定义要绘制的路径与图像"><a href="#4-调用相关绘图API定义要绘制的路径与图像" class="headerlink" title="(4) 调用相关绘图API定义要绘制的路径与图像"></a>(4) 调用相关绘图API定义要绘制的路径与图像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 画线    </span><br><span class="line">ctx.moveTo(0, 0);</span><br><span class="line">ctx.lineTo(100, 100);</span><br><span class="line">&#x2F;&#x2F; 画圆</span><br><span class="line">ctx.arc(95, 50, 40, 2 * Math.PI, 0);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#x2F;&#x2F; 可添加对键盘鼠标键盘事件的处理，实现交互动画</span><br></pre></td></tr></table></figure>
<h3 id="5-绘制已定义的路径及图像"><a href="#5-绘制已定义的路径及图像" class="headerlink" title="(5) 绘制已定义的路径及图像"></a>(5) 绘制已定义的路径及图像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.stroke(); &#x2F;&#x2F; 有时会重新映射坐标原点或者旋转画布坐标轴，需要ctx.save()与ctx.restore()配合使用来存储于恢复画布状态</span><br></pre></td></tr></table></figure>
<h3 id="6-定时刷新canvas从而实现动画效果"><a href="#6-定时刷新canvas从而实现动画效果" class="headerlink" title="(6) 定时刷新canvas从而实现动画效果"></a>(6) 定时刷新canvas从而实现动画效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; requestAnimationFrame()方法（推荐）或者setInterval()&#x2F;递归调用setTimeout()方法进行刷新动画</span><br></pre></td></tr></table></figure>
<h2 id="3、常用绘图属性与API方法"><a href="#3、常用绘图属性与API方法" class="headerlink" title="3、常用绘图属性与API方法"></a>3、常用绘图属性与API方法</h2><h3 id="1-颜色、样式、阴影属性与方法"><a href="#1-颜色、样式、阴影属性与方法" class="headerlink" title="(1) 颜色、样式、阴影属性与方法"></a>(1) 颜色、样式、阴影属性与方法</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td>shadowOffsetX</td>
<td>设置或返回阴影与形状的水平距离</td>
</tr>
<tr>
<td>shadowOffsetY</td>
<td>设置或返回阴影与形状的垂直距离</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr>
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td>createRadialGradient()</td>
<td>创建放射状/环形的渐变（用在画布内容上）</td>
</tr>
<tr>
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody></table>
<h3 id="2-线条样式属性"><a href="#2-线条样式属性" class="headerlink" title="(2) 线条样式属性"></a>(2) 线条样式属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lineCap</td>
<td>设置或返回线条的结束端点样式(值为square、round，线条会稍稍变长)</td>
</tr>
<tr>
<td>lineJoin</td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td>lineWidth</td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td>miterLimit</td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody></table>
<h3 id="3-矩形方法"><a href="#3-矩形方法" class="headerlink" title="(3) 矩形方法"></a>(3) 矩形方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>rect()</td>
<td>创建矩形</td>
</tr>
<tr>
<td>fillRect()</td>
<td>绘制‘被填充’的矩形</td>
</tr>
<tr>
<td>strokeRect()</td>
<td>绘制矩形（无填充）</td>
</tr>
<tr>
<td>clearRect()</td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
</tbody></table>
<h3 id="4-路径方法"><a href="#4-路径方法" class="headerlink" title="(4) 路径方法"></a>(4) 路径方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fill()</td>
<td>填充当前绘图（路径）</td>
</tr>
<tr>
<td>stroke()</td>
<td>绘制已定义的路径</td>
</tr>
<tr>
<td>beginPath()</td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr>
<td>closePath()</td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr>
<td>lineTo()</td>
<td>添加一个新点，然后在画布中创建从该点到最后指定点的线条</td>
</tr>
<tr>
<td>clip()</td>
<td>原始画布剪切任意形状和尺寸的区域(裁剪路径的作用可制作遮罩)</td>
</tr>
<tr>
<td>quadraticCurveTo()</td>
<td>创建二次贝塞尔曲线</td>
</tr>
<tr>
<td>bezierCurveTo()</td>
<td>创建三次贝塞尔曲线</td>
</tr>
<tr>
<td>arc()</td>
<td>创建弧/曲线（用于创建圆形或部分圆）</td>
</tr>
<tr>
<td>arcTo()</td>
<td>创建两切线之间的弧/曲线</td>
</tr>
<tr>
<td>isPointInPath()</td>
<td>如果指定的点位于当前路径中，则返回true，否则返回false</td>
</tr>
<tr>
<td>setLineDash()</td>
<td>填充线时使用虚线模式（参数为数组，交替描述绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复）</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;注：一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）</em></p>
<h3 id="5-转换方法"><a href="#5-转换方法" class="headerlink" title="(5) 转换方法"></a>(5) 转换方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr>
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr>
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr>
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr>
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵。然后运行transform()</td>
</tr>
</tbody></table>
<h3 id="6-文本属性与方法"><a href="#6-文本属性与方法" class="headerlink" title="(6) 文本属性与方法"></a>(6) 文本属性与方法</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>font</td>
<td>设置或返回文本内容的当前字体属性</td>
</tr>
<tr>
<td>textAlign</td>
<td>设置或返回文本内容的当前对齐方式</td>
</tr>
<tr>
<td>textBaseline</td>
<td>设置或返回在绘制文本时使用的当前文本基线</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillText()</td>
<td>在画布上绘制”被填充的”文本</td>
</tr>
<tr>
<td>strokeText()</td>
<td>在画布上绘制文本（无填充）</td>
</tr>
<tr>
<td>measureText()</td>
<td>返回包含指定文本宽度的对象</td>
</tr>
</tbody></table>
<h3 id="7-像素操作属性与方法"><a href="#7-像素操作属性与方法" class="headerlink" title="(7) 像素操作属性与方法"></a>(7) 像素操作属性与方法</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>返回 ImageData 对象的宽度</td>
</tr>
<tr>
<td>height</td>
<td>返回 ImageData 对象的高度</td>
</tr>
<tr>
<td>data</td>
<td>返回一个对象，其包含指定的 ImageData 对象的图像数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createImageData()</td>
<td>创建新的、空白的 ImageData 对象</td>
</tr>
<tr>
<td>getImageData()</td>
<td>返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据</td>
</tr>
<tr>
<td>putImageData()</td>
<td>把图像数据（从指定的 ImageData 对象）放回画布上</td>
</tr>
</tbody></table>
<h3 id="8-图像绘制方法"><a href="#8-图像绘制方法" class="headerlink" title="(8) 图像绘制方法"></a>(8) 图像绘制方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>drawImage()</td>
<td>向画布上绘制图像、画布或视频</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.drawImage(img,[sx,sy,swidth,sheight,]x,y,[width,height]); &#x2F;&#x2F; 语法，其中img为Image实例</span><br></pre></td></tr></table></figure>
<h3 id="9-其他属性与方法"><a href="#9-其他属性与方法" class="headerlink" title="(9) 其他属性与方法"></a>(9) 其他属性与方法</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>globalAlpha</td>
<td>设置或返回绘图的当前 alpha 或透明值</td>
</tr>
<tr>
<td>globalCompositeOperation</td>
<td>设置或返回新图像如何绘制到已有的图像上</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>save()</td>
<td>保存当前环境的状态（可以调用任意多次save方法，类似数组的push）</td>
</tr>
<tr>
<td>restore()</td>
<td>返回之前保存过的路径状态和属性（调用restore方法，上一个保存的状态就从栈中弹出，类似于数组pop）</td>
</tr>
</tbody></table>
<h2 id="4、canvas小案例（时钟）"><a href="#4、canvas小案例（时钟）" class="headerlink" title="4、canvas小案例（时钟）"></a>4、canvas小案例（时钟）</h2><p>(1) 动画效果：<br><img src="/images/canvas/%E6%97%B6%E9%92%9F.gif" alt="时钟"><br>(2) 实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;时钟&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html,</span><br><span class="line">        body &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        body &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas id&#x3D;&quot;clock&quot; height&#x3D;&quot;250px&quot; width&#x3D;&quot;250px&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F; 时钟</span><br><span class="line">        let dom &#x3D; document.getElementById(&#39;clock&#39;);</span><br><span class="line">        let ctx &#x3D; dom.getContext(&#39;2d&#39;);</span><br><span class="line">        let width &#x3D; ctx.canvas.width;</span><br><span class="line">        let height &#x3D; ctx.canvas.height;</span><br><span class="line">        let r &#x3D; width &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 绘制时钟，定义计时器对其进行实时刷新</span><br><span class="line">        draw();</span><br><span class="line">        setInterval(draw, 1000);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;绘制时钟圆环</span><br><span class="line">        function drawBackground() &#123;</span><br><span class="line">            ctx.save();</span><br><span class="line">            ctx.translate(r, r);</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.lineWidth &#x3D; 10;</span><br><span class="line">            ctx.arc(0, 0, r - ctx.lineWidth &#x2F; 2, 0, 2 * Math.PI, false);</span><br><span class="line">            ctx.stroke();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绘制时间数字</span><br><span class="line">        function drawNumber() &#123;</span><br><span class="line">            let hourNumbers &#x3D; [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2];</span><br><span class="line">            hourNumbers.map(function (number, i) &#123;</span><br><span class="line">                let rad &#x3D; 2 * Math.PI &#x2F; 12 * i;</span><br><span class="line">                let x &#x3D; Math.cos(rad) * (r - 30);</span><br><span class="line">                let y &#x3D; Math.sin(rad) * (r - 30);</span><br><span class="line">                ctx.textAlign &#x3D; &#39;center&#39;;</span><br><span class="line">                ctx.textBaseline &#x3D; &#39;middle&#39;;</span><br><span class="line">                ctx.font &#x3D; 16 + &quot;px Arial&quot;;</span><br><span class="line">                ctx.fillText(number, x, y)</span><br><span class="line">            &#125;);</span><br><span class="line">            ctx.stroke();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绘制刻度</span><br><span class="line">        function drawDots() &#123;</span><br><span class="line">            let hourNumbers &#x3D; [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2];</span><br><span class="line">            for (let i &#x3D; 0; i &lt; 60; i++) &#123;</span><br><span class="line">                let rad &#x3D; 2 * Math.PI &#x2F; 60 * i;</span><br><span class="line">                let x &#x3D; Math.cos(rad) * (r - 16);</span><br><span class="line">                let y &#x3D; Math.sin(rad) * (r - 16) + 1;</span><br><span class="line">                ctx.textAlign &#x3D; &#39;center&#39;;</span><br><span class="line">                ctx.textBaseline &#x3D; &#39;middle&#39;;</span><br><span class="line">                ctx.font &#x3D; 18 + &quot;px Arial&quot;;</span><br><span class="line">                if (i % 5 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    ctx.fillStyle &#x3D; &#39;black&#39;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ctx.fillStyle &#x3D; &#39;#d1d1d1&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.fillText(&#39; • &#39;, x, y)</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.stroke();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绘制时针</span><br><span class="line">        function drawHour(hour, minute) &#123;</span><br><span class="line">            ctx.save();</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            let rad &#x3D; 2 * Math.PI &#x2F; 12 * hour;</span><br><span class="line">            let mrad &#x3D; 2 * Math.PI &#x2F; 12 &#x2F; 60 * minute;</span><br><span class="line">            ctx.rotate(rad + mrad);</span><br><span class="line">            ctx.lineWidth &#x3D; 6;</span><br><span class="line">            ctx.moveTo(0, 10);</span><br><span class="line">            ctx.lineTo(0, -r &#x2F; 2);</span><br><span class="line">            ctx.lineCap &#x3D; &#39;round&#39;;</span><br><span class="line">            ctx.stroke();</span><br><span class="line">            ctx.restore();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绘制分针</span><br><span class="line">        function drawMinute(minute, second) &#123;</span><br><span class="line">            ctx.save()</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            let rad &#x3D; 2 * Math.PI &#x2F; 60 * minute;</span><br><span class="line">            let mrad &#x3D; 2 * Math.PI &#x2F; 60 &#x2F; 60 * second;</span><br><span class="line">            ctx.rotate(rad + mrad);</span><br><span class="line">            ctx.lineWidth &#x3D; 4;</span><br><span class="line">            ctx.moveTo(0, 10);</span><br><span class="line">            ctx.lineTo(0, -r &#x2F; 2 - 10);</span><br><span class="line">            ctx.lineCap &#x3D; &#39;round&#39;;</span><br><span class="line">            ctx.stroke();</span><br><span class="line">            ctx.restore();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 绘制秒针</span><br><span class="line">        function drawSecond(second) &#123;</span><br><span class="line">            ctx.save();</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            let rad &#x3D; 2 * Math.PI &#x2F; 60 * second;</span><br><span class="line">            ctx.rotate(rad);</span><br><span class="line">            ctx.lineWidth &#x3D; 2;</span><br><span class="line">            ctx.moveTo(0, 10);</span><br><span class="line">            ctx.lineTo(0, -r &#x2F; 2 - 20);</span><br><span class="line">            let gnt1 &#x3D; ctx.createLinearGradient(0, 0, 0, -r &#x2F; 2 - 20);</span><br><span class="line">            gnt1.addColorStop(0, &#39;red&#39;);</span><br><span class="line">            gnt1.addColorStop(1, &#39;rgb(250, 94, 94)&#39;);</span><br><span class="line">            ctx.strokeStyle &#x3D; gnt1;</span><br><span class="line">            ctx.lineCap &#x3D; &#39;round&#39;;</span><br><span class="line">            ctx.stroke();</span><br><span class="line">            ctx.restore();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 主函数-绘制时钟</span><br><span class="line">        function draw() &#123;</span><br><span class="line">            ctx.clearRect(0, 0, 300, 300);</span><br><span class="line">            let now &#x3D; new Date();</span><br><span class="line">            let hour &#x3D; now.getHours() &lt; 10 ? &#39;0&#39; + now.getHours() : now.getHours();</span><br><span class="line">            let minute &#x3D; now.getMinutes() &lt; 10 ? &#39;0&#39; + now.getMinutes() : now.getMinutes();</span><br><span class="line">            let second &#x3D; now.getSeconds() &lt; 10 ? &#39;0&#39; + now.getSeconds() : now.getSeconds();</span><br><span class="line">            drawBackground();</span><br><span class="line">            drawNumber();</span><br><span class="line">            drawDots();</span><br><span class="line">            drawHour(hour, minute);</span><br><span class="line">            drawMinute(minute, second);</span><br><span class="line">            drawSecond(second);</span><br><span class="line">            ctx.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局（自适应、响应式、Layout）</title>
    <url>/2020/11/02/css/CSS%E5%B8%83%E5%B1%80%EF%BC%88%E8%87%AA%E9%80%82%E5%BA%94%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%81Layout%EF%BC%89/</url>
    <content><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于盒状模型，依赖 display、 position、float、margin、paddding等属性，采用绝对的单位px、相对单位em、vw、vh、rem以及百分比%等单位进行页面设计。本文将从静态布局、流式布局、自适应布局、响应式布局、弹性布局几个方面进行简单介绍。</p>
<h2 id="1、静态布局"><a href="#1、静态布局" class="headerlink" title="1、静态布局"></a>1、静态布局</h2><p>&emsp;&emsp;页面采用px单位，一般会设置min-width属性，当页面尺寸小于这个宽度时，出现滚动条进行相应显示，当页面尺寸大于这个宽度时，内容区域一般设置为居中显示。使用浮动（float）、定位（position）对元素进行相应的布局<br>&emsp;&emsp;优点：设计简单，编码简单，不用考虑兼容性问题<br>&emsp;&emsp;缺点：有兼容性问题，针对不同的屏幕显示方式单一，对个别用户很不友好。有时也会JS动态修改标签的initial-scale使得页面相应等比缩放，但效果有限</p>
<h2 id="2、流式布局"><a href="#2、流式布局" class="headerlink" title="2、流式布局"></a>2、流式布局</h2><p>&emsp;&emsp;页面宽度采用%（百分比）进行布局，高度一般使用px进行设置，或设置为auto并结合margin、paddding进行布局。宽度会随着浏览器宽度进行相应的调整，为了防止对应区域过大或过小使得内容超出区域，一般结合max-width与min-width进行设置。这种布局整体布局方式不变，即页面元素间相对位置不变，文字大小一般使用px，不随页面尺寸变化而变化。布局方式的代表如栅格系统（将网页页面按比例分成对应行列来排列页面中元素的分布）<br>&emsp;&emsp;优点：在一定范围内，能较好的应对不同的PC端页面<br>&emsp;&emsp;缺点：不适应与PC端到移动端较大的尺寸跨度，元素区域过大过小很导致显示不友好。文字大小不随页面宽度变化而变化，在不同屏幕会出现页面样式可能不协调的情况</p>
<h2 id="3、自适应布局"><a href="#3、自适应布局" class="headerlink" title="3、自适应布局"></a>3、自适应布局</h2><p>&emsp;&emsp;自适应网页设计的核心，就是CSS3引入的媒体查询模块（@media）。自动检测屏幕宽度，然后加载相应的CSS文件或样式<br>&emsp;&emsp;采用媒体查询技术，为不同屏幕分辨率定义布局，即定义多个静态布局，每个静态布局对应一个屏幕范围，可对页面元素尺寸与位置进行相应的调整，对文字尺寸等也可以特殊设置或使用百分比%、em，rem，vh、vw等相对单位</p>
<p>&emsp;&emsp;特别的，其中：<br>&emsp;&emsp;百分比 %是相对于父元素大小的百分比大小<br>&emsp;&emsp;em是最常见的相对长度单位，基准值是当前元素的字号大小<br>&emsp;&emsp;rem代表“ root”：“ root em”，它等于固定在root元素上的字体大小<br>&emsp;&emsp;vh和vw更多是PC端响应式Web设计依赖百分比规则,尺寸vh等于视口高度的1/100，尺寸vw等于视口宽度的1/100。但CSS百分比度量并非始终是解决所有问题的最佳解决方案<br>&emsp;&emsp;<u>在移动设备中，物理设备上的1px一般不等于css的1px像素，在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px、1024px等值，带来的后果就是浏览器会出现横向滚动条。</u>为了避免这种情况，在移动端页面设计时，让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，使用下面的代码使viewport的宽度等于设备的宽度，即即网页初始大小占屏幕面积的100%</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 网页宽度等于屏幕宽度（width&#x3D;device-width），原始缩放比例为1.0（initial-scale&#x3D;1）</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;优点：对PC端、移动端不同屏幕尺寸变化时，页面元素都会进行相应的调整，有较好的适应能力<br>&emsp;&emsp;缺点：为了使不同设备达到较好的，对各个不同屏幕尺寸范围会进行长时间的设计与调整，过程中也会产生大量的冗余代码</p>
<h2 id="4、响应式布局"><a href="#4、响应式布局" class="headerlink" title="4、响应式布局"></a>4、响应式布局</h2><p>&emsp;&emsp;<u>个人认为，响应式布局比适应布局更高级，是自适应布局的优化；自适应布局是响应式布局的一个子集。它们都会使用媒体查询（@media）根据不同的访问设备的宽度加载不同的样式。</u>如果要说区别的话，或许自适应式只考虑了屏幕尺寸大小，主要使用媒体查询技术来相应的适应性调整，而响应式布局可能还会考虑到移动设备的触屏操作、页面元素排版是否合理，是否需要对元素的位置重新进行调整等问题。</p>
<h2 id="5、弹性布局（Flex布局）"><a href="#5、弹性布局（Flex布局）" class="headerlink" title="5、弹性布局（Flex布局）"></a>5、弹性布局（Flex布局）</h2><p>&emsp;&emsp;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性,可以简便、完整、响应式地实现各种页面布局。具体布局方式在上一篇文章(CSS布局类型（Display、Flex、Grid）)已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/css/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-1-Flex%E5%B8%83%E5%B1%80">Display Flex 传送门</a></p>
<h2 id="6、网格布局（Grid布局）"><a href="#6、网格布局（Grid布局）" class="headerlink" title="6、网格布局（Grid布局）"></a>6、网格布局（Grid布局）</h2><p>&emsp;&emsp;Grid 布局是目前最强大的布局方案。Grid 布局与Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。Flex 布局是轴线布局，只能指定项目针对轴线(主轴、交叉轴)的位置，可以看作是一维布局。Grid 布局则是将容器划分成行与列，产生单元格，然后指定项目所在的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。具体布局方式在上一篇文章已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/css/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-2-Grid%E5%B8%83%E5%B1%80">Display Grid 传送门</a></p>
<p><em>[注] 在页面的实际设计中，为了使页面达到更合理的布局方式。我们往往会根据布局要求采用多种布局方式来达到我们的目的</em></p>
<h2 id="题外话1-格式化上下文"><a href="#题外话1-格式化上下文" class="headerlink" title="题外话1 格式化上下文"></a>题外话1 格式化上下文</h2><p>&emsp;&emsp;格式化上下文(Block Formatting Context，BFC)是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域<br>&emsp;&emsp;创建BFC的方式：<br>&emsp;&emsp;根元素（html）<br>&emsp;&emsp;浮动元素（元素的 float 不是 none）<br>&emsp;&emsp;绝对定位元素（元素的 position 为 absolute 或 fixed）<br>&emsp;&emsp;行内块元素（元素的 display 为 inline-block）<br>&emsp;&emsp;表格元素（元素的 display 为 table-cell、table-caption等，HTML表格单元格默认为该值）<br>&emsp;&emsp;overflow 值不为 visible 的块元素（一般这种方式用得最多：overflow: hidden/auto）<br>&emsp;&emsp;弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）<br>&emsp;&emsp;网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p>
<p>&emsp;&emsp;BFC布局规则：<br>&emsp;&emsp;① 内部的块级元素会在垂直方向，依次排列<br>&emsp;&emsp;② 外边距塌陷现象，属于同一个BFC的两个相邻元素的margin会发生重叠（在其中一个元素外面添加一个BFC区域来清除外边距塌陷）<br>&emsp;&emsp;③ 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此<br>&emsp;&emsp;④ BFC的区域不会与浮动元素重叠，即浮动不会影响其它BFC中元素的布局<br>&emsp;&emsp;&emsp;&emsp;应用：<u>自适应两栏布局</u><br>&emsp;&emsp;⑤ BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然<br>&emsp;&emsp;⑥ 计算BFC的高度时，浮动元素也参与计算，即浮动元素不会超出BFC区域的边界<br>&emsp;&emsp;&emsp;&emsp;应用：<u>利用BFC特性来清除浮动</u>、<u>布局文本环绕图像样式</u>（也可以通过clearfix清除浮动来实现）</p>
<h2 id="题外话2-clearfix清除浮动"><a href="#题外话2-clearfix清除浮动" class="headerlink" title="题外话2 clearfix清除浮动"></a>题外话2 clearfix清除浮动</h2><p>&emsp;&emsp;原理：clear <strong>属性定义了元素的哪边上不允许出现浮动元素。</strong> <u>如果声明为左边或右边清除(clear: both;)，会使父元素内部之前添加的伪元素的上外边框边界刚好在浮动元素的下外边距边界之下，使得父元素的高度能够超过浮动元素的高度，从而达到清除浮动的目的</u></p>
<p>&emsp;&emsp;代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box:after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  display: block;</span><br><span class="line">  clear: both;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">  &#x2F;&#x2F; visibility: hidden;</span><br><span class="line">  &#x2F;&#x2F; height: 0;</span><br><span class="line">  &#x2F;&#x2F; font-size: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题外话3-CSS其他知识"><a href="#题外话3-CSS其他知识" class="headerlink" title="题外话3 CSS其他知识"></a>题外话3 CSS其他知识</h2><p>&emsp;&emsp;css模块化有css-in-js的概念，有BEM（block element modifier）命名规范，有less、sass预处理器等方面知识。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML(5)概述</title>
    <url>/2020/09/14/html/HTML-5-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>HTML称为超文本标记语言（Hyper Text Markup Language），用来描述网页文档内容的含义和结构。</p>
<h2 id="1、标记语言和编程语言"><a href="#1、标记语言和编程语言" class="headerlink" title="1、标记语言和编程语言"></a>1、标记语言和编程语言</h2><p>&emsp;&emsp;标记语言，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的文字编码。标记语言是一套标记标签，HTML 文档使用标记标签来描述网页。HTML 文档包含 HTML 标签和纯文本。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释对应的内容。</p>
<p>&emsp;&emsp;编程语言，是一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行为。即编写语言是与计算机进行交互，是计算机执行相应计算的语言。例如Python、C、Java等程序语言。</p>
<h2 id="2、HTML-lt-DOCTYPE-gt"><a href="#2、HTML-lt-DOCTYPE-gt" class="headerlink" title="2、HTML &lt;!DOCTYPE&gt;"></a>2、HTML &lt;!DOCTYPE&gt;</h2><p>&emsp;&emsp;&lt;!DOCTYPE&gt;用来声明浏览器按照那个HTML版本来解析文档。它没有结束标签，对大小写不敏感，要写在文档第一行才有效；否则相当于没有这个声明。当没有这个声明时，支持HTML5的浏览器默认是&lt;!DOCTYPE html&gt;。特别的，HTML4及以前的版本，标记语言基于SGML，在声明HTML版本时，还需要声明DTD（文档类型定义）来告诉浏览器按照那个模式来解析HTML文档。</p>
<h2 id="3、常用标签"><a href="#3、常用标签" class="headerlink" title="3、常用标签"></a>3、常用标签</h2><p>&emsp;&emsp;HTML 标签（也称HTML元素）是由尖括号包围的关键词, 标签通常是成对出现的。标签对中第一个便签是开始标签（开放标签），第二个标签是结束标签（闭合标签）。大多数HTML元素可拥有相应的描述属性，也可与其他HTML元素进行嵌套。<u>HTML标签对大小写不明感，推荐小写。</u></p>
<p>&emsp;&emsp;<u>浏览器会自动地在标题的前后添加空行。</u>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。</p>
<p>&emsp;&emsp;浏览器在显示页面时，会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。代码中的所有连续的换行（br）也被显示为一个空格。</p>
<p>&emsp;&emsp;段落（p）的行数依赖于浏览器窗口的大小。如果调节浏览器窗口的大小，将改变段落中的行数。</p>
<h3 id="1-基础标签"><a href="#1-基础标签" class="headerlink" title="(1) 基础标签"></a>(1) 基础标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;html&gt;</td>
<td>定义HTML文档结构</td>
</tr>
<tr>
<td>&lt;body&gt;</td>
<td>定义文档主体内容</td>
</tr>
<tr>
<td>&lt;h1&gt;…&lt;h6&gt;</td>
<td>定义HTML标题</td>
</tr>
<tr>
<td>&lt;p&gt;</td>
<td>定义段落</td>
</tr>
<tr>
<td>&lt;br&gt;</td>
<td>定义简单的换行（不产生一个新段落的情况下进行换行）</td>
</tr>
<tr>
<td>&lt;hr&gt;</td>
<td>定义水平线</td>
</tr>
</tbody></table>
<h3 id="2-格式化标签"><a href="#2-格式化标签" class="headerlink" title="(2) 格式化标签"></a>(2) 格式化标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;strong&gt;</td>
<td>语气更为强烈的文本（粗体，与b标签表现形式类似）</td>
</tr>
<tr>
<td>&lt;cite&gt;</td>
<td>引用</td>
</tr>
<tr>
<td>&lt;code&gt;</td>
<td>代码文本 ，不保留多余的空格和折行，需要则可与pre标签结合使用</td>
</tr>
<tr>
<td>&lt;del&gt;</td>
<td>定义删除文本（中划线）</td>
</tr>
<tr>
<td>&lt;em&gt;</td>
<td>强调文本（斜体，与i标签表现形式类似）</td>
</tr>
<tr>
<td>&lt;ins&gt;</td>
<td>插入文本（下划线）</td>
</tr>
<tr>
<td>&lt;kbd&gt;</td>
<td>键盘文本</td>
</tr>
<tr>
<td>&lt;mark&gt;</td>
<td>(HTML5新增) 有记号的文本（黄色背景）</td>
</tr>
<tr>
<td>&lt;meter&gt;</td>
<td><u>(HTML5新增) 预定义范围内的度量（进度条形式）</u></td>
</tr>
<tr>
<td>&lt;pre&gt;</td>
<td>(HTML5新增) 预格式文本（特殊符号会被转化为符号实体）</td>
</tr>
<tr>
<td>&lt;progress&gt;</td>
<td>(HTML5新增) 任何类型的任务的进度（进度条）</td>
</tr>
<tr>
<td>&lt;q&gt;</td>
<td>短引用（文本加上双引号）</td>
</tr>
<tr>
<td>&lt;blockquote&gt;</td>
<td>长的引用（文本整体进行缩进）</td>
</tr>
<tr>
<td>&lt;address&gt;</td>
<td>地址（斜体）</td>
</tr>
<tr>
<td>&lt;abbr&gt;</td>
<td>缩写</td>
</tr>
<tr>
<td>&lt;ruby&gt;</td>
<td>(HTML5新增) ruby注释</td>
</tr>
<tr>
<td>&lt;rt&gt;</td>
<td>显示中文注音或字符（嵌套在ruby元素内部）</td>
</tr>
<tr>
<td>&lt;rp&gt;</td>
<td>显示浏览器不支持ruby显示的内容（嵌套在ruby元素内部）</td>
</tr>
<tr>
<td>&lt;small&gt;</td>
<td>小号字体文本</td>
</tr>
<tr>
<td>&lt;sub&gt;</td>
<td>上标文本</td>
</tr>
<tr>
<td>&lt;sup&gt;</td>
<td>下标文本</td>
</tr>
</tbody></table>
<h3 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="(3) 表单标签"></a>(3) 表单标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;form&gt;</td>
<td>定义提供用户输入的HTML表单</td>
</tr>
<tr>
<td>&lt;input&gt;</td>
<td>定义输入控件</td>
</tr>
<tr>
<td>&lt;textarea&gt;</td>
<td>定义多行文本输入控件</td>
</tr>
<tr>
<td>&lt;button&gt;</td>
<td>定义按钮</td>
</tr>
<tr>
<td>&lt;select&gt;</td>
<td>定义下拉选择列表</td>
</tr>
<tr>
<td>&lt;optgroup&gt;</td>
<td>定义下拉列表相关选项组合</td>
</tr>
<tr>
<td>&lt;option&gt;</td>
<td>定义下拉列表中的选项</td>
</tr>
<tr>
<td>&lt;label&gt;</td>
<td>定义input元素标注</td>
</tr>
<tr>
<td>&lt;fieldset&gt;</td>
<td>定义围绕表单中元素的边框</td>
</tr>
<tr>
<td>&lt;legend&gt;</td>
<td>定义fieldset元素标题</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;input常用输入限制属性：</em><br><em>&emsp;&emsp;&emsp;accept、autocomplate、autofocus、value、checked、multiple、readonly、disabled、size、maxlength、min、max、<u>pattern(规定用于验证输入字段的模式，模式指的是正则表达式)</u>、required、size、step、placeholder、width…</em></p>
<p><em>&emsp;&emsp;&emsp;input type取值：</em><br><em>&emsp;&emsp;&emsp; text、password、file、hidden、reset、submit、radio、checkbox、button、number、date、<u>color</u>、range、month、week、time、datetime(IE、Firefox 或者 Chrome 不支持)、datetime-local、email、search、tel、url、<u>image（定义图像形式的按钮）</u>…</em></p>
<h3 id="4-图像标签"><a href="#4-图像标签" class="headerlink" title="(4) 图像标签"></a>(4) 图像标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;img&gt;</td>
<td>定义图像（alt 属性用来为图像定义一串预备的可替换的文本）</td>
</tr>
<tr>
<td><u>&lt;map&gt;</u></td>
<td>定义映射图像</td>
</tr>
<tr>
<td><u>&lt;area&gt;</u></td>
<td>定义图像地图内部区域（嵌套在map元素内部）</td>
</tr>
<tr>
<td>&lt;canvas&gt;</td>
<td>(HTML5新增) 定义图形</td>
</tr>
<tr>
<td>&lt;figure&gt;</td>
<td>(HTML5新增) 定义媒介内容的分组，以及他们的标题</td>
</tr>
<tr>
<td>&lt;figcaption&gt;</td>
<td>(HTML5新增) 定义figure元素的标题</td>
</tr>
</tbody></table>
<h3 id="5-音频视频标签"><a href="#5-音频视频标签" class="headerlink" title="(5) 音频视频标签"></a>(5) 音频视频标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;audio&gt;</td>
<td>(HTML5新增) 定义声音内容</td>
</tr>
<tr>
<td>&lt;source&gt;</td>
<td>(HTML5新增) 定义媒介源（嵌套在audio标签内部）</td>
</tr>
<tr>
<td>&lt;video&gt;</td>
<td>(HTML5新增) 定义视频</td>
</tr>
<tr>
<td><u>&lt;track&gt;</u></td>
<td>(HTML5新增) 定义媒体播放器的文本轨道（嵌套在video标签内部）</td>
</tr>
</tbody></table>
<h3 id="6-链接标签"><a href="#6-链接标签" class="headerlink" title="(6) 链接标签"></a>(6) 链接标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;a&gt;</td>
<td>定义锚</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td>定义文档与外部资源的关系</td>
</tr>
<tr>
<td>&lt;nav&gt;</td>
<td>(HTML5新增) 定义导航链接</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;a标签的常用属性：</em><br><em>&emsp;&emsp;&emsp;1) href 规定链接指向的页面的 URL或者页面某一位置</em><br><em>&emsp;&emsp;&emsp;2) download  (HTML5新增) 使用download，规定被下载的超链接目标名称</em><br><em>&emsp;&emsp;&emsp;3) media (HTML5新增) 规定被链接文档是为何种媒介/设备优化的</em><br><em>&emsp;&emsp;&emsp;4) target 规定在何处打开链接文档</em><br><em>&emsp;&emsp;&emsp;5) type  (HTML5新增) 规定被链接文档的的 MIME 类型</em></p>
<h3 id="7-列表标签"><a href="#7-列表标签" class="headerlink" title="(7) 列表标签"></a>(7) 列表标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;ul&gt;</td>
<td>定义无序列表</td>
</tr>
<tr>
<td>&lt;ol&gt;</td>
<td>定义有序列表</td>
</tr>
<tr>
<td>&lt;li&gt;</td>
<td>定义列表的项目（可嵌套其他HTML元素）</td>
</tr>
<tr>
<td>&lt;dl&gt;</td>
<td>定义列表</td>
</tr>
<tr>
<td>&lt;dt&gt;</td>
<td>定义列表中的项目</td>
</tr>
<tr>
<td>&lt;dd&gt;</td>
<td>定义列表中的项目描述</td>
</tr>
</tbody></table>
<h3 id="8-表格标签"><a href="#8-表格标签" class="headerlink" title="(8) 表格标签"></a>(8) 表格标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;table&gt;</td>
<td>定义表格</td>
</tr>
<tr>
<td>&lt;caption&gt;</td>
<td>定义表格标题</td>
</tr>
<tr>
<td>&lt;th&gt;</td>
<td>定义表格中的表头单元格</td>
</tr>
<tr>
<td>&lt;tr&gt;</td>
<td>定义表格中的行</td>
</tr>
<tr>
<td>&lt;td&gt;</td>
<td>定义表格中的单元格</td>
</tr>
<tr>
<td>&lt;thead&gt;</td>
<td>定义表格中的表头内容</td>
</tr>
<tr>
<td>&lt;tbody&gt;</td>
<td>定义表格中的主体内容</td>
</tr>
<tr>
<td>&lt;tfoot&gt;</td>
<td>定义表格中的表注内容（脚注）</td>
</tr>
<tr>
<td>&lt;col&gt;</td>
<td>定义表格中一个和多个列属性</td>
</tr>
<tr>
<td>&lt;colgroup&gt;</td>
<td>定义表格中供格式化的列组</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;表格标签的常用属性：</em><br><em>&emsp;&emsp;&emsp;1) table border（边框）、background（表格背景）、cellpadding（单元格边距）、cellspacing（单元格间距）、frame（框架-控制表格边框）</em><br><em>&emsp;&emsp;&emsp;2) th/td colspan（跨列）、rowspan（跨行）、background（单元格背景）、align（单元格对齐方式</em><br><em>&emsp;&emsp;&emsp;注: 空的单元格的边框不会显示，可使用空格字符”&amp;nbsp;” 处理没有内容的单元格显示边框；单元格内可嵌套其他HTML元素</em></p>
<h3 id="9-布局标签"><a href="#9-布局标签" class="headerlink" title="(9) 布局标签"></a>(9) 布局标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;style&gt;</td>
<td>定义文档的样式信息</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td>定义资源引用</td>
</tr>
<tr>
<td>&lt;div&gt;</td>
<td>定义文档中的节点，可用于组合其他 HTML 元素的容器（块级元素代表）</td>
</tr>
<tr>
<td>&lt;span&gt;</td>
<td>定义文档中的节点（内联元素代表）</td>
</tr>
<tr>
<td>&lt;header&gt;</td>
<td>(HTML5新增) 定义section或page的页眉</td>
</tr>
<tr>
<td>&lt;footer&gt;</td>
<td>(HTML5新增) 定义section或page的页脚</td>
</tr>
<tr>
<td>&lt;section&gt;</td>
<td>(HTML5新增) 定义section</td>
</tr>
<tr>
<td>&lt;article&gt;</td>
<td>(HTML5新增) 定义文章</td>
</tr>
<tr>
<td>&lt;aside&gt;</td>
<td>(HTML5新增) 定义页面内容之外的内容</td>
</tr>
<tr>
<td>&lt;details&gt;</td>
<td>(HTML5新增) 定义用户可查看或隐藏的额外细节</td>
</tr>
<tr>
<td>&lt;summary&gt;</td>
<td>(HTML5新增) 定义 details 元素的可见标题</td>
</tr>
</tbody></table>
<h3 id="10-元信息标签"><a href="#10-元信息标签" class="headerlink" title="(10) 元信息标签"></a>(10) 元信息标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;head&gt;</td>
<td>定义关于文档的信息</td>
</tr>
<tr>
<td>&lt;meta&gt;</td>
<td>定义HTML文档的元信息（name 和 content 描述页面的内容）</td>
</tr>
<tr>
<td>&lt;base&gt;</td>
<td>定义页面所有链接的默认地址或默认目标</td>
</tr>
</tbody></table>
<h3 id="11-编程标签"><a href="#11-编程标签" class="headerlink" title="(11) 编程标签"></a>(11) 编程标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;script&gt;</td>
<td>定义客户端脚本<u>（HTML5已不支持type属性）</u></td>
</tr>
<tr>
<td>&lt;noscript&gt;</td>
<td>针对不支持脚本的客户端的替代内容（比如提示）</td>
</tr>
<tr>
<td>&lt;embed&gt;</td>
<td>(HTML5新增) 为外部应用（非HTML定义容器，比如插入音频），最好插入的音频的方法：HTML5 audio + embed（或者引入第三方播放器）</td>
</tr>
<tr>
<td>&lt;object&gt;</td>
<td>定义嵌入的对象（支持HTML助手（插件），比如插入视频），最好插入视频的方法：HTML5 video + object + embed</td>
</tr>
<tr>
<td>&lt;param&gt;</td>
<td>定义嵌入对象的参数</td>
</tr>
</tbody></table>
<h3 id="12-框架标签"><a href="#12-框架标签" class="headerlink" title="(12) 框架标签"></a>(12) 框架标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;frameset&gt;</td>
<td>定义框架结构（rows/columns 的值规定了每行或每列占据屏幕的面积）</td>
</tr>
<tr>
<td>&lt;frame&gt;</td>
<td>定义了放置在每个框架中的 HTML 文档（嵌套在frameset元素内部）</td>
</tr>
<tr>
<td>&lt;noframes&gt;</td>
<td>定义不支持frameset客户端的可替换文本</td>
</tr>
<tr>
<td>&lt;iframe&gt;</td>
<td>定义内联的子窗口（框架）</td>
</tr>
</tbody></table>
<h2 id="4、HTML标签属性"><a href="#4、HTML标签属性" class="headerlink" title="4、HTML标签属性"></a>4、HTML标签属性</h2><p>&emsp;&emsp;HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。属性总是以名称/值对的形式出现，属性总是在 HTML 元素的开始标签中规定。HTML标签属性对大小写不明感，推荐小写。</p>
<p>&emsp;&emsp;常用HTML标签属性：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>元素的类名（classname）</td>
</tr>
<tr>
<td>id</td>
<td>元素的唯一 id</td>
</tr>
<tr>
<td>style</td>
<td>元素的行内样式（inline style）</td>
</tr>
<tr>
<td>title</td>
<td>元素的额外信息（可在工具提示中显示）</td>
</tr>
<tr>
<td>contenteditable</td>
<td>(HTML5新增) 元素内容是否可编辑</td>
</tr>
<tr>
<td>data-*</td>
<td>(HTML5新增) 用于存储页面或程序自定义属性数据</td>
</tr>
<tr>
<td>dir</td>
<td>元素中内容的文本方向</td>
</tr>
<tr>
<td>draggable</td>
<td>(HTML5新增) 元素是否可拖动（链接和图像默认是可拖动的）</td>
</tr>
<tr>
<td>hidden</td>
<td>(HTML5新增) 元素仍未或不再相关（浏览器不显示 hidden 属性的元素）</td>
</tr>
<tr>
<td>tabindex</td>
<td>元素的 tab 键选中次序</td>
</tr>
</tbody></table>
<h2 id="5、HTML语义化"><a href="#5、HTML语义化" class="headerlink" title="5、HTML语义化"></a>5、HTML语义化</h2><p>HTML语义化的目的：用更合适的标签做更合适的事情，使文档内容结构化、代码语义化</p>
<p>优点：<br>&emsp;&emsp;(1) 提高代码可读性<br>&emsp;&emsp;(2) 利于浏览器解析与SEO搜索引擎优化<br>&emsp;&emsp;(3) 提高代码可维护性与重用性</p>
<p>提高代码语义化的方法：<br>&emsp;&emsp;(1) 减少使用没有语义的标签，例如div、span等<br>&emsp;&emsp;(2) 减少使用纯样式标签，例如b、i等<br>&emsp;&emsp;(3) 表单使用fieldset包裹；使用legend添加标题；使用label标签为input添加标注<br>&emsp;&emsp;(4) 表格使用caption添加标题，表头部分用thead、主体部分用tbody、脚注部分用tfoot包裹<br>&emsp;&emsp;(5) img元素附带alt信息，即对图片进行文本说明，当图像无法查看时会显示文本描述</p>
<h2 id="6、网站SEO搜索引擎优化"><a href="#6、网站SEO搜索引擎优化" class="headerlink" title="6、网站SEO搜索引擎优化"></a>6、网站SEO搜索引擎优化</h2><p>SEO目的：为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望搜索引擎能多多我们收录网站，并且在别人进行搜索时网站能排列在搜索结果的前面</p>
<p>实现方式：<br>&emsp;&emsp;(1) 提高网站代码的语义化<br>&emsp;&emsp;(2) 重要内容不使用JS输出<br>&emsp;&emsp;(3) 网站的标题（title）进行合理设置<br>&emsp;&emsp;(4) 对关键字、描述精心设计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;...&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h2><h3 id="1-URL-统一资源定位器"><a href="#1-URL-统一资源定位器" class="headerlink" title="(1) URL-统一资源定位器"></a>(1) URL-统一资源定位器</h3><p>&emsp;&emsp;URL （Uniform Resource Locator）也被称为网址，由域名或IP地址、端口、路径等遵循一定的规则形成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename</span><br><span class="line">&#x2F;&#x2F; scheme - 定义因特网服务的类型。常见的类型http、https、ftp、file</span><br><span class="line">&#x2F;&#x2F; host - 定义域主机（http 的默认主机是 www）</span><br><span class="line">&#x2F;&#x2F; domain - 定义因特网域名，比如 w3school.com.cn</span><br><span class="line">&#x2F;&#x2F; :port - 定义主机上的端口号（http 的默认端口号是 80，https的默认端口号443）</span><br><span class="line">&#x2F;&#x2F; path - 定义服务器上的路径</span><br><span class="line">&#x2F;&#x2F; filename - 定义文档&#x2F;资源的名称</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HTML URL 编码：<br>&emsp;&emsp;URL 会将字符转换为可通过因特网传输的格式，只能使用 ASCII 字符集来通过因特网进行发送。编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 编码不能包含空格，通常使用 + 来替换空格。</p>
<h3 id="2-文件路径"><a href="#2-文件路径" class="headerlink" title="(2) 文件路径"></a>(2) 文件路径</h3><p>&emsp;&emsp;文件路径描述了网站文件夹结构中某个文件的位置，文件路径会在链接外部文件时被用到。比如链接网页、图像、视频、样式表、JavaScript等。分为绝对路径（绝对文件路径是指向一个因特网文件的完整 URL）与相对路径（相对路径指向了相对于项目当前页面的文件）。</p>
<h3 id="3-字符实体"><a href="#3-字符实体" class="headerlink" title="(3) 字符实体"></a>(3) 字符实体</h3><p>&emsp;&emsp;在 HTML 中，某些字符是预留的，有特定的含义。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体，用&amp;entity_name（实体名称）或&amp;#entity_number（实体编号）表示。<br>&emsp;&emsp;常用的字符实体：</p>
<table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>实体名称</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td>&amp;nbsp;</td>
<td>&amp;#160;</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt;</td>
<td>&amp;#60;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt;</td>
<td>&amp;#62;</td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td>&amp;quot;</td>
<td>&amp;#34;</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp;</td>
<td>&amp;#38;</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
<td>&amp;times;</td>
<td>&amp;#215;</td>
</tr>
<tr>
<td>/</td>
<td>除号</td>
<td>&amp;divide;</td>
<td>&amp;#247;</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy;</td>
<td>&amp;#169;</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg;</td>
<td>&amp;#174;</td>
</tr>
<tr>
<td>™</td>
<td>商标</td>
<td>&amp;trade;</td>
<td>&amp;#8482;</td>
</tr>
</tbody></table>
<h3 id="4-颜色值"><a href="#4-颜色值" class="headerlink" title="(4) 颜色值"></a>(4) 颜色值</h3><p>&emsp;&emsp; 由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS Map、Set关键字</title>
    <url>/2021/06/10/javascript/JS%20Map%E3%80%81Set%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><u>JavaScript 中Map与Set都是ES6新的数据结构，分别存储数据映射关系与数据集合。</u>Map是类似Object的一种键值对集合，不同与Object，Map的键不仅限于是String或Symbol类型，其他各种类型的值包括对象都可以成为Map的键。Set是类似数组的一种数据结构，不同点在于Set中没有重复的值。</p>
<h2 id="1、Map"><a href="#1、Map" class="headerlink" title="1、Map"></a>1、Map</h2><p>&emsp;&emsp;Map对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>&emsp;&emsp;一个Map对象在迭代时会根据对象中元素的插入顺序来进行一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>
<p><em>&emsp;&emsp;[注] for in 与 for of 语句的区别：</em><br><em>&emsp;&emsp;① for…in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性，为遍历对象属性而构建的，不建议用于迭代一个关注索引顺序的数组，数组可以用 Array.prototype.forEach() 和 for … of</em><br><em>&emsp;&emsp;② for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值迭代处理</em></p>
<p><em>&emsp;&emsp;[注] Map中键 NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。在目前的ECMAScript规范中，-0和+0被认为是相等的。</em></p>
<h3 id="1-Objects-和-maps-的比较"><a href="#1-Objects-和-maps-的比较" class="headerlink" title="1) Objects 和 maps 的比较"></a>1) Objects 和 maps 的比较</h3><p>&emsp;&emsp;Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 是更好的选择:</p>
<table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map 默认情况不包含任何键。只包含显式插入的键</td>
<td>Object 原型链上的可能存在键名与设置的键名产生冲突 <em>(可通过Object.create(null)来创建一个没有原型的对象)</em></td>
</tr>
<tr>
<td>键的类型</td>
<td>Map 的键可以是任意值，包括函数、对象或任意基本类型</td>
<td>Object 的键必须是一个 String 或是Symbol</td>
</tr>
<tr>
<td>键的顺序</td>
<td><u>Map 中的 key 是有序的，迭代时按插入的顺序返回键值</u></td>
<td><u>Object 的键是无序的</u></td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可通过 size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，可直接被迭代</td>
<td>Object需要以某种方式获取它的键然后才能迭代</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好</td>
<td>在频繁添加和删除键值对的场景下未作出优化</td>
</tr>
</tbody></table>
<h3 id="2-Map构造函数"><a href="#2-Map构造函数" class="headerlink" title="2) Map构造函数"></a>2) Map构造函数</h3><p>&emsp;&emsp;Map()：创建 Map 对象(使用new关键字)</p>
<h3 id="3-Map属性"><a href="#3-Map属性" class="headerlink" title="3) Map属性"></a>3) Map属性</h3><p>&emsp;&emsp;Map.length：<u>属性 length 的值为0，想要计算一个 Map 中的条目数量， 使用 Map.prototype.size</u><br>&emsp;&emsp;Map.prototype：表示 Map 构造器的原型。允许添加属性从而应用于所有的 Map 对象</p>
<h3 id="4-Map实例"><a href="#4-Map实例" class="headerlink" title="4) Map实例"></a>4) Map实例</h3><p>&emsp;&emsp;所有的 Map 对象实例都会继承 Map.prototype</p>
<p>&emsp;&emsp;(1) 实例属性<br>&emsp;&emsp;Map.prototype.constructor：返回一个函数，它创建了实例的原型。默认是Map函数<br>&emsp;&emsp;Map.prototype.size：返回Map对象的键/值对的数量</p>
<p>&emsp;&emsp;(2) 实例方法（Map.prototype上的方法）<br>&emsp;&emsp;clear()：移除Map对象的所有键/值对<br>&emsp;&emsp;delete(key)：Map对象中存在该元素，则移除它并返回 true；否则返回false<br>&emsp;&emsp;entries()：返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组<br>&emsp;&emsp;forEach(callbackFn[(value, key), thisArg])：按插入顺序，为Map对象里的每一键值对调用一次&emsp;&emsp;callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值<br>&emsp;&emsp;get(key)：返回键对应的值，如果不存在，则返回undefined<br>&emsp;&emsp;has(key)：返回一个布尔值，表示Map实例是否包含键对应的值<br>&emsp;&emsp;keys()：返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键<br>&emsp;&emsp;<u>set(key, value)：设置Map对象中键的值。返回该Map对象</u><br>&emsp;&emsp;values()：返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 </p>
<p>&emsp;&emsp;简单示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; function a () &#123;&#125;</span><br><span class="line">let maps &#x3D; new Map()</span><br><span class="line">&#x2F;&#x2F; 为maps设置各个类型的键与值</span><br><span class="line">maps.set(123, &#39;123aaa&#39;)</span><br><span class="line">maps.set(a, &#39;aaa&#39;)</span><br><span class="line">maps.set(true, &#39;真值&#39;)</span><br><span class="line">maps.set(NaN, &#39;NaN&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印maps或相关key对应的value值</span><br><span class="line">console.log(maps) &#x2F;&#x2F; Map(4) &#123;123 &#x3D;&gt; &quot;123aaa&quot;, ƒ &#x3D;&gt; &quot;aaa&quot;, true &#x3D;&gt; &quot;真值&quot;, NaN &#x3D;&gt; &quot;NaN&quot;&#125;</span><br><span class="line">console.log(maps.get(a)) &#x2F;&#x2F; aaa</span><br><span class="line">console.log(maps.get(NaN)) &#x2F;&#x2F; NaN</span><br><span class="line">console.log(maps.get(888)) &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for of 遍历map对象</span><br><span class="line">for(const m of maps) &#123;</span><br><span class="line">  console.log(m)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; [123, &quot;123aaa&quot;]</span><br><span class="line">&#x2F;&#x2F; [ƒ, &quot;aaa&quot;]</span><br><span class="line">&#x2F;&#x2F; [true, &quot;真值&quot;]</span><br><span class="line">&#x2F;&#x2F; [NaN, &quot;NaN&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; forEach遍历map对象</span><br><span class="line">maps.forEach((value, key) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(key, value)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; 123 &quot;123aaa&quot;</span><br><span class="line">&#x2F;&#x2F; ƒ a () &#123;&#125; &quot;aaa&quot;</span><br><span class="line">&#x2F;&#x2F; true &quot;真值&quot;</span><br><span class="line">&#x2F;&#x2F; NaN &quot;NaN&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span><br><span class="line">const map2 &#x3D; new Map([[123, &#39;aaaa&#39;],[false, &#39;假值&#39;], [undefined, &#39;undefined&#39;]])</span><br><span class="line">console.log(map2) &#x2F;&#x2F; &#123;123 &#x3D;&gt; &quot;aaaa&quot;, false &#x3D;&gt; &quot;假值&quot;, undefined &#x3D;&gt; &quot;undefined&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的</span><br><span class="line">const map3 &#x3D; new Map([...maps, ...map2])</span><br><span class="line">console.log(map3) &#x2F;&#x2F; &#123;123 &#x3D;&gt; &quot;aaaa&quot;, ƒ &#x3D;&gt; &quot;aaa&quot;, true &#x3D;&gt; &quot;真值&quot;, NaN &#x3D;&gt; &quot;NaN&quot;, false &#x3D;&gt; &quot;假值&quot;, …&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问map对象的size属性</span><br><span class="line">console.log(map3.size) &#x2F;&#x2F; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除maps对象中的键值对</span><br><span class="line">console.log(maps.delete(123)) &#x2F;&#x2F; true</span><br><span class="line">console.log(maps) &#x2F;&#x2F; &#123;ƒ &#x3D;&gt; &quot;aaa&quot;, true &#x3D;&gt; &quot;真值&quot;, NaN &#x3D;&gt; &quot;NaN&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>利用Map对象，可根据存储的数据映射关系对相应key值进行快速查询操作</strong></p>
<h2 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h2><p>&emsp;&emsp;Set对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的</p>
<h3 id="1-Set构造函数"><a href="#1-Set构造函数" class="headerlink" title="1) Set构造函数"></a>1) Set构造函数</h3><p>&emsp;&emsp;Set()：创建一个新的Set对象(使用new关键字)</p>
<h3 id="2-Set属性"><a href="#2-Set属性" class="headerlink" title="2) Set属性"></a>2) Set属性</h3><p>&emsp;&emsp;Set.length：<u>属性 length 的值为0，想要计算一个 Set 中的条目数量， 使用 Set.prototype.size</u><br>&emsp;&emsp;Set.prototype：表示 Set 构造器的原型。允许添加属性从而应用于所有的 Set 对象</p>
<h3 id="3-Set实例"><a href="#3-Set实例" class="headerlink" title="3) Set实例"></a>3) Set实例</h3><p>&emsp;&emsp;所有的 Set 对象实例都会继承 Set.prototype</p>
<p>&emsp;&emsp;(1) 实例属性<br>&emsp;&emsp;Set.prototype.size：返回Set对象值的数量</p>
<p>&emsp;&emsp;(2) 实例方法（Set.prototype上的方法）<br>&emsp;&emsp;add(value)：在Set对象尾部添加一个元素。返回该Set对象<br>&emsp;&emsp;clear()：移除Set对象内的所有元素<br>&emsp;&emsp;delete(value)：移除Set中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值。如果该元素存在，返回true，否则返回false<br>&emsp;&emsp;entries()：返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似，每个值的键和值相等<br>&emsp;&emsp;forEach(callbackFn[, thisArg])：按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数<br>&emsp;&emsp;has(value)：返回一个布尔值，表示该值在Set中存在与否<br>&emsp;&emsp;values()：返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值</p>
<p>&emsp;&emsp;简单示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; function a() &#123; &#125;</span><br><span class="line">let sets &#x3D; new Set()</span><br><span class="line">&#x2F;&#x2F; 为Set对象设置不同类型的值</span><br><span class="line">sets.add(123)</span><br><span class="line">sets.add(a)</span><br><span class="line">sets.add(true)</span><br><span class="line">sets.add(NaN)</span><br><span class="line">console.log(sets) &#x2F;&#x2F; &#123;123, ƒ, true, NaN&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给Set对象添加相同的值(无效：Set对象中的元素是唯一的)</span><br><span class="line">sets.add(123)</span><br><span class="line">sets.add(a)</span><br><span class="line">sets.add(true)</span><br><span class="line">console.log(sets) &#x2F;&#x2F; &#123;123, ƒ, true, NaN&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除Set中的元素</span><br><span class="line">sets.delete(123)</span><br><span class="line">console.log(sets) &#x2F;&#x2F; &#123;ƒ, true, NaN&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 for of 迭代Set对象</span><br><span class="line">for (const item of sets) &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 forEach 迭代Set对象</span><br><span class="line">sets.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组与Set相互转换</span><br><span class="line">const set2 &#x3D; new Set([1, 2, 3, 4, 2, 4]) &#x2F;&#x2F; 将数组转换为Set对象，由于Set对象值的唯一性，Set对象中已无重复的值</span><br><span class="line">console.log(set2) &#x2F;&#x2F; &#123;1, 2, 3, 4&#125;</span><br><span class="line">console.log([...set2]) &#x2F;&#x2F; [1, 2, 3, 4] &#x2F;&#x2F; 可以通过Set进行数组去重~</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>利用Set对象，可实现基本集合操作，比如求交集、并集、差集等</strong></p>
<h3 id="注-JavaScript-中的相等性判断"><a href="#注-JavaScript-中的相等性判断" class="headerlink" title="[注] JavaScript 中的相等性判断"></a>[注] JavaScript 中的相等性判断</h3><p>&emsp;&emsp;(1) ES2015中有四种相等算法：<br>&emsp;&emsp;① 抽象（非严格）相等比较(==)<br>&emsp;&emsp;② 严格相等比较(===)，用于  Array.prototype.indexOf, Array.prototype.lastIndexOf, 和 case-matching<br>&emsp;&emsp;③ 同值零，用于 %TypedArray% 和 ArrayBuffer 构造函数、以及Map和Set操作, 并将用于 ES2016/ES7 中的String.prototype.includes</p>
<p><em>&emsp;&emsp;ES5 比较两个值是否相等,只有两个运算符：抽象相等运算符和严格相等运算符。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及-0 等于 +0。JavaScript缺乏一种运算,在所有环境中,使得只要两个值是一样的,它们就应该相等。ES6提出“Same-value equality”(同值相等)算法，用来解决这个问题。</em></p>
<p>&emsp;&emsp;④ 同值，用于所有其他地方</p>
<p>&emsp;&emsp;(2) JavaScript提供三种不同的值比较操作：<br>&emsp;&emsp;① 严格相等比较，使用 ===<br>&emsp;&emsp;② 抽象相等比较,使用 ==<br>&emsp;&emsp;③ Object.is （ECMAScript 2015/ ES6 新特性，有特殊用途）</p>
<p>&emsp;&emsp;抽象相等比较将执行类型转换; 严格相等比较将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ); 而Object.is的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理不相同，Object.is（+0，-0）将为 false，而Object.is（NaN，NaN）将为 true。</p>
<p>&emsp;&emsp;(3) 不同判等模型的判等结果：</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>==</th>
<th>===</th>
<th>Object.is</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>undefined</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>“foo”</td>
<td>“foo”</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>+0</td>
<td>-0</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“”</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“”</td>
<td>0</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“0”</td>
<td>0</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“1”</td>
<td>1</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>[1,2]</td>
<td>“1,2”</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>“foo”</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>undefined</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>undefined</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>{ foo: “bar” }</td>
<td>{ foo: “bar” }</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>new String(“foo”)</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>null</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“foo”</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS Proxy、Reflect与@Decorator</title>
    <url>/2021/06/22/javascript/JS%20Proxy%E3%80%81Reflect%E4%B8%8E@Decorator/</url>
    <content><![CDATA[<h2 id="1、Proxy关键字"><a href="#1、Proxy关键字" class="headerlink" title="1、Proxy关键字"></a>1、Proxy关键字</h2><p>&emsp;&emsp;Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等），即进行数据劫持</p>
<p>&emsp;&emsp;使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; new Proxy(target, handler)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中的参数：</p>
<p>&emsp;&emsp;target：指要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）<br>&emsp;&emsp;handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为</p>
<h3 id="Proxy-handler"><a href="#Proxy-handler" class="headerlink" title="Proxy handler"></a>Proxy handler</h3><p>&emsp;&emsp;handler 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。标准的捕捉器如下：<br>&emsp;&emsp;▪ getPrototypeOf()：Object.getPrototypeOf 方法的捕捉器（返回指定对象的原型，内部[[Prototype]]属性的值）<br>&emsp;&emsp;▪ setPrototypeOf()：Object.setPrototypeOf 方法的捕捉器（设置一个指定的对象的原型 到另一个对象或null）<br>&emsp;&emsp;▪ isExtensible()：Object.isExtensible 方法的捕捉器（判断对象是否是可拓展的）<br>&emsp;&emsp;▪ preventExtensions()：Object.preventExtensions 方法的捕捉器（让一个对象变为不可扩展，也就是永远不能再添加新的属性）<br>&emsp;&emsp;▪ getOwnPropertyDescriptor()：Object.getOwnPropertyDescriptor 方法的捕捉器（返回指定对象上一个自有属性对应的属性描述符）<br>&emsp;&emsp;▪ defineProperty()：Object.defineProperty 方法的捕捉器（在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象，也可进行数据劫持）<br>&emsp;&emsp;▪ has()：in 操作符的捕捉器<br>&emsp;&emsp;▪ get()：属性读取操作的捕捉器<br>&emsp;&emsp;▪ set()：属性设置操作的捕捉器<br>&emsp;&emsp;▪ deleteProperty()：delete 操作符的捕捉器<br>&emsp;&emsp;▪ ownKeys()：Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器<br>&emsp;&emsp;▪ apply()：函数调用操作的捕捉器<br>&emsp;&emsp;▪ construct()：new 操作符的捕捉器</p>
<p>&emsp;&emsp;简单示例代码：</p>
<p>&emsp;&emsp;① Proxy代理对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; new Proxy(&#123; name: &#39;xg&#39;&#125;, &#123;</span><br><span class="line">  get (target, property, receiver) &#123;</span><br><span class="line">    console.log(&#96;访问了$&#123;JSON.stringify(target)&#125;的$&#123;property&#125;属性，值为$&#123;target[property]&#125;&#96;)</span><br><span class="line">    return target[property]</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, property, value, receiver) &#123;</span><br><span class="line">    target[property] &#x3D; value</span><br><span class="line">    console.log(&#96;设置了$&#123;JSON.stringify(target)&#125;的$&#123;property&#125;属性，赋值值为$&#123;value&#125;&#96;)</span><br><span class="line">  &#125;,</span><br><span class="line">  has (target, property) &#123;</span><br><span class="line">    console.log(&#96;使用in关键字判断了$&#123;JSON.stringify(target)&#125;对象是否存在$&#123;property&#125;属性，结果为$&#123;target[property] !&#x3D;&#x3D; undefined&#125;&#96;)</span><br><span class="line">    return target[property] !&#x3D;&#x3D; undefined</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty (target, property) &#123;</span><br><span class="line">    delete target[property]</span><br><span class="line">    console.log(&#96;删除了$&#123;JSON.stringify(target)&#125;的$&#123;property&#125;属性&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.age &#x3D; 24</span><br><span class="line">console.log(&#39;age&#39; in p)</span><br><span class="line">console.log(p)</span><br><span class="line">console.log(p.name)</span><br><span class="line">delete p.age</span><br><span class="line">console.log(p)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; 设置了&#123;&quot;name&quot;:&quot;xg&quot;,&quot;age&quot;:24&#125;的age属性，赋值值为24</span><br><span class="line">&#x2F;&#x2F; 使用in关键字判断了&#123;&quot;name&quot;:&quot;xg&quot;,&quot;age&quot;:24&#125;对象是否存在age属性，结果为true</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; Proxy &#123;name: &quot;xg&quot;, age: 24&#125;</span><br><span class="line">&#x2F;&#x2F; 访问了&#123;&quot;name&quot;:&quot;xg&quot;,&quot;age&quot;:24&#125;的name属性，值为xg</span><br><span class="line">&#x2F;&#x2F; xg</span><br><span class="line">&#x2F;&#x2F; 删除了&#123;&quot;name&quot;:&quot;xg&quot;&#125;的age属性</span><br><span class="line">&#x2F;&#x2F; Proxy &#123;name: &quot;xg&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;② Proxy代理function函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const A &#x3D; new Proxy(function (list)  &#123;</span><br><span class="line">  [this.name, this.age] &#x3D; list</span><br><span class="line">  this.sayHello &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;你好，我是$&#123;this.name&#125;，今年$&#123;this.age&#125;岁了&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  construct (target, argumentsList) &#123;</span><br><span class="line">    console.log(&#39;对A使用了new关键字&#39;)</span><br><span class="line">    return new target(argumentsList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const a &#x3D; new A(&#39;xg&#39;, 5)</span><br><span class="line">console.log(a)</span><br><span class="line">a.sayHello()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; 对A使用了new关键字</span><br><span class="line">&#x2F;&#x2F; Proxy.construct &#123;name: &quot;xg&quot;, age: 5, sayHello: ƒ&#125;</span><br><span class="line">&#x2F;&#x2F;你好，我是xg，今年5岁了</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;③ Proxy代理class类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const f &#x3D; new Proxy(class Person&#123;</span><br><span class="line">  constructor(list) &#123;</span><br><span class="line">    [this.name, this.age, this.sex] &#x3D; list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  construct (target, argumentsList) &#123;</span><br><span class="line">    console.log(&#39;对f使用了new关键字&#39;)</span><br><span class="line">    return new target(argumentsList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const f2 &#x3D; new f(&#39;xionggang&#39; , &#39;24&#39;, &#39;男&#39;)</span><br><span class="line">console.log(f2)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; 对f使用了new关键字</span><br><span class="line">&#x2F;&#x2F; Person &#123;name: &quot;xionggang&quot;, age: &quot;24&quot;, sex: &quot;男&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] <u>Proxy与Object.defineProperty的区别</u>：</em><br><em>&emsp;&emsp;Proxy与Object.defineProperty都能实现数据劫持。Object.defineProperty 只能监听对象的属性,因此我们需要对每个对象的每个属性进行遍历（甚至深层遍历嵌套的对象），不能监听数组的变化，也不能对ES6新产生的 Map,Set 这些数据结构做出监听。Proxy可以直接监听整个对象而非属性，可以直接监听数组的变化，有更多的拦截方法，如ownKeys、deleteProperty、has等。</em></p>
<h2 id="2、Reflect关键字"><a href="#2、Reflect关键字" class="headerlink" title="2、Reflect关键字"></a>2、Reflect关键字</h2><p>&emsp;&emsp;Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的<u>静态方法</u>。<strong>这些方法与 <a href="/2021/06/22/javascript/JS%20Proxy%E3%80%81Reflect%E4%B8%8E@Decorator/#Proxy-handler">proxy handlers</a> 的方法相同</strong>。Reflect不是一个函数对象，因此它是不可构造的（不能通过new运算符对其进行调用）。<strong>Reflect的所有属性和方法都是<u>静态方法</u></strong>（就如Math对象一样）</p>
<p><em>&emsp;&emsp;[注] 静态方法与非静态方法：</em><br><em>&emsp;&emsp;静态方法：使用 static 关键字修饰的方法，又叫类方法，属于类不属于对象。可以在实例化前直接通过类名进行调用（生命周期与类的生命周期相同）</em><br><em>&emsp;&emsp;非静态方法：不含有 static 关键字修饰的普通方法，又称为实例方法，成员方法。属于对象的，而不属于类，需要实例化后通过实例进行调用（生命周期与类实例的生命周期相同）</em></p>
<h3 id="Reflect-静态方法"><a href="#Reflect-静态方法" class="headerlink" title="Reflect 静态方法"></a>Reflect 静态方法</h3><p>&emsp;&emsp;▪ apply(target, thisArgument, argumentsList)：<br>&emsp;&emsp;对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似<br>&emsp;&emsp;▪ construct(target, argumentsList[, newTarget])：<br>&emsp;&emsp;对构造函数进行 new 操作，相当于执行 new target(…args)<br>&emsp;&emsp;▪ deleteProperty(target, propertyKey)：<br>&emsp;&emsp;作为函数的delete操作符，相当于执行 delete target[name]<br>&emsp;&emsp;▪ get(target, propertyKey[, receiver])：<br>&emsp;&emsp;获取对象身上某个属性的值，类似于 target[name]<br>&emsp;&emsp;▪ set(target, propertyKey, value[, receiver])：<br>&emsp;&emsp;将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true<br>&emsp;&emsp;▪ getPrototypeOf(target)：<br>&emsp;&emsp;类似于 Object.getPrototypeOf()<br>&emsp;&emsp;▪ has(target, propertyKey)：<br>&emsp;&emsp;判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同<br>&emsp;&emsp;▪ isExtensible(target)：<br>&emsp;&emsp;类似于 Object.isExtensible()<br>&emsp;&emsp;▪ ownKeys(target)：<br>&emsp;&emsp;返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响)<br>&emsp;&emsp;▪ setPrototypeOf(target, prototype)：<br>&emsp;&emsp;设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回true</p>
<p>&emsp;&emsp;简单示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const classObj &#x3D; &#123; school: &#39;华阳中学&#39; , className: &#39;高三7班&#39;, session: &#39;2019届&#39; &#125;</span><br><span class="line">const studentA &#x3D; Object.create(classObj)</span><br><span class="line">console.log(studentA) &#x2F;&#x2F; &#123; __proto__: &#123; className: &quot;高三7班&quot;, school: &quot;华阳中学&quot; , session: &quot;2019届&quot; &#125;&#125;</span><br><span class="line">console.log(Reflect.has(studentA, &#39;school&#39;)) &#x2F;&#x2F; true</span><br><span class="line">Reflect.set(studentA, &#39;name&#39;, &#39;xionggang&#39;)</span><br><span class="line">Reflect.set(studentA, &#39;age&#39;, &#39;24&#39;)</span><br><span class="line">Reflect.set(studentA, &#39;sex&#39;, &#39;男&#39;)</span><br><span class="line">console.log(studentA) &#x2F;&#x2F; &#123; name: &quot;xionggang&quot;, age: &quot;24&quot;, sex: &quot;男&quot;, __proto__: &#123; className: &quot;高三7班&quot;, school: &quot;华阳中学&quot; , session: &quot;2019届&quot; &#125;&#125;</span><br><span class="line">console.log(Reflect.ownKeys(studentA)) &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;]</span><br><span class="line">console.log(Reflect. getPrototypeOf(studentA)) &#x2F;&#x2F; &#123;school: &quot;华阳中学&quot;, className: &quot;高三7班&quot;, session: &quot;2019届&quot;&#125;</span><br><span class="line">Reflect.deleteProperty(studentA, &#39;age&#39;)</span><br><span class="line">Reflect.deleteProperty(studentA, &#39;age&#39;)</span><br><span class="line">console.log(studentA) &#x2F;&#x2F; &#123; name: &quot;xionggang&quot;, sex: &quot;男&quot;, __proto__: &#123; className: &quot;高三7班&quot;, school: &quot;华阳中学&quot; , session: &quot;2019届&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、-Decorator（ES7-装饰器语法糖）"><a href="#3、-Decorator（ES7-装饰器语法糖）" class="headerlink" title="3、@Decorator（ES7 装饰器语法糖）"></a>3、@Decorator（ES7 装饰器语法糖）</h2><p>&emsp;&emsp;装饰器是最新的 ECMA 中的一个<u>提案</u>，是一种与类、函数或对象相关的语法，用来注释或修改(增强)类和类方法等</p>
<p>&emsp;&emsp;简单使用（给ClassA类添加日志装饰器）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@log</span><br><span class="line">class ClassA&#123;&#125;</span><br><span class="line">function log (target) &#123;</span><br><span class="line">  target.prototype.logger &#x3D; () &#x3D;&gt; &#96;$&#123;target.name&#125;被调用了&#96;</span><br><span class="line">&#125;</span><br><span class="line">const instance &#x3D; new ClassA()</span><br><span class="line">instance.logger() &#x2F;&#x2F; classA被调用了</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 在使用ES7装饰器模块目前需要引入babel模块的 transform-decorators-legacy 库将代码转换为ES5或ES6运行。<u>ES7的装饰器 decorator 是依赖于 ES5 的 Object.defineProperty 方法</u></em></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS modules模块化、按需引入</title>
    <url>/2021/07/29/javascript/JS%20modules%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<p>一种将 JavaScript 程序拆分为可按需导入的单独模块的机制。<br>ES6 Module 的基本特征：<br>(1) 模块化，可重用<br>(2) 封装了变量和function，和全局的namaspace不接触，松耦合<br>(3) 只暴露可用公用(public)的方法，其它私有方法全部隐藏</p>
<h2 id="1、前端模块化的意义"><a href="#1、前端模块化的意义" class="headerlink" title="1、前端模块化的意义"></a>1、前端模块化的意义</h2><p>&emsp;&emsp;说到模块化，首先想到的是将不同的逻辑写在不同的js文件中。假设在index.html依次引入两个学生了tom.js、jack.js。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;tom.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;jack.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;tom.js、jack.js中的内容分别为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; tom.js</span><br><span class="line">var name &#x3D; &#39;tom&#39;</span><br><span class="line">var age &#x3D; 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; jack.js</span><br><span class="line">var name &#x3D; &#39;jack&#39;</span><br><span class="line">var age &#x3D; 8</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行index.html，在浏览器控制台输出tom的信息，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出为：我的名字叫jack 我今年8岁 </p>
<p>&emsp;&emsp;tom.js、jack.js定义的变量全部都运行在全局作用域中。模块化首先带来了<u>变量被覆盖</u>的问题，如何解决？于是引入了<u>命名空间</u>的概念（变量覆盖的问题可以使用ES6 中的let/const定义变量来解决，let/const有块级作用域的概念）  </p>
<p>&emsp;&emsp;修改tom.js、jack.js，给他们加上不同的命名空间:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; tom.js</span><br><span class="line">var tom &#x3D; &#123;</span><br><span class="line">  name: &#39;tom&#39;,</span><br><span class="line">  age: 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; jack.js</span><br><span class="line">var jack &#x3D; </span><br><span class="line">  name: &#39;jack&#39;,</span><br><span class="line">  age: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重新运行index.html，在浏览器控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;我的名字叫&#39; + tom.name, &#39;我今年&#39; + tom.age + &#39;岁&#39;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出：我的名字叫tom 我今年5岁 </p>
<p>&emsp;&emsp;好像没问题，但如果不小心jack.js写成了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; jack.js</span><br><span class="line">var jack &#x3D; </span><br><span class="line">  name: &#39;jack&#39;,</span><br><span class="line">  age: 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tom.age &#x3D; 10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重新运行index.html，在浏览器控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;我的名字叫&#39; + tom.name, &#39;我今年&#39; + tom.age + &#39;岁&#39;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出：我的名字叫tom 我今年8岁</p>
<p>&emsp;&emsp;哎，又出问题了，虽然用了命名空间，但是也不能保证<u>变量其他文件被修改</u>，如何解决呢？于是这里要引入<u>作用域私有化变量</u>的概念，只是想输出学生的信息，而不想学生信息在外面被修改，那继续修改tom.js、jack.js，用函数包裹学生信息并返回一个tell方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; tom.js</span><br><span class="line">var tom &#x3D; (function ()&#123;</span><br><span class="line">  var name &#x3D; &#39;tom&#39;</span><br><span class="line">  var age &#x3D; 5</span><br><span class="line">  return &#123;</span><br><span class="line">    tell: function() &#123;</span><br><span class="line">      console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; jack.js</span><br><span class="line">var jack &#x3D; (function ()&#123;</span><br><span class="line">  var name &#x3D; &#39;jack&#39;</span><br><span class="line">  var age &#x3D; 8</span><br><span class="line">  return &#123;</span><br><span class="line">    tell: function() &#123;</span><br><span class="line">      console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重新运行index.html,在浏览器控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tom.tell()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出：我的名字叫tom 我今年5岁 </p>
<p>&emsp;&emsp;在jack.js或在控制台里，也无法访问到tom的name或age（自由变量）信息，现在tom与jack的学生信息是安全的，继续把tom.js标准化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; tom.js</span><br><span class="line">(function (window)&#123;</span><br><span class="line">  var name &#x3D; &#39;tom&#39;</span><br><span class="line">  var age &#x3D; 5</span><br><span class="line">  function tell() &#123;</span><br><span class="line">    console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  window.tom &#x3D; &#123; tell &#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码便是<u>早期模块化的一种标准写法，使用自执行函数封装逻辑并挂载到window对象</u><br>&emsp;&emsp;模块化具有<strong>作用域封装私有化内部变量、重用性提高代码复用、低耦合编译代码维护</strong>的优点</p>
<h2 id="2、模块化的进化史"><a href="#2、模块化的进化史" class="headerlink" title="2、模块化的进化史"></a>2、模块化的进化史</h2><p>&emsp;&emsp;前端模块化主要经历了上面的自执行函数，再到AMD、CommonJS、ES Module这几个阶段</p>
<h3 id="1-AMD"><a href="#1-AMD" class="headerlink" title="1) AMD"></a>1) AMD</h3><p>&emsp;&emsp;AMD是一种异步模块定义的实现技术，浏览器不支持，需要用到实现AMD模式浏览器兼容的一个第三方库require.js，我们在index.html中引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;requirejs.org&#x2F;docs&#x2F;release&#x2F;2.3.3&#x2F;minified&#x2F;require.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>添加一个bob学生。bob.js使用AMD模块定义的方式实现，在index.html中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bob.js</span><br><span class="line">define(function() &#123;</span><br><span class="line">  var name &#x3D; &#39;bob&#39;</span><br><span class="line">  var age &#x3D; &#39;6&#39;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  require([&#39;bob&#39;], function(tell)&#123;</span><br><span class="line">    tell()</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在bob.js中定义了一个匿名模块，返回了一个匿名函数，在index.html里加载这个bob模块，并在回调函数中使用tell接收匿名函数并执行。运行index.html</p>
<p>&emsp;&emsp;可以看到控制台输出：我的名字叫bob 我今年6岁  </p>
<p>&emsp;&emsp;ADM模块还可以定义具名模块，定义模块可以指明依赖，并且模块处理返回函数，还可以直接返回其他数据结构，如返回一个对象、Number、String等，语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define([id], [dependencies], factory)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ADM模块化方式虽然require时能异步加载，但定义模块时需要显示的指明依赖的模块，在实际开发中提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅，已经被很少使用</p>
<h3 id="2-CommonJS"><a href="#2-CommonJS" class="headerlink" title="2) CommonJS"></a>2) CommonJS</h3><p>&emsp;&emsp;CommonJS是另一种模块化一种规范，NodeJS的模块化就是基于这种规范实现的。浏览器也不支持CommonJS格式，缺少module、exports、require、global等这几个环境变量。浏览器无法直接使用npm模块，因为这些模块基于CommonJS。要在浏览器中使用CommonJS，可以使用Browserify这个库将CommonJS代码转换成浏览器能执行的js代码</p>
<p><img src="/images/javascript/browserify.png" alt="browserify"></p>
<p>&emsp;&emsp;在电脑cmd窗口全局安装Browserify：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g browserify</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;修改jack.js为Common.js规范，并创建main.js里使用该规范输出jack的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; jack.js</span><br><span class="line">module.exports &#x3D; function() &#123;</span><br><span class="line">  var name &#x3D; &#39;jack&#39;</span><br><span class="line">  var age &#x3D; 8</span><br><span class="line">  console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.js</span><br><span class="line">const jack &#x3D; require(&quot;.&#x2F;jack&quot;)</span><br><span class="line">jack()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果直接在index.html引入main.js，浏览器肯定会报 require is not defined这样的错误，我们需要先使用Browserify转化代码，在项目根目录下打开电脑cmd窗口，执行Browserify工具对代码进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browserify main.js -o bundle.js</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行完成，在项目根目录生成了bundle.js文件，在index.html中引入bundle.js，重新执行index.html</p>
<p>&emsp;&emsp;可以看到控制台输出：我的名字叫jack 我今年8岁  </p>
<p>&emsp;&emsp;打开bundle.js，可以看到编译后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;function r(e,n,t)&#123;function o(i,f)&#123;if(!n[i])...</span><br><span class="line">  module.exports &#x3D; function() &#123;</span><br><span class="line">    var name &#x3D; &#39;jack&#39;</span><br><span class="line">    var age &#x3D; 8</span><br><span class="line">    console.log(&#39;我的名字叫&#39; + name, &#39;我今年&#39; + age + &#39;岁&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,&#123;&#125;],2:[function(require,module,exports)&#123;</span><br><span class="line">  var jack &#x3D; require(&quot;.&#x2F;jack&quot;)</span><br><span class="line">  jack()</span><br><span class="line">  console.log(jack.name)</span><br><span class="line">&#125;,&#123;&quot;.&#x2F;jack&quot;:1&#125;]&#125;,&#123;&#125;,[2]);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;CommonJS模块加载方式是同步的，更适合在服务端使用，不适合使用在浏览器环境中，因为同步加载阻塞浏览器加载其他资源造成不好的用户体验。在Nodejs中可以直接使用CommonJS规范，Nodejs是支持的</p>
<h2 id="3、ES6原生支持模块化"><a href="#3、ES6原生支持模块化" class="headerlink" title="3、ES6原生支持模块化"></a>3、ES6原生支持模块化</h2><p>&emsp;&emsp;ES6的模块化的支持，完成了将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来的编码需求。ES6模块是<u>编译时加载</u>，能对代码进行静态分析与优化。通过<u>export</u>命令用于规定模块的对外接口，<u>import</u>命令用于引入其他模块提供的功能。export，import命令可以出现在模块顶层的任何位置(位于块及作用于中无法静态优化，系统会报错SyntaxError错误)</p>
<h3 id="1-export关键字"><a href="#1-export关键字" class="headerlink" title="1) export关键字"></a>1) export关键字</h3><p>&emsp;&emsp;ES6的模块自动采用<u>严格模式</u>，一个模块就是一个独立的文件</p>
<p><em>&emsp;&emsp;[注] ES5 中的严格模式限制：</em><br><em>&emsp;&emsp;变量必须声明后再使用</em><br><em>&emsp;&emsp;函数的参数不能有同名属性，否则报错</em><br><em>&emsp;&emsp;不能使用with语句</em><br><em>&emsp;&emsp;不能对只读属性赋值，否则报错</em><br><em>&emsp;&emsp;不能使用前缀0表示八进制数，否则报错</em><br><em>&emsp;&emsp;不能删除不可删除的属性，否则报错</em><br><em>&emsp;&emsp;不能删除变量delete prop，会报错，只能删除属性delete global[prop]</em><br><em>&emsp;&emsp;eval不会在它的外层作用域引入变量</em><br><em>&emsp;&emsp;eval和arguments不能被重新赋值</em><br><em>&emsp;&emsp;arguments不会自动反映函数参数的变化</em><br><em>&emsp;&emsp;不能使用arguments.callee</em><br><em>&emsp;&emsp;不能使用arguments.caller</em><br><em>&emsp;&emsp;禁止this指向全局对象</em><br><em>&emsp;&emsp;不能使用fn.caller和fn.arguments获取函数调用的堆栈</em><br><em>&emsp;&emsp;增加了保留字（比如protected、static和interface）</em>  </p>
<p>&emsp;&emsp;ES6的模块文件内部的所有变量，外部无法获取。希望外部能够读取模块内部的某个变量，须使用export关键字输出该变量。export命令必须与模块内部的变量建立一一对应关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; module.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法1：分别暴露接口</span><br><span class="line">export const twoTimes &#x3D; (arr, times &#x3D; 2) &#x3D;&gt; &#123;</span><br><span class="line">  return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const threeTimes &#x3D; (arr, times &#x3D; 3) &#x3D;&gt; &#123;</span><br><span class="line">  return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法2：统一暴露接口</span><br><span class="line">const twoTimes &#x3D; (arr, times &#x3D; 2) &#x3D;&gt; &#123;</span><br><span class="line">  return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const threeTimes &#x3D; (arr, times &#x3D; 3) &#x3D;&gt; &#123;</span><br><span class="line">  return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; twoTimes, threeTimes &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用，type&#x3D;&quot;module&quot;时浏览器会异步加载模块，不会造成页面阻塞：</span><br><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import &#123; twoTimes, threeTimes &#125; from &#39;.&#x2F;module.js&#39;</span><br><span class="line"></span><br><span class="line">  console.log(twoTimes([1,2,3,4])) &#x2F;&#x2F; [2, 4, 6, 8]</span><br><span class="line">  console.log(threeTimes([1,2,3,4])) &#x2F;&#x2F; [2, 4, 6, 8]</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-export-default关键字"><a href="#2-export-default关键字" class="headerlink" title="2) export default关键字"></a>2) export default关键字</h3><p>&emsp;&emsp;可以看到，上面2种暴露接口的方式，在import引入时一般来说需要知道要知道的函数名和变量名。为了方便开发，export default命令可为模块暴露默认输出，其他模块加载该模块时，import命令可以为该函数名和变量名指定任意名字（使用了export default，就算暴露出的函数有名字，也会被当做匿名函数处理）。需要注意的是，一个模块只能有一个默认输出，因此export default命令只能使用一次。且在使用import命令时后面才不用加大括号，因为只可能对应一个函数或变量。此外，export default还可以输出默认值！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法3：默认暴露一个接口</span><br><span class="line">const twoTimes &#x3D; (arr, times &#x3D; 2) &#x3D;&gt; &#123;</span><br><span class="line">  return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default twoTimes</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用：</span><br><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import twoTimes from &#39;.&#x2F;module.js&#39;</span><br><span class="line"></span><br><span class="line">  console.log(twoTimes([1,2,3,4])) &#x2F;&#x2F; [2, 4, 6, 8]</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于默认暴露定义函数名称没有太大意义，我们可以优化代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法3（优化）：默认暴露一个接口</span><br><span class="line">export default (arr, times &#x3D; 2) &#x3D;&gt; &#123;</span><br><span class="line">  return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-import关键字"><a href="#3-import关键字" class="headerlink" title="3) import关键字"></a>3) import关键字</h3><p>&emsp;&emsp;import命令具有提升效果，会提升到整个模块的头部，首先执行。<u>import命令是编译阶段执行的，在代码运行之前，所以不能使用表达式和变量</u>。在引入默认暴露的接口是，不需要使用花括号进行解构赋值。如果多次重复执行同一句import语句，只会执行一次</p>
<p>&emsp;&emsp;特别的，在import获取接口时，可以使用as关键字进行重命名。也可以使用*(星号)进行模块整体加载，即指定一个对象，所有输出值都加载在这个对象上面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import &#123;twoTimes as tool&#125; from &#39;.&#x2F;module.js&#39;</span><br><span class="line"></span><br><span class="line">  console.log(tool)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 输出：</span><br><span class="line">  &#x2F;&#x2F; (arr, times &#x3D; 2) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;   return arr.map(item &#x3D;&gt; item * times);</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import * as tool from &#39;.&#x2F;module.js&#39;</span><br><span class="line"></span><br><span class="line">  console.log(tool)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 输出：</span><br><span class="line">  &#x2F;&#x2F; Module &#123;Symbol(Symbol.toStringTag): &quot;Module&quot;&#125;</span><br><span class="line">  &#x2F;&#x2F;  threeTimes: (arr, times &#x3D; 3) &#x3D;&gt; &#123;…&#125;</span><br><span class="line">  &#x2F;&#x2F;  twoTimes: (arr, times &#x3D; 2) &#x3D;&gt; &#123;…&#125;</span><br><span class="line">  &#x2F;&#x2F;  Symbol(Symbol.toStringTag): &quot;Module&quot;</span><br><span class="line">  &#x2F;&#x2F;  getthreeTimes: ƒ ()</span><br><span class="line">  &#x2F;&#x2F;  set threeTimes: ƒ ()</span><br><span class="line">  &#x2F;&#x2F;  get twoTimes: ƒ ()set</span><br><span class="line">  &#x2F;&#x2F;  twoTimes: ƒ ()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;export与import可以一起使用，实现先输入后输出模块。可以修改默认名，完成具名接口与默认接口的转换</p>
<h3 id="4-模块的继承"><a href="#4-模块的继承" class="headerlink" title="4) 模块的继承"></a>4) 模块的继承</h3><p>&emsp;&emsp;ES6模块可以继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; extends_module.js</span><br><span class="line"></span><br><span class="line">export * from &#39;.&#x2F;module.js&#39; &#x2F;&#x2F; 整体加载module.js模块，再在extends_module暴露出去</span><br><span class="line"></span><br><span class="line">export const sayHello &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 暴露自己的方法</span><br><span class="line">  console.log(&#39;extends_module自己的方法&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">  import * as tool from &#39;.&#x2F;extends_module.js&#39;</span><br><span class="line"></span><br><span class="line">  console.log(tool)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 输出：</span><br><span class="line">  &#x2F;&#x2F; Module &#123;Symbol(Symbol.toStringTag): &quot;Module&quot;&#125;</span><br><span class="line">  &#x2F;&#x2F;  sayHello: () &#x3D;&gt; &#123; console.log(&#39;extends_module自己的方法&#39;) &#125;</span><br><span class="line">  &#x2F;&#x2F;  threeTimes: (arr, times &#x3D; 3) &#x3D;&gt; &#123;…&#125;</span><br><span class="line">  &#x2F;&#x2F;  twoTimes: (arr, times &#x3D; 2) &#x3D;&gt; &#123;…&#125;</span><br><span class="line">  &#x2F;&#x2F;  Symbol(Symbol.toStringTag): &quot;Module&quot;</span><br><span class="line">  &#x2F;&#x2F;  getthreeTimes: ƒ ()</span><br><span class="line">  &#x2F;&#x2F;  set threeTimes: ƒ ()</span><br><span class="line">  &#x2F;&#x2F;  get twoTimes: ƒ ()set</span><br><span class="line">  &#x2F;&#x2F;  twoTimes: ƒ ()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-模块加载本质"><a href="#5-模块加载本质" class="headerlink" title="5) 模块加载本质"></a>5) 模块加载本质</h3><p>&emsp;&emsp;ES6模块的运行时遇到加载命令import时，不会去执行模块，而是只生成一个的<u>只读引用</u>，不能再次被赋值。ES6模块不会缓存值，等到真的需要用到引入的模块时，会再次地去获取该模块的值</p>
<h2 id="4、ES6-Module与CommonJS的区别"><a href="#4、ES6-Module与CommonJS的区别" class="headerlink" title="4、ES6 Module与CommonJS的区别"></a>4、ES6 Module与CommonJS的区别</h2><p>&emsp;&emsp;① ES6 Module是静态导入的，CommonJS是动态导入的。即前者模块依赖关系的构建发生在代码编译阶段；后者模块依赖关系的构建发生在代码运行阶段<br>&emsp;&emsp;② 前者输出模块的引用，无缓存问题；后者输出模块的拷贝，有缓存问题<br>&emsp;&emsp;③ 前者使用export、import关键字，后者使用module.exports、require关键字  </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS (异步)异常捕获与处理</title>
    <url>/2021/07/01/javascript/JS%20(%E5%BC%82%E6%AD%A5)%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>异常处理，是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件）。通过异常处理，我们可以对用户在程序中的非法输入或者程序内部逻辑问题进行控制和提示，以防程序崩溃</p>
<h2 id="1、Error对象"><a href="#1、Error对象" class="headerlink" title="1、Error对象"></a>1、Error对象</h2><p>&emsp;&emsp;通过Error的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象也可用于用户自定义的异常的基础对象</p>
<p>&emsp;&emsp;语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Error([message[, fileName[,lineNumber]]])</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 当代码运行时的发生错误，会创建新的Error 对象，并将其抛出。当像函数一样使用 Error 时，它将返回一个 Error 对象。即仅仅调用 Error 产生的结果与通过new 关键字构造 Error 对象生成的结果相同</em></p>
<h3 id="通用的Error构造函数"><a href="#通用的Error构造函数" class="headerlink" title="通用的Error构造函数"></a>通用的Error构造函数</h3><p>&emsp;&emsp;EvalError: 创建一个error实例，表示错误的原因与 eval() 有关<br>&emsp;&emsp;InternalError：创建一个代表Javascript引擎内部错误的异常抛出的实例，比如递归太深导致爆栈<br>&emsp;&emsp;RangeError：创建一个error实例，表示错误的原因为数值变量或参数超出其有效范围，比如数组越界<br>&emsp;&emsp;ReferenceError：创建一个error实例，表示错误的原因为无效引用，比如访问了未定义的变量<br>&emsp;&emsp;SyntaxError：创建一个error实例，表示错误的原因为在解析代码的过程中发生了语法错误<br>&emsp;&emsp;TypeError：创建一个error实例，表示错误的原因为变量或参数不属于有效类型<br>&emsp;&emsp;URIError：创建一个error实例，表示错误的原因为给 encodeURI()或 decodeURI()传递的参数无效</p>
<p><em>&emsp;&emsp;[注] Error.prototype 允许添加属性到 Error 实例；全局 Error 对象自身不包含任何方法，但存在一些从原型链中继承的方法</em></p>
<h2 id="2、异常捕获"><a href="#2、异常捕获" class="headerlink" title="2、异常捕获"></a>2、异常捕获</h2><p>&emsp;&emsp;通常用 throw 关键字来<u>抛出</u>创建的 Error 对象，使用 try…catch 结构来<u>捕获</u>异常。try…catch 语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常被抛出。如果我们抛出一个异常，try…catch语句就捕获它，如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw new Error(&#39;哎呀，发送了一个未知错误~&#39;)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&#96;$&#123;e.name&#125; : $&#123;e.message&#125;&#96;)</span><br><span class="line">  console.log(&#39;代码执行到这里了~&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; Error : 哎呀，发送了一个未知错误~</span><br><span class="line">&#x2F;&#x2F; 代码执行到这里了~</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不过 try…catch 只能捕获同步异常，捕获不到异步异常！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&#39;哎呀，发送了一个未知错误~&#39;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&#96;$&#123;e.name&#125; : $&#123;e.message&#125;&#96;)</span><br><span class="line">  console.log(&#39;代码执行到这里了~&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：这段代码没有输出</span><br><span class="line">&#x2F;&#x2F; 浏览器控制台打印错误：Uncaught Error: 哎呀，发送了一个未知错误~</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结论：try...catch 未能捕获异步异常</span><br></pre></td></tr></table></figure>
<h2 id="3、异步异常捕获"><a href="#3、异步异常捕获" class="headerlink" title="3、异步异常捕获"></a>3、异步异常捕获</h2><p>&emsp;&emsp;从 ECMAScript 6 开始，JavaScript 增加了对 Promise 对象的支持，它允许你对延时和异步操作流进行控制，也可以对异步异常进行捕获处理：<br>&emsp;&emsp;☞ pending：初始的状态，即正在执行，不处于 fulfilled 或 rejected 状态<br>&emsp;&emsp;☞ fulfilled：成功的完成了操作<br>&emsp;&emsp;☞ rejected：失败，没有完成操作<br>&emsp;&emsp;☞ settled：Promise 处于 fulfilled 或 rejected 二者中的任意一个状态, 不会是 pending，即处于已敲定的状态</p>
<p><img src="/images/javascript/Promise%E6%B5%81%E7%A8%8B.png" alt="Promise流程"></p>
<p>&emsp;&emsp;待定状态的 Promise 对象要么会通过一个值被兑现（fulfilled），要么会通过一个原因（错误）被拒绝（rejected）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用</p>
<p><em>&emsp;&emsp;[注] Promise.prototype.then 和  Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。任何不是 throw 的终止都会创建一个”已决议”状态，resolve() 方法可能将 pending 状态转化为 fulfilled 或 rejected 状态；而以 throw 终止则会创建一个”已拒绝”状态，reject() 方法会将 pending 状态转化为  rejected 状态</em></p>
<p>&emsp;&emsp;Promise捕获异常示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      throw &#39;出错啦~&#39;</span><br><span class="line">      resolve(true)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;已兑现: $&#123;res&#125;&#96;)</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;已拒绝: $&#123;err&#125;&#96;) &#x2F;&#x2F; 已拒绝: 出错啦~</span><br><span class="line">&#125;).finally(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Promise执行已完成&#39;) &#x2F;&#x2F; Promise执行已完成</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;try…catch语句不能捕获异步异常，但可以在Promise函数体的异步操作执行时，将异步操作的错误信息通过reject(err)函数抛出，此时Promise状态变为rejected状态，在Promise的catch分支中将reject()函数抛出的err错误信息捕获。项目中我们可以使用Promise封装ajax请求，来实现对请求失败的<u>统一处理</u>~</p>
<h2 id="4、Vue项目中使用axios请求数据并统一处理异常"><a href="#4、Vue项目中使用axios请求数据并统一处理异常" class="headerlink" title="4、Vue项目中使用axios请求数据并统一处理异常"></a>4、Vue项目中使用axios请求数据并统一处理异常</h2><p>&emsp;&emsp;1) 对axios配置超时等属性，对请求与响应作统一拦截处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;api&#x2F;axios.js</span><br><span class="line"></span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import &#123; get &#125; from &#39;lodash&#39;</span><br><span class="line">import qs from &#39;qs&#39;</span><br><span class="line">import &#123; Message &#125; from &#39;element-ui&#39;</span><br><span class="line">import Router from &#39;@&#x2F;router&#39;</span><br><span class="line">import store from &#39;..&#x2F;store&#39;</span><br><span class="line"></span><br><span class="line">const instance &#x3D; axios.create(&#123;</span><br><span class="line">  baseURL: &#39;&#x2F;api&#39;,</span><br><span class="line">  timeout: 1000 * 30</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.interceptors.request.use(config &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 给header统一加上Token信息</span><br><span class="line">  config.headers.Token &#x3D; localStorage.getItem(&#39;accessToken&#39;)</span><br><span class="line">  &#x2F;&#x2F; 预处理get请求url上的数组信息</span><br><span class="line">  if (config.method &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123;</span><br><span class="line">    config.paramsSerializer &#x3D; params &#x3D;&gt; &#123;</span><br><span class="line">      return qs.stringify(params, &#123; indices: false &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">  &#x2F;&#x2F; 请求成功，返回服务端响应内容</span><br><span class="line">  response &#x3D;&gt; response.data,</span><br><span class="line">  &#x2F;&#x2F; 请求失败，统一处理错误信息</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    if (error.response) &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录信息过期移除缓存的用户信息，跳转登录页</span><br><span class="line">      if (error.response.status &#x3D;&#x3D;&#x3D; 401) &#123;</span><br><span class="line">        localStorage.removeItem(&#39;userInfo&#39;)</span><br><span class="line">        store.commit(&#39;clearUserInfo&#39;)</span><br><span class="line">        &#x2F;&#x2F; Message.error(&#39;您的登录已过期，请重新登录&#39;)</span><br><span class="line">        Message.error(get(error, &#39;response.data.message&#39;, &#39;您的登录已过期，请重新登录&#39;))</span><br><span class="line">        Router.push(&#39;&#x2F;login&#39;)</span><br><span class="line">        return Promise.resolve()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 统一处理错误，并将错误抛出，具体请求也能拿到错误信息</span><br><span class="line">        Message.error(get(error, &#39;response.data.message&#39;, &#39;网络错误，请您稍后尝试&#39;))</span><br><span class="line">        return Promise.reject(error.response.data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Message.error(&#39;网络错误，请您稍后尝试&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default instance</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2) 针对功能模块编写API列表文件，对请求进行封装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;api&#x2F;menu.js</span><br><span class="line"></span><br><span class="line">import axios from &#39;@&#x2F;api&#x2F;axios.js&#39;</span><br><span class="line"></span><br><span class="line">export const fetchFrontMenuList &#x3D; params &#x3D;&gt; axios.get(&#39;&#x2F;v1&#x2F;menu-front&#39;, &#123; params &#125;)</span><br><span class="line">export const fetchBannerList &#x3D; menuId &#x3D;&gt; axios.get(&#96;&#x2F;v1&#x2F;menu-front&#x2F;$&#123;menuId&#125;&#x2F;banner&#96;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3) 页面中接口的简单使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;views&#x2F;Index.vue</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line">  import &#123; fetchFrontMenuList &#125; from &#39;@&#x2F;api&#x2F;menu&#39;</span><br><span class="line"></span><br><span class="line">  export default @Component(&#123;&#125;)</span><br><span class="line">  class Index extends Vue &#123;</span><br><span class="line">    menuList &#x3D; []</span><br><span class="line"></span><br><span class="line">    async created () &#123;</span><br><span class="line">      const resp &#x3D; await fetchFrontMenuList(&#123; status: 0 &#125;)</span><br><span class="line">      this.menuList &#x3D; (resp.data || [])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue全局配置</title>
    <url>/2021/10/21/vue/Vue%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>这部分主要讲Vue项目的全局配置，Vue根实例属性与方法，以及Vue的全局方法</p>
<h2 id="初始化Vue3项目"><a href="#初始化Vue3项目" class="headerlink" title="初始化Vue3项目"></a>初始化Vue3项目</h2><p>&emsp;&emsp;使用vue-cli初始化vue项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create test</span><br><span class="line">  &#x2F;&#x2F; - 选择 Default (Vue 3) ([Vue 3] babel, eslint)</span><br><span class="line">cd test</span><br><span class="line">npm run serve</span><br><span class="line">  &#x2F;&#x2F; App running at:</span><br><span class="line">  &#x2F;&#x2F; - Local:   http:&#x2F;&#x2F;localhost:8080&#x2F;</span><br><span class="line">  &#x2F;&#x2F; - Network: http:&#x2F;&#x2F;172.17.4.18:8080&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/vue/vue_init_page.jpg" alt="vue_init_page"></p>
<p>&emsp;&emsp;入口文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line"></span><br><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39; &#x2F;&#x2F; 引入根组件</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(App) &#x2F;&#x2F; 创建 Vue 根组件实例 app</span><br><span class="line">app.mount(&#39;#app&#39;) &#x2F;&#x2F; 将根组件实例 app 挂载到 根节点 (public&#x2F;index.html：&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;)</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] Vue3允许&lt;template&gt;模板存在多标签</em></p>
<h2 id="Vue打包生成的dist项目本地运行"><a href="#Vue打包生成的dist项目本地运行" class="headerlink" title="Vue打包生成的dist项目本地运行"></a>Vue打包生成的dist项目本地运行</h2><p>&emsp;&emsp;进入Vue项目根目录，运行入npm run build(在package.json的scripts配置)。经过打包工具编译打包，项目打包后在根目录下将会生成dist项目文件夹。但不能直接打开dist目录下的index.html在浏览器进行预览，因为index.html文件中引用使用的是绝对路径，直接运行时绝对路径’/‘指向磁盘根目录，index.html没成功加载打包后的js、css等文件，页面白屏。解决方法：让dist项目运行在服务器环境下即可</p>
<p>① 修改打包工具对应配置，将打包时引用绝对路径方式改为相对路径</p>
<p>② 使用http-server</p>
<p>&emsp;&emsp;可全局安装http-server，在dist目录下运行http-server服务使dist处于服务器环境中</p>
<p><img src="/images/vue/http-server.png" alt="http-server"></p>
<h2 id="1、应用全局配置"><a href="#1、应用全局配置" class="headerlink" title="1、应用全局配置"></a>1、应用全局配置</h2><p>&emsp;&emsp;每个 Vue 应用（实例）都会暴露一个 config 对象，在挂载应用到根节点前，可对该应用进行相应配置<br>&emsp;&emsp;(1) globalProperties([key: string]: any)<br>&emsp;&emsp;添加一个可以在应用的任何组件实例中访问的全局 property（封装全局变量或函数）。组件的 property 在命名冲突具有优先权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">app.config.globalProperties.$http &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;可以在这里封装请求哦~&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">created() &#123;</span><br><span class="line">  this.$http() &#x2F;&#x2F; 可以在这里封装请求哦~</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(2) compilerOptions，配置运行时编译器的选项。可在组件上定义该选项覆盖全局应用配置</p>
<p><em>&emsp;&emsp;[注] compilerOptions配置仅在完整的构建版本中生效，还需要进行相应配置</em></p>
<p>&emsp;&emsp;① isCustomElement((tag: string) =&gt; boolean)<br>&emsp;&emsp;指定一个方法来识别 Vue 以外 (Web Components API) 定义的自定义元素。匹配了这个条件，组件不会再要求本地或全局注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任何带有 &#39;-&#39; 的元素都会被识别为自定义元素</span><br><span class="line">app.config.compilerOptions.isCustomElement &#x3D; tag &#x3D;&gt; tag.includes(&#39;-&#39;)</span><br></pre></td></tr></table></figure>

<p><em>&emsp;&emsp;[注] Web Components API是谷歌推行的自定义浏览器元素的技术</em><br><em>&emsp;&emsp;&emsp;&emsp;原生自定义元素指南：<a href="https://www.robinwieruch.de/web-components-tutorial">Web Components Tutorial for Beginners [2019]</a></em></p>
<p>&emsp;&emsp;一个使用原生 Web Components API 定义&lt;user-card&gt;元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; card.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 定义组件模板 --&gt;</span><br><span class="line">  &lt;template id&#x3D;&quot;userCardTemplate&quot;&gt;</span><br><span class="line">    &lt;!-- 给自定义元素添加样式 --&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      :host &#123;</span><br><span class="line">        display: flex; align-items: center; width: 400px; height: 180px;</span><br><span class="line">        border: 1px solid #d5d5d5; box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);</span><br><span class="line">        border-radius: 4px; display: flex; justify-content: center; align-items: center;</span><br><span class="line">      &#125;</span><br><span class="line">      .image &#123; width: 120px; height: 120px; border-radius: 50%; font-size: 0; &#125;</span><br><span class="line">      .container &#123; width: 200px; display: flex; flex-direction: column; align-items: center; &#125;</span><br><span class="line">      .container &gt; p &#123; font-size: 12px; color: #666; margin: 5px 0; &#125;</span><br><span class="line">      .container &gt; .name &#123; font-size: 20px; font-weight: 600; &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;img class&#x3D;&quot;image&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;p class&#x3D;&quot;name&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p class&#x3D;&quot;wechat&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p class&#x3D;&quot;email&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 使用组件定义好的元素并传入参数 --&gt;</span><br><span class="line">  &lt;user-card </span><br><span class="line">    image&#x3D;&quot;https:&#x2F;&#x2F;gimg2.baidu.com&#x2F;image_search&#x2F;src&#x3D;http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F202005%2F12%2F20200512164443_xudmd.thumb.400_0.png&amp;refer&#x3D;http%3A%2F%2Fc-ssl.duitang.com&amp;app&#x3D;2002&amp;size&#x3D;f9999,10000&amp;q&#x3D;a80&amp;n&#x3D;0&amp;g&#x3D;0n&amp;fmt&#x3D;jpeg?sec&#x3D;1637913324&amp;t&#x3D;b6dbd9cdeedcf605dd56aa1426283d9e&quot;</span><br><span class="line">    name&#x3D;&quot;熊小刚&quot;</span><br><span class="line">    wechat&#x3D;&quot;littlefish_and_bears&quot;</span><br><span class="line">    email&#x3D;&quot;xionggang1024@gmail.com&quot;&gt;</span><br><span class="line">  &lt;&#x2F;user-card&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 定义UserCard类，UserCard继承于HTMLElement类</span><br><span class="line">    class UserCard extends HTMLElement &#123;</span><br><span class="line">      constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        const shadow &#x3D; this.attachShadow( &#123; mode: &#39;closed&#39; &#125; );</span><br><span class="line">        const templateElem &#x3D; document.getElementById(&#39;userCardTemplate&#39;);</span><br><span class="line">        const content &#x3D; templateElem.content.cloneNode(true);</span><br><span class="line">        &#x2F;&#x2F; 给自定义元素添加参数</span><br><span class="line">        content.querySelector(&#39;img&#39;).setAttribute(&#39;src&#39;, this.getAttribute(&#39;image&#39;));</span><br><span class="line">        content.querySelector(&#39;.container&gt;.name&#39;).innerText &#x3D; this.getAttribute(&#39;name&#39;);</span><br><span class="line">        content.querySelector(&#39;.container&gt;.wechat&#39;).innerText &#x3D; this.getAttribute(&#39;wechat&#39;);</span><br><span class="line">        content.querySelector(&#39;.container&gt;.email&#39;).innerText &#x3D; this.getAttribute(&#39;email&#39;);</span><br><span class="line">        shadow.appendChild(content);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 定义根据UserCard类定义user-card元素</span><br><span class="line">    window.customElements.define(&#39;user-card&#39;, UserCard);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;效果：</p>
<p><img src="/images/vue/user_card.png" alt="user_card"></p>
<p>特别的，可以用脚本把&lt;template&gt;注入网页。这样的话，JavaScript 脚本跟&lt;template&gt;就能封装成一个 JS 文件，成为独立的组件文件。网页只要加载这个脚本，就能使用&lt;user-card&gt;组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; user-card.js</span><br><span class="line"></span><br><span class="line">const template &#x3D; document.createElement(&#39;template&#39;);</span><br><span class="line">template.innerHTML &#x3D; &#96;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">  :host &#123;</span><br><span class="line">    display: flex; align-items: center; width: 400px; height: 180px;</span><br><span class="line">    border: 1px solid #d5d5d5; box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);</span><br><span class="line">    border-radius: 4px; display: flex; justify-content: center; align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">  .image &#123; width: 120px; height: 120px; border-radius: 50%; font-size: 0; &#125;</span><br><span class="line">  .container &#123; width: 200px; display: flex; flex-direction: column; align-items: center; &#125;</span><br><span class="line">  .container &gt; p &#123; font-size: 12px; color: #666; margin: 5px 0; &#125;</span><br><span class="line">  .container &gt; .name &#123; font-size: 20px; font-weight: 600; &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;img class&#x3D;&quot;image&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;p class&#x3D;&quot;name&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p class&#x3D;&quot;wechat&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p class&#x3D;&quot;email&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">class UserCard extends HTMLElement &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    const shadow &#x3D; this.attachShadow( &#123; mode: &#39;closed&#39; &#125; );</span><br><span class="line">    const content &#x3D; template.content.cloneNode(true);</span><br><span class="line">    content.querySelector(&#39;img&#39;).setAttribute(&#39;src&#39;, this.getAttribute(&#39;image&#39;));</span><br><span class="line">    content.querySelector(&#39;.container&gt;.name&#39;).innerText &#x3D; this.getAttribute(&#39;name&#39;);</span><br><span class="line">    content.querySelector(&#39;.container&gt;.wechat&#39;).innerText &#x3D; this.getAttribute(&#39;wechat&#39;);</span><br><span class="line">    content.querySelector(&#39;.container&gt;.email&#39;).innerText &#x3D; this.getAttribute(&#39;email&#39;);</span><br><span class="line">    shadow.appendChild(content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.customElements.define(&#39;user-card&#39;, UserCard);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; card.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;user-card </span><br><span class="line">      image&#x3D;&quot;https:&#x2F;&#x2F;gimg2.baidu.com&#x2F;image_search&#x2F;src&#x3D;http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F202005%2F12%2F20200512164443_xudmd.thumb.400_0.png&amp;refer&#x3D;http%3A%2F%2Fc-ssl.duitang.com&amp;app&#x3D;2002&amp;size&#x3D;f9999,10000&amp;q&#x3D;a80&amp;n&#x3D;0&amp;g&#x3D;0n&amp;fmt&#x3D;jpeg?sec&#x3D;1637913324&amp;t&#x3D;b6dbd9cdeedcf605dd56aa1426283d9e&quot;</span><br><span class="line">      name&#x3D;&quot;熊小刚&quot;</span><br><span class="line">      wechat&#x3D;&quot;littlefish_and_bears&quot;</span><br><span class="line">      email&#x3D;&quot;xionggang1024@gmail.com&quot;&gt;</span><br><span class="line">    &lt;&#x2F;user-card&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;.&#x2F;user-card.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;&emsp;&emsp;Vue3官方提供的封装原生Web Components API的文档地址：<a href="https://v3.cn.vuejs.org/guide/web-components.html#%E8%B7%B3%E8%BF%87%E7%BB%84%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90">Vue 与 Web Components</a></em></p>
<p>&emsp;&emsp;② whitespace(‘condense’ | ‘preserve’)<br>&emsp;&amp;emsp设置 Vue 编译时的压缩标准，默认(condense)会移除/压缩模板元素之间的空格以产生更高效的编译结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.config.compilerOptions.whitespace &#x3D; &#39;preserve&#39;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ delimiters(Array&lt;string&gt;)<br>&emsp;&emsp;设置用在模板内的文本插值的边界符，默认值：[‘&#123;&#123;’, ‘&#125;&#125;’]，这个选项一般会用于避免和同样使用大括号语法的服务端框架发生冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将边界符改变为 ES6 模板字符串风格</span><br><span class="line">app.config.compilerOptions.delimiters &#x3D; [&#39;$&#123;&#39;, &#39;&#125;&#39;]  </span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ comments(boolean)<br>&emsp;&emsp;默认情况（false）下，Vue 会在生产环境下移除模板内的 HTML 注释。这个选项一般与依赖 HTML 注释的其它库和 Vue 配合使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.config.compilerOptions.comments &#x3D; true</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;应用配置处理globalProperties、compilerOptions，还有其他的errorHandler、warnHandler、performance等配置，用得相对较少，感兴趣的朋友可自行研究</p>
<h2 id="2、Vue根实例-属性-方法"><a href="#2、Vue根实例-属性-方法" class="headerlink" title="2、Vue根实例(属性)方法"></a>2、Vue根实例(属性)方法</h2><p>&emsp;&emsp;在 Vue 3 中，改变全局 Vue 行为的 API 以及属性现在被移动到了由新的 createApp 方法所创建的应用实例上<br>&emsp;&emsp;(1) component({string} name, {Function | Object} [definition])<br>&emsp;&emsp;注册或检索全局组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">app.component(&#39;my-component&#39;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检索</span><br><span class="line">const MyComponent &#x3D; app.component(&#39;my-component&#39;)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;(2) config<br>&emsp;&emsp;应用配置，详见本文章前面的<a href="/2021/10/21/vue/Vue%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/#1%E3%80%81%E5%BA%94%E7%94%A8%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">《1、应用全局配置》</a></p>
<p>&emsp;&emsp;(3) directive({string} name, {Function | Object} [definition])<br>&emsp;&emsp;注册或检索全局指令，用法与component API相似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">app.directive(&#39;my-directive&#39;, &#123;</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  beforeMount() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  beforeUpdate() &#123;&#125;,</span><br><span class="line">  updated() &#123;&#125;,</span><br><span class="line">  beforeUnmount() &#123;&#125;,</span><br><span class="line">  unmounted() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册 (功能指令)</span><br><span class="line">app.directive(&#39;my-directive&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 这将被作为 mounted 和 updated 调用</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const myDirective &#x3D; app.directive(&#39;my-directive&#39;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(4) mixin(Object)<br>&emsp;&emsp;将一个 mixin 应用在整个应用范围内</p>
<p>&emsp;&emsp;(5) mount({Element | string} rootContainer, {boolean} isHydrate)<br>&emsp;&emsp;提供 DOM 元素的 innerHTML 将被替换为应用根组件的模板渲染结果，可将Vue根组件挂载到根节点上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">createApp(&#123;&#125;).mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;(6) provide/inject<br>解决深度嵌套的组件 props 沿着组件链逐级传递的麻烦问题，这个选项在写插件时尤其有用，是 globalProperties 的替代选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 祖先组件</span><br><span class="line">export default &#123;</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Welcome to Your Vue.js App&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 后代组件</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#39;msg&#39;],</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.msg) &#x2F;&#x2F; Welcome to Your Vue.js App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>&emsp;&emsp;[]注 默认情况下，provide/inject 绑定并不是响应式的。我们可以通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为</em></p>
<p>&emsp;&emsp;(7) unmount<br>&emsp;&emsp;卸载应用实例的根组件</p>
<p>&emsp;&emsp;(8) use({Object | Function} plugin, …options (可选))<br>&emsp;&emsp;安装 Vue.js 插件。如果插件是一个对象，它必须暴露一个 install 方法。如果它本身是一个函数，函数将被视为安装方法，当在同一个插件上多次调用此方法时，该插件将仅安装一次</p>
<p>&emsp;&emsp;(9) version<br>&emsp;&emsp;以字符串形式提供已安装的 Vue 的版本号</p>
<h2 id="3、Vue的全局方法"><a href="#3、Vue的全局方法" class="headerlink" title="3、Vue的全局方法"></a>3、Vue的全局方法</h2><p>&emsp;&emsp;-待完善-</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue概述</title>
    <url>/2021/10/20/vue/Vue%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>Vue是一个由<a href="https://baike.baidu.com/item/%E5%B0%A4%E9%9B%A8%E6%BA%AA">尤雨溪</a>以及团队开发与维护的轻量级、响应式的JavaScript开发库，能够更高效的构建单页面的WEB应用。一般采用声明式渲染、MVVM模式实现数据与视图UI同步变化的数据驱动方式，是开发者能更好地组织与简化WEB项目开发</p>
<h2 id="1、单页面应用-SPA"><a href="#1、单页面应用-SPA" class="headerlink" title="1、单页面应用(SPA)"></a>1、单页面应用(SPA)</h2><p>&emsp;&emsp;为了提高传统WEB应用的性能与用户体验（页面跳转时公共资源被多次重复请求、页面频繁跳转用户体验不好），在前后端分离的前提下，采用了可以局部动态更新当前页面组件的方式来与用户交互，而不需要重新加载整个页面，是一种<u>网站应用模型</u>，能让WEB应用使用更加流畅</p>
<p>&emsp;&emsp;相对于传统多页面WEB应用，单页面应用还需要处理路由（路由前端化）问题，根据路由规则去移除，添加或更新页面组件。不需要刷新页面进行重新服务器让其返回页面，服务器只负责处理数据并提供接口</p>
<p>&emsp;&emsp;前端路由有history与hash两种模式，都可以在<u>不刷新页面</u>的前提下改变了页面的URL，从而Vue监听到页面URL变化，通过定义好的路由规则，来实现页面中组件的移除或更新，从而达到局部更新页面的状态的目的</p>
<p>&emsp;&emsp;history与hash模式的区别：<br>&emsp;&emsp;(1) history模式是基于HTML5 window.history中新增的pushState()和replaceState()方法来完成不刷新改变URL<br>&emsp;&emsp;(2) hash模式基于window.location中的hash，采用hash模式是URL中的’#’(锚点)功能来完成不刷新改变URL</p>
<p>&emsp;&emsp;SPA的优缺点：<br>&emsp;&emsp;优点：<br>&emsp;&emsp;① 无页面刷新，应用更加流畅<br>&emsp;&emsp;② 服务器压力更小，后端逻辑可复用<br>&emsp;&emsp;缺点：<br>&emsp;&emsp;① SEO不友好（可通过服务端渲染解决）<br>&emsp;&emsp;② 页面首次(首屏)加载时间长<br>&emsp;&emsp;③ 浏览器前进后退功能无效<br>&emsp;&emsp;④ 若采用hash模式，页面原有的锚点功能会失效  </p>
<h2 id="2、声明式编程-渲染"><a href="#2、声明式编程-渲染" class="headerlink" title="2、声明式编程(渲染)"></a>2、声明式编程(渲染)</h2><p>&emsp;&emsp;先来说说命令式编程、声明式编程与函数式编程，这些都是<u>编程范式，与具体语言没有太大的关系</u>。同一功能可以用同一语言使用不同的编程范式来实现，例如将一个嵌套的数组各项值乘2<br>命令式编程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [1, [2, 3], 4]</span><br><span class="line">for (let i &#x3D; 0, cnt &#x3D; list.length; i &lt; cnt; i++) &#123;</span><br><span class="line">    if (typeof list[i] &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">        list[i] &#x3D; list[i] * 2</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (let j &#x3D; 0, len &#x3D; list[i].length; j &lt; len; j++) &#123;</span><br><span class="line">            list[i][j] &#x3D; list[i][j] * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(list) &#x2F;&#x2F; [2, [4, 6], 8]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;命令式编程是关注代码执行过程，是对执行过程进行模拟，执行完成才知道结果</p>
<p>声明式编程:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [1, [2, 3], 4]</span><br><span class="line">list &#x3D; list.map(item &#x3D;&gt; &#123;</span><br><span class="line">    if(typeof item &#x3D;&#x3D;&#x3D; &quot;number&quot; ) return item * 2</span><br><span class="line">    else return item.map(value &#x3D;&gt; value * 2)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(list) &#x2F;&#x2F; [2, [4, 6], 8]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;声明式编程值关注执行的结果，不关心具体执行过程，所以一般不包含for、while等循环控制语句</p>
<p>函数式编程:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [1, [2, 3], 4]</span><br><span class="line">function fn(list) &#123;</span><br><span class="line">    if(typeof list &#x3D;&#x3D;&#x3D; &quot;number&quot; ) return list * 2</span><br><span class="line">    else return list.map(value &#x3D;&gt; fn(value))</span><br><span class="line">&#125;</span><br><span class="line">list &#x3D; fn(list)</span><br><span class="line">console.log(list) &#x2F;&#x2F; [2, [4, 6], 8]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数式编程和声明式编程思想是一致的，关注执行结果。函数式编程把运算过程尽量写成一系列嵌套函数的调用的形式（递归）来提高代码的通用性，例如将上面list数组在定义时赋值为更复杂的[1, [2, [3, 4]], [5, [6, 7, [8]]], 9, 10]，只有函数式编程的递归代码不做任何修改也能输出想要的结果正确结果</p>
<p>&emsp;&emsp;一般来说Vue是采用声明式编程的。在组件实例化是定义props、data、methods、computed等内容时，我们只需声明对应的参数、数据、方法等，在&lt;template&gt;模板里通过mustache语法（&#123;&#123;&#125;&#125;）直接绑定并使用。当数据发生改变，对应数据的视图也会自动更新，开发者真正开发中无需额外实现双向数据绑定的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &#39;Test&#39;,</span><br><span class="line">props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">&#125;,</span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &#39;测试~&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h3 &#123;</span><br><span class="line">    margin: 40px 0 0;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;</span><br><span class="line">    color: #42b983;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Vue通过声明式编程，使得视图、数据结构相互分离，开发者只需要关注核心逻辑的开发，数据展示由Vue库来完成，使编码更加简单高效<br>&emsp;&emsp;特别的，平时我们编写HTML(&lt;template&gt;)以及css代码时，都是关注布局与样式结果，不需要实现html代码展示在浏览器屏幕上的功能。及编码html、css的方式是声明式的</p>
<h2 id="3、模板编译与虚拟DOM"><a href="#3、模板编译与虚拟DOM" class="headerlink" title="3、模板编译与虚拟DOM"></a>3、模板编译与虚拟DOM</h2><p>&emsp;&emsp;vue文件是不能直接运行在浏览器上的，需要结合Webpack使用vue-loader等处理模块（函数）将vue文件编译打包成js文件。期间会经过模板编译、实现watcher等核心渲染监听逻辑、生成虚拟DOM以及Diff算法对比虚拟DOM的更新等过程，最终再更新渲染在浏览器页面上<br>&emsp;&emsp;在Vue中，为了避免页面更新时频繁的进行页面重绘等操作，减少浏览器性能消耗，使用JS对象来描述页面真实的DOM。在页面数据更新时，会将更新后的虚拟DOM结构与之前的虚拟DOM结构采用Diff算法进行对比，最后只是将对比出来的差异的部分进行真实DOM的更新渲染</p>
<p><img src="/images/note/vNode.png" alt="vNode"></p>
<p>&emsp;&emsp;在页面数据发生变化时，根据Vue相关响应式原理，会生成新的虚拟DOM结构，进行Diff算法（React Diff算法与Vue一致）来计算页面最小更新。<strong>匹配的最小单位是标签，只进行只进行同层级比较，忽略跨级操作</strong>。如上图中的&lt;ul&gt;结构不会与&lt;li&gt;结构进行比较。若&lt;ul&gt;结构一致，还有子元素时，会对里面的&lt;li&gt;进行一一比较，若&lt;ul&gt;已经不同，直接回新的&lt;ul&gt;更新页面上对应的真实DOM</p>
<p>&emsp;&emsp;为了提高效率，框架一般要求在循环出来的最外层元素添加唯一的key标识，便于Diff算法比较时具有更高效率</p>
<p><em>&emsp;&emsp;[注] 一般不使用 index 作为 key 的值，因为在对数据进行逆序添加、逆序删除等破坏顺序操作时：①会造成没必要的真实DOM的更新 ② DOM 结构中包含输入类元素，会导致元素绑定的值出现错误，因为Diff 算法无法知道输出类元素绑定的值是什么。如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的</em></p>
<h2 id="4、MVVM模式与数据响应式"><a href="#4、MVVM模式与数据响应式" class="headerlink" title="4、MVVM模式与数据响应式"></a>4、MVVM模式与数据响应式</h2><p>&emsp;&emsp;MVVM（Model View ViewModel）是MVC的升级版，采用ViewModel层将视图（View）与数据模型（Model）进行解耦。将视图DOM封装，利用观察者模式（发布订阅）实现视图与数据模型的动态响应与同步更新</p>
<p><img src="/images/note/mvvm.webp" alt="avatar"></p>
<p>&emsp;&emsp;(1) 数据模型层数据同步更新到视图<br>&emsp;&emsp;① 实现数据劫持，Vue2.x中采用Object.defineProperty()实现；Vue3.x中采用新的API Proxy()来实现检测数据变化<br>&emsp;&emsp;② 实现发布订阅者模式，视图层订阅数据模型层数据更新的消息。当数据模型层数据更新时，会将更新函数发布到对应的全部的订阅者<br>&emsp;&emsp;③ 结合数据劫持和发布订阅模式，解析HTML( &lt;template&gt;)结构中绑定的变量（订阅者），当数据模型中对应数据更新后，对应变量会通过数据模型层发布的更新函数进行更新，从而达到更新视图层的目的</p>
<p>&emsp;&emsp;(2) 视图层输入（数据模型层某些数据的数据源）更新到数据模型层<br>&emsp;&emsp;视图层通过事件绑定监听数据变化，从而在对应的事件回调函数里更新数据模型层的数据</p>
<p>&emsp;&emsp;通过发布订阅模式与事件响应机制，Vue实现了数据双向绑定，使得日常开发只需要关注数据，不需要操作DOM结构，使用数据驱动页面更新</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript概述</title>
    <url>/2020/12/03/javascript/JavaScript%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型，单线程的脚本语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态页面信息，而是实时的内容更新，交互式的地图，2D/3D 动画，滚动播放的视频等更加丰富的内容，也能实现用户在网页界面上与服务器相关交互功能</p>
<h2 id="1、语言特性"><a href="#1、语言特性" class="headerlink" title="1、语言特性"></a>1、语言特性</h2><p>&emsp;&emsp;JavaScript是一门动态的、弱类型、基于原型（prototype）的脚本语言。在JavaScript中“一切皆对象”，在这一方面，它比其他的面向对象的语言来得更为彻底。即使作为代码本身载体的函数（function），也是对象。</p>
<h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><h3 id="1-向页面添加JavaScript"><a href="#1-向页面添加JavaScript" class="headerlink" title="1) 向页面添加JavaScript"></a>1) 向页面添加JavaScript</h3><p>&emsp;&emsp;在body标签结束前插入以下script标签引入JavaScript， <u>JavaScript 是区分大小写的</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式1：内联JavaScript</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ...在此编写JavaScript代码...</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式2：外部引入JavaScript</span><br><span class="line">&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 在外部引入JS时，在必要的时候（防止加载阻塞页面渲染问题或对多个有依赖关系的脚本对加载顺序有要求），我们需要在&lt;script&gt;标签上加上async或defer修饰符（属性）（这是解决脚本阻塞问题的两种方式）。<u>浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。</u>当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，async 是最理想的选择；<u>defer 属性的脚本将按照在页面中出现的顺序加载，可保证脚本的加载顺序</u></em></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2) 变量"></a>2) 变量</h3><p>&emsp;&emsp;变量是用来存储数值的，那么有一个重要的概念需要区分。变量不是数值本身，它们仅仅是一个用于存储数值的容器，JS中使用var、let、const来定义变量</p>
<p>&emsp;&emsp;<strong>构造变量名称（唯一标识符）的通用规则是：</strong><br>&emsp;&emsp;名称可包含字母、数字、下划线和美元符号<br>&emsp;&emsp;名称必须以字母、$或_开头<br>&emsp;&emsp;名称对大小写敏感<br>&emsp;&emsp;保留关键字不能作为变量名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a;</span><br><span class="line">let b;</span><br><span class="line">onst C &#x3D; 100; &#x2F;&#x2F; 定义常量必须进行初始化，常量一般用大写英文命名</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;变量类型：<br>&emsp;&emsp;值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol<br>&emsp;&emsp;引用数据类型：对象(Object，JavaScript 对象是键值对的容器)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）</p>
<h3 id="3-语句与表达式"><a href="#3-语句与表达式" class="headerlink" title="3) 语句与表达式"></a>3) 语句与表达式</h3><p>&emsp;&emsp;<u>JavaScript区分表达式和语句</u><br>&emsp;&emsp;表达式是输出值的，并且可以写在任何需要一个值的地方，例如函数的参数等。一般来讲，表达式由变量、操作符和约束条件等以能求得有意义的数值（非undefined）为目的排列所得的组合<br>&emsp;&emsp;语句表示执行了一个动作，例如循环控制语句(for、while…)和分支判断语句(if)等。一个程序基本上就是一系列的语句的集合。在JavaScript中需要语句的地方，也可以写入一个表达式。但不能够在需要表达式的地方写入一个语句。我们常用分号分语句，使得可以在一行编写多条语句。<br>&emsp;&emsp;常用运算符：=、+、-、*、/、==、!=、&gt;、&lt;、&amp;&amp;、||、位运算符、……<br>&emsp;&emsp;常用语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 赋值语句    </span><br><span class="line">let a &#x3D; 5, b &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if条件判断语句</span><br><span class="line">if (condition1) &#123;</span><br><span class="line">  &#x2F;&#x2F; 当条件 1 为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2) &#123;</span><br><span class="line">  &#x2F;&#x2F; 当条件 2 为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  &#x2F;&#x2F; 当条件 1 和 条件 2 都不为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; switch分支语句</span><br><span class="line">switch (n) &#123;</span><br><span class="line">  case 1:</span><br><span class="line">    &#x2F;&#x2F; 执行代码块 1</span><br><span class="line">    break; &#x2F;&#x2F; 阻止代码向下一个case执行，有时为了逻辑需要（如累加等），switch语句中不会使用此关键字</span><br><span class="line">  case 2:</span><br><span class="line">    &#x2F;&#x2F; 执行代码块 2</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">  &#x2F;&#x2F; 与 case 1 和 case 2 不同时执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for、while、do while循环语句（break 语句用于跳出循环，continue 用于跳过循环中的一个迭代）</span><br><span class="line">for (语句 1; 语句 2; 语句 3)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 语句2为真执行的代码块</span><br><span class="line">&#125;</span><br><span class="line">while (条件) &#123;</span><br><span class="line">  &#x2F;&#x2F; 条件为真执行的代码块</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">  &#x2F;&#x2F; 代码块会在条件被测试前执行，代码块至少被执行一次</span><br><span class="line">&#125; while (条件);</span><br></pre></td></tr></table></figure>
<h3 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4) 字符串模板"></a>4) 字符串模板</h3><p>&emsp;&emsp;模板字符串使用反引号<u>(` `)</u> 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${ expression } ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。<u>特别的，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。</u>注意，在模版字符串内使用反引号（`）时，需要在它前面加转义符（），<strong>字符串模板可以嵌套使用。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 4;</span><br><span class="line">function upgradePhone(str, a)&#123; &#x2F;&#x2F; [注] 函数的第一个参数是数组（模板中各个原生字符串）。其余的参数为模板中的变量</span><br><span class="line">  return &#39;带标签的模板字符串，&#39; + str[0] + (a + 2) + str[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#96;我有一个苹果$&#123;a&#125;s，哈哈哈~&#96;) &#x2F;&#x2F; 我有一个苹果6s，哈哈哈~</span><br><span class="line">console.log(upgradePhone&#96;我有一个苹果$&#123;a&#125;s，哈哈哈~&#96;) &#x2F;&#x2F; 带标签的模板字符串，我有一个苹果6s，哈哈哈~</span><br></pre></td></tr></table></figure>
<h3 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5) 解构赋值"></a>5) 解构赋值</h3><p>&emsp;&emsp;解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。使得对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法<br>&emsp;&emsp;特别的：<u>赋值语句周围的圆括号()在使用对象字面量无声明解构赋值时是必须的</u>，否则左边被认为是一个块而不是对象字面量。<u>并且()表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a, b, C;</span><br><span class="line">[a, b &#x3D; 0] &#x3D; [10, 20, 30, 40, 50]; &#x2F;&#x2F; a:10, b:20 [注] 为了防止取出一个值为undefined，可以在表达式左边预设默认值</span><br><span class="line">[a, b, ...C] &#x3D; [10, 20, 30, 40, 50]; &#x2F;&#x2F; a:10，b:20, C: [30, 40, 50]</span><br><span class="line">(&#123; a, b &#x3D; 0&#125; &#x3D; &#123; a: 10, b: 20 &#125;); &#x2F;&#x2F; a: 10, b: 20</span><br><span class="line">(&#123;a, b, ...C&#125; &#x3D; &#123;a: 10, b: 20, c: 30, d: 40&#125;); &#x2F;&#x2F; a: 10, b: 20, C: &#123;c: 30, d: 40&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h3><p>&emsp;&emsp;函数就是包裹在花括号中的代码块，使用关键字function进行定义。当调用该函数时，会执行函数内的代码，在调用函数时，可以向其传递参数。这些参数可以在函数中使用，多个参数用逗号（,）分割。<u>变量和参数必须以一致的顺序出现。</u>第一个变量就是第一个被传递的参数的给定的值，以此类推。有时，我们会希望函数将值返回调用的地方。通过使用return语句就可以实现。在使用return语句时，函数会停止执行(无论后面是否还存在语句)，并返回指定的值。</p>
<p><em>&emsp;&emsp;[注] <u>函数有作用域的概念，在函数内部定义的变量，只能在函数内部访问它（闭包情况除外），此时该变量的作用域是局部的。特别的，如果给未声明的变量赋值，该变量会被自动配置为全局变量（隐式全局变量，也为window对象的属性）。</u></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function functionName(var1, var2, ...) &#123;</span><br><span class="line">  &#x2F;&#x2F; 代码</span><br><span class="line">  &#x2F;&#x2F; return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、可维护的JavaScript代码"><a href="#3、可维护的JavaScript代码" class="headerlink" title="3、可维护的JavaScript代码"></a>3、可维护的JavaScript代码</h2><p>&emsp;&emsp;(1) 尽量不使用全局变量，更不能使用隐式全局变量<br>&emsp;&emsp;(2) 尽量使用let、const语句声明多个变量，并以逗号分隔<br>&emsp;&emsp;(3) 循环存储长度，只检索了一次循环对象的长度值。（’i–’优于’i+=i,i=i+1’优于’i++’）<br>&emsp;&emsp;(4) 数组使用正常的for循环，对象使用for-in循环。（在for-in中，属性列表的顺序（序列）是不能保证的）（hasOwnProperty()方法，可以过滤掉原型链上的属性）<br>&emsp;&emsp;(5) 不扩展内置原型Prototypes<br>&emsp;&emsp;(6) switch语句增强可读性和健壮性，以default结束switch<br>&emsp;&emsp;(7) 避免隐式类型转换<br>&emsp;&emsp;(8) 避免eval()（eval()会干扰作用域链），实在用使用eval(),可以用new Function()代替<br>&emsp;&emsp;(9) 给setInterval(), setTimeout()和Function()构造函数传递字符串或匿名函数<br>&emsp;&emsp;(10) parseInt()传递基数参数，+，Number()优于parseInt()<br>&emsp;&emsp;(11) 缩进<br>&emsp;&emsp;(12) 使用花括号{}，建议并始终把左花括号与之前的语句放在同一行<br>&emsp;&emsp;(13) 空格<br>&emsp;&emsp;(14) <u>命名方式</u><br>&emsp;&emsp;(15) 注释</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS(3)概述</title>
    <url>/2020/09/24/css/CSS-3-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>层叠样式表(Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>
<h2 id="1、文档流-CSS设计核心"><a href="#1、文档流-CSS设计核心" class="headerlink" title="1、文档流 - CSS设计核心"></a>1、文档流 - CSS设计核心</h2><p>&emsp;&emsp;文档流是文档中可显示对象在排列时所占用的位置。即将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素为文档流。</p>
<p>&emsp;&emsp;元素脱离文档流的原因：<br>&emsp;&emsp;(1) 浮动float<br>&emsp;&emsp;(2) 绝对定位（position: absolute/fixed）</p>
<p>&emsp;&emsp;元素脱离文档流的后果：<br>&emsp;&emsp;(1) 使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。（可结合BFC格式化上下文的特性，布局文本环绕图像的样式）<br>&emsp;&emsp;(2) 对于使用position：absolute脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它<br>&emsp;&emsp;(3) 元素脱离文本流后，父元素高度会塌陷，一般通过BFC的特性或者css clearfix属性（推荐使用伪元素清除浮动的方式）清除浮动</p>
<h2 id="2、CSS框模型"><a href="#2、CSS框模型" class="headerlink" title="2、CSS框模型"></a>2、CSS框模型</h2><p>&emsp;&emsp;框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。<br><img src="/images/css3/CSS%E6%A1%86%E6%A8%A1%E5%9E%8B.gif" alt="CSS框模型"><br>&emsp;&emsp;元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距会呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p>
<p>&emsp;&emsp;内边距、边框和外边距都是可选的，在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>&emsp;&emsp;内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。外边距可以是负值。</p>
<p>&emsp;&emsp;外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<p>&emsp;&emsp;[注] CSS框模型包含2种盒子：<br>&emsp;&emsp;(1) 标准盒模型（box-sizing：content-box），盒子的宽高只有内容的宽高<br>&emsp;&emsp;(2) IE盒模型（box-sizing：border-box），盒子的宽高=内容（content）+内边距（padding）+边框（border）的总宽高</p>
<h2 id="3、CSS基础"><a href="#3、CSS基础" class="headerlink" title="3、CSS基础"></a>3、CSS基础</h2><h3 id="1-选择器"><a href="#1-选择器" class="headerlink" title="(1) 选择器"></a>(1) 选择器</h3><table>
<thead>
<tr>
<th>选择器名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素选择器</td>
<td>通常选择某个 HTML 元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>允许以一种独立于文档元素的方式来指定样式，将类选择器的样式与元素关联，必须将元素class指定为一个对应的类名</td>
</tr>
<tr>
<td>id选择器</td>
<td>允许以一种独立于文档元素的方式来指定样式，将id选择器的样式与元素关联，必须将元素id指定为一个对应的值</td>
</tr>
<tr>
<td>属性选择器</td>
<td>可以根据元素的属性及属性值来选择元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>可以选择作为某元素后代的元素</td>
</tr>
<tr>
<td>子元素选择器</td>
<td>只能选择作为某元素子元素的元素</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>可选择紧接在另一元素后的元素，且二者有相同父元素</td>
</tr>
<tr>
<td>伪类</td>
<td>用于向某些选择器添加特殊的效果</td>
</tr>
<tr>
<td>伪元素</td>
<td>用于向某些选择器设置特殊效果</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;[注] 选择器优先级：</em><br><em>&emsp;&emsp;&emsp; 1)不同选择器优先级：!important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</em><br><em>&emsp;&emsp;&emsp; 2)不同一级别选择器优先级：同一级别中后写的会覆盖先写的样式；同一级别css引入方式不同，优先级不同：内联(行内)样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 导入样式(@import)</em></p>
<h3 id="2-样式"><a href="#2-样式" class="headerlink" title="(2) 样式"></a>(2) 样式</h3><p>&emsp;&emsp;HTML 的 style 属性，提供了一种改变所有 HTML 元素的样式的通用方法。<br>&emsp;&emsp;当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化处理。有三种方式来插入样式表：外部样式表、内部样式表、内联样式（后者优先级高于前者）。</p>
<p>&emsp;&emsp;1) 背景属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>背景设置简写属性</td>
</tr>
<tr>
<td>background-color</td>
<td>背景颜色</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图像（可设置多张图片，或者设置css3渐变效果）</td>
</tr>
<tr>
<td>background-repeat</td>
<td>背景图像是否及如何重复</td>
</tr>
<tr>
<td>background-position</td>
<td>背景图像的起始位置</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景图是否固定或者随着页面滚动</td>
</tr>
<tr>
<td>background-attachment</td>
<td>规定背景图像是否固定或者随着页面的其余部分滚动</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;2) 文本属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>颜色</td>
</tr>
<tr>
<td>direction</td>
<td>文本方向</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>text-indent</td>
<td>缩进文本</td>
</tr>
<tr>
<td>text-align</td>
<td>水平对齐</td>
</tr>
<tr>
<td>word-spacing</td>
<td>字间隔</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>字母间隔</td>
</tr>
<tr>
<td>text-transform</td>
<td>字符转换，如大小写转换</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本装饰</td>
</tr>
<tr>
<td>white-space</td>
<td>处理空白字符</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;3) 字体属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>font</td>
<td>简写属性（HTML5已不支持此属性）</td>
</tr>
<tr>
<td>font-family</td>
<td>字体系列</td>
</tr>
<tr>
<td>font-size</td>
<td>字体尺寸</td>
</tr>
<tr>
<td>font-style</td>
<td>字体风格</td>
</tr>
<tr>
<td>font-variant</td>
<td>以小型大写字体或者正常字体显示文本</td>
</tr>
<tr>
<td>font-weight</td>
<td>字体粗细</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;4) 尺寸属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>元素的宽度</td>
</tr>
<tr>
<td>height</td>
<td>元素的高度</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>max-height</td>
<td>元素的最大高度</td>
</tr>
<tr>
<td>max-width</td>
<td>元素的最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>元素的最小高度</td>
</tr>
<tr>
<td>min-width</td>
<td>元素的最小宽度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;5) 显示属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clear</td>
<td>设置一个元素的侧面是否允许其他的浮动元素</td>
</tr>
<tr>
<td>cursor</td>
<td>规定当指向某元素之上时显示的指针类型</td>
</tr>
<tr>
<td>display</td>
<td>设置是否及如何显示元素</td>
</tr>
<tr>
<td>float</td>
<td>定义元素在哪个方向浮动</td>
</tr>
<tr>
<td>position</td>
<td>把元素放置到一个静态的、相对的、绝对的、或固定的位置中</td>
</tr>
<tr>
<td>visibility</td>
<td>设置元素是否可见或不可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;6) 链接属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>创建指向另一个文档的链接</td>
</tr>
<tr>
<td>name</td>
<td>创建文档内的书签</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;<u>[注] 给链接设置样式时样注意合理的顺序：a:link、a:visited、a:hover、a:active</u></em></p>
<p>&emsp;&emsp;7) 列表属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>list-style</td>
<td>简写属性</td>
</tr>
<tr>
<td>list-style-image</td>
<td>列表项标志为图片</td>
</tr>
<tr>
<td>list-style-position</td>
<td>列表项标志的位置</td>
</tr>
<tr>
<td>list-style-type</td>
<td>列表项标志的类型</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;8) 表格属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>border-collapse</td>
<td>是否把表格边框合并为单一边框</td>
</tr>
<tr>
<td>border-spacing</td>
<td>分割单元格边框的距离</td>
</tr>
<tr>
<td>caption-side</td>
<td>表格标题的位置</td>
</tr>
<tr>
<td>empty-cells</td>
<td>是否显示表格中的空单元格</td>
</tr>
<tr>
<td>table-layout</td>
<td>设置显示单元、行和列的算法</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;9) 轮廓属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>outline</td>
<td>声明中设置所有的轮廓属性</td>
</tr>
<tr>
<td>outline-color</td>
<td>轮廓颜色</td>
</tr>
<tr>
<td>outline-style</td>
<td>轮廓样式</td>
</tr>
<tr>
<td>outline-width</td>
<td>轮廓宽度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;10) 框模型</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>padding</td>
<td>简写属性。作用是在一个声明中设置元素的所内边距属性</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>元素的下内边距</td>
</tr>
<tr>
<td>padding-left</td>
<td>元素的左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td>元素的右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td>元素的上内边距</td>
</tr>
<tr>
<td>border</td>
<td>简写属性，用于把针对四个边的属性设置在一个声明</td>
</tr>
<tr>
<td>border-style</td>
<td>用于设置元素所有边框的样式，或者单独地为各边设置边框样式</td>
</tr>
<tr>
<td>border-width</td>
<td>用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度</td>
</tr>
<tr>
<td>border-color</td>
<td>设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色</td>
</tr>
<tr>
<td>margin</td>
<td>简写属性。在一个声明中设置所有外边距属性</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>元素的下外边距</td>
</tr>
<tr>
<td>margin-left</td>
<td>元素的左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td>元素的右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td>元素的上外边距</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;11) 定位</p>
<p>&emsp;&emsp;CSS中三种定位机制：普通流、浮动与绝对定位。</p>
<p>&emsp;&emsp;① 在普通流中：<br>&emsp;&emsp;块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。<br>&emsp;&emsp;行内框在一行中水平排列。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度，由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。</p>
<p>&emsp;&emsp;② 浮动与清除浮动：<br>&emsp;&emsp;浮动（float）的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。不论何种元素，浮动会生成一个块级框。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。文本会环绕在浮动元素周围但文本过少可能会导致父元素高度塌陷，一般清除父元素的浮动来实现文本环绕图像的样式。<br>&emsp;&emsp;清除浮动（clear）属性定义了元素的哪一侧不允许出现浮动元素，设置了 clear 属性的元素会增加上外边距，即在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，<u>如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下，从而达到清除浮动的目的。</u><br>&emsp;&emsp;利用BFC（块级格式化上下文）的特性（BFC区域不会与float box重叠），也可以达到清除浮动的目的。</p>
<p>&emsp;&emsp;③ 绝对定位：<br>&emsp;&emsp;设置为绝对定位（position: absolute/fixed）的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素绝对定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>display</td>
<td>改变元素生成框的类型</td>
</tr>
<tr>
<td>position</td>
<td>定位元素到静态的、相对的、绝对的、或固定的位置</td>
</tr>
<tr>
<td>top</td>
<td>定位元素的上外边距边界与其包含块上边界之间的偏移</td>
</tr>
<tr>
<td>right</td>
<td>定位元素右外边距边界与其包含块右边界之间的偏移</td>
</tr>
<tr>
<td>bottom</td>
<td>定义了定位元素下外边距边界与其包含块下边界之间的偏移</td>
</tr>
<tr>
<td>left</td>
<td>定义了定位元素左外边距边界与其包含块左边界之间的偏移</td>
</tr>
<tr>
<td>overflow</td>
<td>设置当元素的内容溢出其区域时发生的事情</td>
</tr>
<tr>
<td>clip</td>
<td>设置元素的形状。元素被剪入这个形状之中，然后显示出来</td>
</tr>
<tr>
<td>vertical-align</td>
<td>置元素的垂直对齐方式</td>
</tr>
<tr>
<td>z-index</td>
<td>设置元素的堆叠顺序</td>
</tr>
</tbody></table>
<h2 id="4、CSS进阶"><a href="#4、CSS进阶" class="headerlink" title="4、CSS进阶"></a>4、CSS进阶</h2><p>&emsp;&emsp;(1) 水平对齐<br>&emsp;&emsp;margin 属性：可通过将左和右外边距设置为 “auto”，来对齐块元素。把左和右外边距设置为 auto，根据相应规则，会均等地分配可用的外边距实现水平居中。<br>&emsp;&emsp;position属性：通过绝对定位使元素会被从正常流中删除，并且能够交叠元素进行水平居中布局。<br>&emsp;&emsp;float属性：通过浮动进行定位使元素水平居中布局。</p>
<p>&emsp;&emsp;(2) 图片滤镜（<u>注意浏览器兼容!!!</u>  -webkit-, -ms- 或 -moz- ）<br>&emsp;&emsp;filter 属性定义了元素(通常是img)的可视效果。常用函数：blur(px)、brightness(%)、contrast(%)、grayscale(%)、opacity(%)。</p>
<h2 id="5、CSS3新能力"><a href="#5、CSS3新能力" class="headerlink" title="5、CSS3新能力"></a>5、<u>CSS3新能力</u></h2><p>&emsp;&emsp;CSS3的新特征有很多，例如选择器的添加、圆角效果、图形化边界、块阴影与文字阴影、使用RGBA实现透明效果、渐变效果、使用@font-face实现定制字体、多背景图、文字或图像的效果与变形处理（旋转、缩放、倾斜、移动）、多栏布局、媒体查询(@media)等。</p>
<p>&emsp;&emsp;1) 选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=”https”]</td>
<td>选择每一个src属性的值以”https”开头的元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=”.pdf”]</td>
<td>选择每一个src属性的值以”.pdf”结尾的元素</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=”abc”]</td>
<td>选择每一个src属性的值包含子字符串”abc”的元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的倒数第二个子元素</td>
</tr>
<tr>
<td>nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的倒数第二个p元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
</tr>
<tr>
<td><u>:target</u></td>
<td>#news:target</td>
<td>选择当前激活的#news元素（包含该锚名称的点击的URL）</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;2) 边框(圆角)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>border-image</td>
<td>设置所有边框图像的速记属性</td>
</tr>
<tr>
<td>box-shadow</td>
<td>附加一个或多个下拉框的阴影（可设置内/外阴影效果）</td>
</tr>
<tr>
<td>border-radius</td>
<td>用于设置所有四个边框圆角半径属性</td>
</tr>
<tr>
<td>border-top-left-radius</td>
<td>定义了左上角的弧度</td>
</tr>
<tr>
<td>border-top-right-radius</td>
<td>定义了右上角的弧度</td>
</tr>
<tr>
<td>border-bottom-right-radius</td>
<td>定义了右下角的弧度</td>
</tr>
<tr>
<td>border-bottom-left-radius</td>
<td>定义了左下角的弧度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;3) 背景</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background-clip</td>
<td>规定背景的绘制区域</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;4) 渐变</p>
<p>&emsp;&emsp;CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。（相关属性background-image）<br>&emsp;&emsp;CSS3 定义了两种类型的渐变（gradients）：</p>
<p>&emsp;&emsp;① 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: linear-gradient(direction, color-stop1, color-stop2, ...);</span><br><span class="line">background-image: linear-gradient(angle, color-stop1, color-stop2)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;② 径向渐变（Radial Gradients）- 由它们的中心定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: radial-gradient(shape size at position, start-color, ..., last-color)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<u>利用repeating-linear-gradient函数可以实现线形重复渐变效果定义：</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repeating-linear-gradient([ &lt;angle&gt; | to &lt;side-or-corner&gt; ,] ? &lt;color-stop&gt; [, &lt;color-stop&gt;]+)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5) 文本效果（文本字体可使用css3 @font-face属性自定义）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情</td>
</tr>
<tr>
<td>text-shadow</td>
<td>向文本添加阴影</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<em>[注1] 单行文本超出隐藏</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123; &#x2F;&#x2F; 有一定宽度的包含元素</span><br><span class="line">  white-space: nowrap; &#x2F;&#x2F; 如何处理包含元素内的空白：文本不会换行，文本会在在同一行上继续，直到遇到&lt;br&gt;标签为止</span><br><span class="line">  text-overflow: ellipsis; &#x2F;&#x2F; 文本溢出包含元素发生事情：显示省略符号来代表被修剪的文本</span><br><span class="line">  overflow: hidden; &#x2F;&#x2F; 内容溢出包含元素发生的事情：内容修剪且不可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<em>[注2]  多行文本超出隐藏（适用于WebKit浏览器及移动端，不同浏览器要添加对应修饰符）</em></p>
<p>&emsp;&emsp;<em>原理：利用了css弹性盒子模型flex-box，可以理解为flex弹性盒子旧的规则，有兼容性问题。在不同的浏览器中声明：display: -moz-box / -webkit-box / box。有box-orient（子元素的排列方向，有horizontal、vertical等取值）, box-direction（子元素的排列顺序，取值有normal、reverse、inherit）, box-align（垂直方向上的空间利用，即对齐方式，有start、end、center等取值）, box-pack（水平方向上的空间利用，即对齐方式，有start、end、center等取值）, box-lines（子元素是可以换行显示，取值有single、multiple）属性来设置子元素的排列方式。再结合-webkit-line-clamp属性（块元素显示的文本的行数，不规范属性，未在css规范草案中）等属性来实现多行显示省略号</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123; </span><br><span class="line">  display: -webkit-box; &#x2F;&#x2F; 布局方式：flex-box弹性盒子</span><br><span class="line">  -webkit-box-orient: vertical; &#x2F;&#x2F; 盒子内子元素排列方向：子元素纵向排列</span><br><span class="line">  -webkit-line-clamp: 3; &#x2F;&#x2F; css不规范属性-webkit-line-clamp：块元素显示的文本的行数为3 （有兼容问题）</span><br><span class="line">  text-overflow: ellipsis; &#x2F;&#x2F; 文本溢出包含元素发生事情：显示省略符号来代表被修剪的文本</span><br><span class="line">  overflow: hidden; &#x2F;&#x2F; 内容溢出包含元素发生的事情：内容修剪且不可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<em>[注3] 多行文本超出隐藏（跨浏览器兼容方案）</em></p>
<p>&emsp;&emsp;<em>父元素使用相对高度，高度是文本行高的相应倍数来显示相应行数的文本，使用对位来放置 ‘…’ 的位置来达到超出隐藏的要求</em></p>
<p>&emsp;&emsp;6) 2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你更改一个元素变形的原点(该属性必须与transform属性一同使用)</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;7) 过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript就能完成简单动画</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td><u>transition-timing-function</u></td>
<td>规定过渡效果的时间曲线(时序函数)，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;8) 动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果，您可以改变任意多的样式任意多的次数。可以实现相对复杂的动画。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes name</span><br><span class="line">&#123;</span><br><span class="line">  0%   &#123; &#x2F;&#x2F; 状态1 &#125;</span><br><span class="line">  ...</span><br><span class="line">  xx%  &#123; &#x2F;&#x2F; 状态x &#125;</span><br><span class="line">  ...</span><br><span class="line">  100% &#123; &#x2F;&#x2F; 状态n &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 自定义动画的使用</span><br><span class="line">animation: name duration timing-function delay iteration-count direction;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)</span><br><span class="line">&#x2F;&#x2F; iteration-count的取值: n(次数)、infinite</span><br><span class="line">&#x2F;&#x2F; animation-direction的取值: normal、alternate</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定 @keyframes 动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;10) 多列布局  （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column-count</td>
<td>指定元素应该被分割的列数</td>
</tr>
<tr>
<td>column-gap</td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td>column-rule</td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td>column-rule-color</td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td>column-rule-style</td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td>column-rule-width</td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td>column-span</td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td>column-width</td>
<td>指定列的宽度</td>
</tr>
<tr>
<td>columns</td>
<td>column-width 与 column-count 的简写属性</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;11) 媒体查询(@media)</p>
<p>&emsp;&emsp;媒体查询非常实用，可以根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如根据屏幕分辨率和浏览器视窗宽度）来设置更合理的样式等</p>
<pre><code>  &lt;link rel=&quot;stylesheet&quot; src=&quot;styleA.css&quot; media=&quot;screen&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; src=&quot;styleB.css&quot; media=&quot;print&quot; /&gt;
</code></pre>
<p>&emsp;&emsp;每条媒体查询语句都由一个可选的媒体类型和任意数量的媒体特性表达式构成。可以使用多种逻辑操作符合并多条媒体查询语句。媒体查询语句不区分大小写。<br>&emsp;&emsp;当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。</p>
<p><em>&emsp;&emsp;[注] <u>即使媒体查询返回false，带有媒体查询附加到其&lt;link&gt;标记的样式表仍将下载</u>，但只有媒体查询为true的对应样式文件才被使用</em></p>
<p>&emsp;&emsp;<u>逻辑操作符 not, and, 和 only 可用于联合构造复杂的媒体查询，可用逗号(,)分隔多个媒体查询，将它们组合为一个规则。</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户设备的宽度介于 300px 到 500px 的设备</span><br><span class="line">@media (min-width: 300px) and (max-width: 500px) &#123; ... &#125;</span><br><span class="line">&#x2F;&#x2F; 用户设备的最小高度为680px或为纵向模式的屏幕设备</span><br><span class="line">@media (min-height: 680px), screen and (orientation: portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、其他CSS属性"><a href="#6、其他CSS属性" class="headerlink" title="6、其他CSS属性"></a>6、其他CSS属性</h2><p>&emsp;&emsp;(1) <u>mask</u>（通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域）<br>&emsp;&emsp;(2) <u>clip-path</u>（使用裁剪方式创建元素的可显示区域，结合transform、transition能作出惊艳的动画效果）<br>&emsp;&emsp;(3) <u>offset</u> （CSS快速定义元素沿相关路径运动）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局类型（Display、Flex、Grid）</title>
    <url>/2020/09/27/css/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/</url>
    <content><![CDATA[<p>display属性规定元素应该生成的框的类型。display 属性可以设置元素的内部和外部等显示类型 display type。元素的外部显示类型 outer display type 将决定该元素在流式布局中的表现（块级或内联元素）；元素的内部显示类型 inner display type 可以控制其子元素的布局（如 flow layout，grid 或 flex）</p>
<p>display 属性使用关键字取值来指定，关键字取值被分为六类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;display-outside&gt; &#x3D; block | inline | run-in</span><br><span class="line">&lt;display-inside&gt; &#x3D; flow | flow-root | table | flex | grid | ruby</span><br><span class="line">&lt;display-listitem&gt; &#x3D; list-item</span><br><span class="line">&lt;display-internal&gt; &#x3D; table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container</span><br><span class="line">&lt;display-box&gt; &#x3D; contents | none</span><br><span class="line">&lt;display-legacy&gt; &#x3D; inline-block | inline-list-item | inline-table | inline-flex | inline-grid</span><br></pre></td></tr></table></figure>
<p>这里主要介绍前两类display-outside与display-inside</p>
<h2 id="1、display-outside类型"><a href="#1、display-outside类型" class="headerlink" title="1、display-outside类型"></a>1、display-outside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的外部显示类型，实际上就是其在流式布局中的角色（即在流式布局中的表现）<br>&emsp;&emsp;block：此元素将显示为块级元素，此元素前后会带有换行符<br>&emsp;&emsp;inline：默认值，此元素会被显示为内联元素，元素前后没有换行符<br>&emsp;&emsp;run-in：此元素会根据上下文作为块级元素或内联元素显示</p>
<p><em>&emsp;&emsp;[注]如果 run-in box 包含 block box，那么这个 run-in box 也成为 block box；如果紧跟在 run-in box 之后的兄弟节点是 block box，那么这个 run-in box 就会做为此 block box 里的 inline box（run-in box 不能进入已经一个已经以 run-in box 开头的块内，也不能进入本身就是 display:run-in的块内）；否则，run-in box 都将成为 block box</em></p>
<h2 id="2、display-inside类型"><a href="#2、display-inside类型" class="headerlink" title="2、display-inside类型"></a>2、display-inside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的内部显示类型，它们定义了该元素内部内容的布局方式。<br>&emsp;&emsp;flow：元素使用流布局（块和内联布局）布局其内容<br><em>&emsp;&emsp;[注] 如果其外部显示类型为inline或run-in，并且它参与了块或内联格式设置上下文，则它将生成一个内联框。否则，它将生成一个块容器框</em><br>&emsp;&emsp;flow-root：该元素生成一个块元素框，该框将建立一个新的块格式化上下文，定义格式化根所在的位置<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 &lt;table&gt; ），表格前后带有换行符<br>&emsp;&emsp;flex：元素的行为类似于block元素，并根据flex box模型布置其内容<br>&emsp;&emsp;grid: 元素的行为类似于块元素，并根据网格模型布置其内容<br>&emsp;&emsp;ruby: 元素的行为类似于内联元素，并根据ruby格式化模型布置其内容。它的行为类似于相应的HTML &lt;ruby&gt;元素</p>
<h3 id="emsp-emsp-1-Flex布局"><a href="#emsp-emsp-1-Flex布局" class="headerlink" title="&emsp;&emsp;1) Flex布局"></a>&emsp;&emsp;1) Flex布局</h3><p>&emsp;&emsp;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”，Flex 容器有主轴与交叉轴两个方向。<br><img src="/images/css3/Flex%E5%AE%B9%E5%99%A8.png" alt="Flex容器"></p>
<p>&emsp;&emsp;<strong>(1) Flex容器的属性：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</strong></p>
<p>&emsp;&emsp;① flex-direction属性决定主轴的方向（即项目的排列方向）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/flex-direction%E5%B1%9E%E6%80%A7.png" alt="flex-direction属性"></p>
<p>&emsp;&emsp;row（默认值）：主轴为水平方向，起点在左端<br>&emsp;&emsp;row-reverse：主轴为水平方向，起点在右端<br>&emsp;&emsp;column：主轴为垂直方向，起点在上沿<br>&emsp;&emsp;column-reverse：主轴为垂直方向，起点在下沿</p>
<p>&emsp;&emsp;② flex-warp属性决定项目排列超过容器宽度时是否换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/flex-warp%E5%B1%9E%E6%80%A7.png" alt="flex-warp属性"></p>
<p>&emsp;&emsp;nowrap(默认)：不换行<br>&emsp;&emsp;wrap：换行，首行在上方<br>&emsp;&emsp;wrap-reserve：换行，首行在下方</p>
<p>&emsp;&emsp;③ flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;④ justify-content属性定义了项目在主轴上的对齐方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/justify-content%E5%B1%9E%E6%80%A7.png" alt="justify-content属性"></p>
<p>&emsp;&emsp;flex-start（默认值）：左对齐<br>&emsp;&emsp;flex-end：右对齐<br>&emsp;&emsp;center： 居中<br>&emsp;&emsp;space-between：两端对齐，项目之间的间隔都相等<br>&emsp;&emsp;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</p>
<p>&emsp;&emsp;⑤ align-items属性定义项目在交叉轴上如何对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/align-items%E5%B1%9E%E6%80%A7.png" alt="align-items属性"></p>
<p>&emsp;&emsp;flex-start：交叉轴的起点对齐<br>&emsp;&emsp;flex-end：交叉轴的终点对齐<br>&emsp;&emsp;center：交叉轴的中点对齐<br>&emsp;&emsp;baseline: 项目的第一行文字的基线对齐<br>&emsp;&emsp;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</p>
<p>&emsp;&emsp;⑥ align-content属性定义了多根轴线的对齐方式（如果项目只有一根轴线，该属性不起作用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;flex-start：与交叉轴的起点对齐<br>&emsp;&emsp;flex-end：与交叉轴的终点对齐<br>&emsp;&emsp;center：与交叉轴的中点对齐<br>&emsp;&emsp;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>&emsp;&emsp;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍<br>&emsp;&emsp;stretch（默认值）：轴线占满整个交叉轴</p>
<p>&emsp;&emsp;<strong>(2)Flex项目的属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self</strong></p>
<p>&emsp;&emsp;① order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order: &lt;integer&gt;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;② flex-grow属性定义项目的放大比例（整体布局存在剩余空间），默认为0，即如果存在剩余空间，也不放大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-grow: &lt;number&gt;; &#x2F;* default 0 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>&emsp;&emsp;③ flex-shrink属性定义了项目的缩小比例（整体布局空间不足），默认为1，即如果空间不足，该项目将缩小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-shrink: &lt;number&gt;; &#x2F;* default 1 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>&emsp;&emsp;④ flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; &#x2F;* default auto *&#x2F;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可设与width或height属性明确的值（比如200px，则项目将占据固定空间）。</p>
<p>&emsp;&emsp;⑤ flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: none | [ &lt;flex-grow&gt; || &lt;flex-shrink&gt;? || &lt;flex-basis&gt;? ]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>&emsp;&emsp;⑥ align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h3 id="emsp-emsp-2-Grid布局"><a href="#emsp-emsp-2-Grid布局" class="headerlink" title="&emsp;&emsp;2) Grid布局"></a>&emsp;&emsp;2) Grid布局</h3><p>&emsp;&emsp;将网页划分成一个个网格，可以任意组合不同的网格。Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可看作是二维布局。Grid 布局远比 Flex 布局强大。同样的，grid布局中也有容器与项目的概念。<br>&emsp;&emsp;grid布局将容器分为行和列，行和列的交叉区域称为单元格<strong>（区域）</strong>。正常情况下，n行和m列会产生n x m个单元格（可能有跨行与跨列等布局状态）。<br>&emsp;&emsp;容器中划分网格的线，称为”网格线”。水平网格线划分出行，垂直网格线划分出列。正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线。<br><img src="/images/css3/Grid%E5%AE%B9%E5%99%A8.png" alt="Grid容器"></p>
<p>&emsp;&emsp;<strong>(1) Grid容器的属性：</strong><br>&emsp;&emsp;grid-template-columns、grid-template-rows（容器划分行和列）<br>&emsp;&emsp;grid-row-gap、grid-columns-gap、grid-gap（行与行、列于列的间距）<br>&emsp;&emsp;grid-template-areas（网格布局给区域命名）<br>&emsp;&emsp;grid-auto-flow（容器中放置项目顺序设置，如先行后列，是否紧密填满）<br>&emsp;&emsp;justify-items、align-items、place-items（单元格内元素水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-content、align-content、place-content（容器中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;grid-auto-columns、grid-auto-rows（超出容器项目的行、列设置）<br>&emsp;&emsp;grid-template、grid（简写属性）</p>
<p>&emsp;&emsp;① grid-template-columns、grid-template-rows属性<br>&emsp;&emsp;容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。下面以列宽设置为例，行高设置同理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-rows: [R1]100px [R2]100px [R3]100px[R4]; &#x2F;&#x2F; 设置网格线名称（网格线有多个名称，默认为1、2、3...)）</span><br><span class="line">  &#x2F;&#x2F; 1、px设置行宽</span><br><span class="line">  grid-template-columns: [C1]100px [C2]100px [C3]100px[C4]; &#x2F;&#x2F; 设置网格线名称</span><br><span class="line"> &#x2F;&#x2F; 2、百分比设置行宽</span><br><span class="line">  grid-template-columns: 33.33% 33.33% 33.33%;</span><br><span class="line">  &#x2F;&#x2F; 3、repeat()重复行宽设置，也可重复某一模式</span><br><span class="line">  grid-template-columns: repeat(3, 33.33%);</span><br><span class="line">  &#x2F;&#x2F; 4、auto-fill关键字自动填充列</span><br><span class="line">  grid-template-columns: repeat(auto-fill, 100px);</span><br><span class="line">  &#x2F;&#x2F; 5、fr关键字按比例划分列宽</span><br><span class="line">  grid-template-columns: 150px 1fr 2fr;</span><br><span class="line">  &#x2F;&#x2F; 6、minmax()函数设置某一列宽范围</span><br><span class="line">  grid-template-columns: 1fr 1fr minmax(100px, 1fr);</span><br><span class="line">  &#x2F;&#x2F; 7、auto关键字列宽自适应</span><br><span class="line">  grid-template-columns: 100px auto 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/grid-template%E5%B1%9E%E6%80%A7.png" alt="grid-template属性"></p>
<p>&emsp;&emsp;② grid-row-gap、grid-columns-gap、grid-gap属性<br>&emsp;&emsp;grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。grid-gap为行列间距两属性的简写属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> .container &#123;</span><br><span class="line">   grid-row-gap: 20px;</span><br><span class="line">   grid-column-gap: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/grid-gap%E5%B1%9E%E6%80%A7.png" alt="grid-gap属性"></p>
<p>&emsp;&emsp;③ grid-template-areas属性<br>&emsp;&emsp;网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。<br><em>&emsp;&emsp;[注] 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &#39;A B C&#39; &#39;D . F&#39; &#39;G H I&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/grid-template-areas%E5%B1%9E%E6%80%A7.png" alt="grid-template-areas属性"></p>
<p>&emsp;&emsp;④ grid-auto-flow属性<br>&emsp;&emsp;划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。</p>
<p><img src="/images/css3/grid-auto-flow%E5%B1%9E%E6%80%A7.png" alt="grid-auto-flow属性"></p>
<p>&emsp;&emsp;⑤ justify-items 、align-items、place-items 属性（设置单元格内容的位置）<br>&emsp;&emsp;justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。place-items属性是align-items属性和justify-items属性的合并简写形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123; </span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  align-items: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;start：对齐单元格的起始边缘<br>&emsp;&emsp;end：对齐单元格的结束边缘<br>&emsp;&emsp;center：单元格内部居中<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p>&emsp;&emsp;⑥ justify-content 、align-content、place-content属性（设置整个内容区域在容器里面的的位置）<br>&emsp;&emsp;justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。place-content属性是align-content属性和justify-content属性的合并简写形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;start - 对齐容器的起始边框<br>&emsp;&emsp;end - 对齐容器的结束边框<br>&emsp;&emsp;center - 容器内部居中<br>&emsp;&emsp;stretch - 项目大小没有指定时，拉伸占据整个网格容器<br>&emsp;&emsp;space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍<br>&emsp;&emsp;space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔<br>&emsp;&emsp;space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p>
<p>&emsp;&emsp;⑦ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;当项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。grid-auto-columns属性和grid-auto-rows属性用来设置浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>&emsp;&emsp;⑧ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。<br>&emsp;&emsp;grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<p>&emsp;&emsp;<strong>(2) Grid项目的属性：</strong><br>&emsp;&emsp;grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column、grid-row（设置项目位置简写属性）<br>&emsp;&emsp;grid-area（指定项目放置的区域）<br>&emsp;&emsp;justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）</p>
<p>&emsp;&emsp;① grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column-start属性：左边框所在的垂直网格线<br>&emsp;&emsp;grid-column-end属性：右边框所在的垂直网格线<br>&emsp;&emsp;grid-row-start属性：上边框所在的水平网格线<br>&emsp;&emsp;grid-row-end属性：下边框所在的水平网格线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item_1&#123;</span><br><span class="line">  grid-column-start: 2;</span><br><span class="line">  grid-row-start: 2;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-end: 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/Grid%E9%A1%B9%E7%9B%AE%E4%BD%8D%E7%BD%AE.png" alt="Grid项目位置"></p>
<p><em>&emsp;&emsp;[注] 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 如: grid-column-start:  span 2; 必要的时候，可使用z-index设置项目重叠顺序</em></p>
<p>&emsp;&emsp;② grid-column、grid-row属性<br>&emsp;&emsp;grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的简写形式，属性值取值用用’/‘分割</p>
<p>&emsp;&emsp;③ grid-area属性<br>&emsp;&emsp;grid-area属性指定项目放在哪一个区域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: &#39;I&#39;; &#x2F;&#x2F; I是grid-template-areas属性指定的区域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/css3/grid-area%E5%B1%9E%E6%80%A7.png" alt="grid-area属性"></p>
<p><em>&emsp;&emsp;[注] grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的简写形式来指定项目位置。形如：grid-area: row-start / column-start / row-end / column-end; 属性值间取值用’/‘分割，上图的设置相当于：grid-area:  2 / 2 / 3 / 3;</em></p>
<p>&emsp;&emsp;④ justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目<br>&emsp;&emsp;align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  align-self: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;start：对齐单元格的起始边缘。<br>&emsp;&emsp;end：对齐单元格的结束边缘。<br>&emsp;&emsp;center：单元格内部居中。<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p><em>&emsp;&emsp;[注] g place-self属性是align-self属性和justify-self属性的简写形式。当省略第二个值时，place会默认这两个属性值相等</em></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS原型（prototype）链与继承（Class）</title>
    <url>/2020/12/23/javascript/JS%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Class%EF%BC%89/</url>
    <content><![CDATA[<p>在JavaScript中，每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。几乎所有 JavaScript 中的对象都是位于原型链顶端的Object对象的实例。</p>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>&emsp;&emsp;对象：对象是一个包含相关数据和方法的集合，通常由一些变量和函数组成，我们称之为对象里面的属性和方法。对象成员的值可以是任意的，例如Number，String，Function，null， undefined等。</p>
<p><em>&emsp;&emsp;[注1] 可以使用点表示法或者括号([ ])表示法访问对象的成员，对象做了字符串(key)到值(value)的映射，而数组做的是数字(索引)到值的映射。其中，括号表示法一个特别的地方是不仅可以动态的去设置对象成员的值，还可以动态的设置成员的名字(key)。</em><br><em>&emsp;&emsp;[注2] 可以用一个对象来做另一个对象成员的值，这样，实际上创建了一个子命名空间，可以链式的使用点表示法或括号表示法去访问其中的成员变量。</em></p>
<p>&emsp;&emsp;<u>面向对象的JavaScript</u>（OOJS）：面向对象编程（OOP）的基本思想为，在程序里，我们通过使用对象去构建现实世界的模型，把原本很难（或不可）能被使用的功能，简单化并提供出来，以供访问。对象可以包含相关的数据和代码，去描述模型以及模型具有的行为和功能。对象包（命名空间）存储（封装）着对象的数据与方法，使数据的组织和访问变得更容易了；对象也常用作数据存储体，用于在网络上运输数据，十分便捷。</p>
<p>&emsp;&emsp;<u>构造函数对象</u>：JavaScript 用一种称为构建函数的特殊函数(function)来定义对象和它们的特征。一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。关键字 new 跟着一个含参构造函数，便能创建一个想要的对象（对象的原型指向构建函数）。其中，这个构建函数是 JavaScript 版本的类（<u>ES6已提供class关键字的语法糖定义构建函数</u>）。</p>
<p><em>&emsp;&emsp;[注] 其他创建对象的方式：</em><br><em>&emsp;&emsp;① 字面量定义对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;② Object()构造函数，即使用new Object()创建对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;③ Object.create()方法，允许您基于现有对象创建新的对象。（对象的原型指向创建时指定的对象）</em></p>
<h2 id="1、原型（链）"><a href="#1、原型（链）" class="headerlink" title="1、原型（链）"></a>1、原型（链）</h2><p>&emsp;&emsp;JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层，以此类推。这种关系常被称为原型链，它解释了为何一个对象会拥有定义在其他(被继承)对象中的属性和方法。比如有些属性和方法定义在Object的构造器函数的prototype属性上，而非定义在当前对象实例本身。</p>
<p><em>&emsp;&emsp;<strong>[注1] 与传统OOP的区别：在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到例中。<u>在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是 __proto__ 属性，是从构造函数的 prototype 属性派生的），</u>可通过其上溯原型链，在构造器中找到对应的属性和方法。</strong></em><br><em>&emsp;&emsp;[注2] 对象原型（可以通过Object.getPrototypeOf(obj)或者浏览器提供的__proto__属性获得）与构造函数的prototype属性是有区别的：前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Bool())和Bool.prototype指向着同一个对象(Bool构造函数)。<u>特别的，没有官方的方法用于直接访问一个对象的原型——原型链中的“连接”被定义在一个内部属性中，</u>在 JavaScript 语言标准中用 [[prototype]] 表示，大多数现代浏览器还是提供了一个名为 __proto__ 属性，其包含了对象的原型。</em></p>
<p>&emsp;&emsp;(1) prototype属性：继承成员被定义的地方<br>&emsp;&emsp;继承的属性和方法是定义在 prototype 属性之上的（可以称之为子命名空间），prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。<br><em>&emsp;&emsp;[注] Object.create()可以指定一个对象作为原型对象来创建一个实例对象。</em></p>
<p>&emsp;&emsp;(2) constructor属性：指向了用于构造此实例对象的构造函数<br>&emsp;&emsp;每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。<br>&emsp;&emsp;在某些情况下，没有原始构造器的引用，想要构造实例可以通过已有实例的constructor属性指向的构造函数来完成。即可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），只需在前面添加 new 关键字（let person2 = new person1.constructor()），便能将此函数作为构造器使用，从而调用这个构造器创建另一个对象实例。</p>
<p><em>&emsp;&emsp;[注] 构建函数前new关键字做了什么？</em><br><em>&emsp;&emsp;① 创建一个新对象</em><br><em>&emsp;&emsp;② 将新对象的__proto__属性指向了构建函数对象prototype对象</em><br><em>&emsp;&emsp;③ 将构建函数的this修正为指向新对象，执行构造函数中的代码，即为这个新对象添加对应属性</em><br><em>&emsp;&emsp;④ 返回新对象</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.__proto__ &#x3D; Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure>
<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><h3 id="JavaScript基于原型链继承（prototypal-inheritance）"><a href="#JavaScript基于原型链继承（prototypal-inheritance）" class="headerlink" title="JavaScript基于原型链继承（prototypal inheritance）"></a>JavaScript基于原型链继承（prototypal inheritance）</h3><p>&emsp;&emsp;如何实现继承：（这里以Teacher构造函数继承于Person构造函数的例子来说明）<br>&emsp;&emsp;(1) 定义构造器（构造函数），这里定义构造函数Person。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, gender, interests) &#123;</span><br><span class="line">  this.name &#x3D;name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.gender &#x3D; gender;</span><br><span class="line">  this.interests &#x3D; interests;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.greeting &#x3D; function() &#123;</span><br><span class="line">  console.log(&#96;hello, I am $&#123;name&#125;!&#96;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(2) 创建继承于Person构造函数的Teacher构造函数，并为Teacher 构造函数添加特有的subject（所授学科科目）属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Teacher(name, age, gender, interests, subject) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个新的对象实例时同时指派其继承的属性（修正this指向Teacher()函数）</span><br><span class="line">  Person.call(this, name, age, gender, interests);</span><br><span class="line">  this.subject &#x3D; subject;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，从而继承其属性与方法</span><br><span class="line">  Teacher.prototype &#x3D; Object.create(Person.prototype);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 修正Teacher构造器指向，使之与Teacher关联(修正前指向Person)</span><br><span class="line">  Teacher.prototype.constructor &#x3D; Teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 每一个函数对象（Function）都有一个 prototype 属性，并且只有函数对象有 prototype 属性，因为 prototype 本身就是定义在Function对象下的属性。其中Person()函数是Person.prototype的构造函数，即Person===Person.prototype.constructor。任何您想要被继承的方法都应该定义在构造函数的 prototype 对象里，并且永远使用父类的 prototype 来创造子类的 prototype，这样才不会打乱类继承结构。</em></p>
<p>&emsp;&emsp;(3) Teacher构造函数添加新的greeting成员函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher.prototype.greeting &#x3D; function()&#123;</span><br><span class="line">  console.log(&#96;hello, I am a teather, I teath $&#123;this.subject&#125;&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(4) 生成对应的teacher实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let t &#x3D; new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);</span><br><span class="line">t.greeting(); &#x2F;&#x2F; hello, I am a teather, I teath englis</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所有代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age, gender, interests) &#123;    </span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.gender &#x3D; gender;</span><br><span class="line">  this.interests &#x3D; interests;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.greeting &#x3D; function () &#123;</span><br><span class="line">  console.log(&#96;hello, I am $&#123;name&#125;!&#96;);</span><br><span class="line">&#125;;</span><br><span class="line">function Teacher(name, age, gender, interests, subject) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个新的对象实例时同时指派其继承的所有属性（修正this指向Teacher()函数）</span><br><span class="line">  Person.call(this, name, age, gender, interests);</span><br><span class="line">  this.subject &#x3D; subject;</span><br><span class="line">  &#x2F;&#x2F; Teacher.prototype现在会继承Person.prototype的所有属性和方法</span><br><span class="line">  Teacher.prototype &#x3D; Object.create(Person.prototype);</span><br><span class="line">  &#x2F;&#x2F; 修正Teacher()的prototype的constructor属性指向(修正前指向Person，不正确)</span><br><span class="line">  Teacher.prototype.constructor &#x3D; Teacher;</span><br><span class="line">&#125;</span><br><span class="line">Teacher.prototype.greeting &#x3D; function()&#123;</span><br><span class="line">  console.log(&#96;hello, I am a teather, I teath $&#123;this.subject&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line">let t &#x3D; new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);</span><br><span class="line">t.greeting(); &#x2F;&#x2F; hello, I am a teather, I teath englis</span><br></pre></td></tr></table></figure>
<h3 id="ES6-类（class）"><a href="#ES6-类（class）" class="headerlink" title="ES6 类（class）"></a>ES6 类（class）</h3><p>&emsp;&emsp;(1) 类的定义方式<br>&emsp;&emsp;ES6 提供了更接近传统语言的写法，引入了class关键字（仅是一个‘语法糖’），可以定义类。可以使编码时逻辑更加清晰明了。在JavaScript中，类是一种“特殊的函数”。类本身就指向构造函数。</p>
<p><em>&emsp;&emsp;[注] 类都在严格模式下执行。类的内部所有定义的方法，都是不可枚举的（这点与 ES5 定义在 prototype 上的方法表现不一致）。定义类的实例必须使用new关键字（不能像 ES5 中的构造函数可直接调用）。</em></p>
<p>&emsp;&emsp;定义类有两种方式：<br>&emsp;&emsp;类声明：class A {}，<strong>类声明不会提升，需要先声明，再访问</strong><br>&emsp;&emsp;类表达式: let B = class [B2] {}，类表达式的命名是可选的（比如这里命名为B2），名称称为局部名称，可使用类的name属性访问对应名称</p>
<p><em>&emsp;&emsp;<strong>[注] 类中的this：</strong></em><br>&emsp;&emsp;① 在构造函数constructor()中基类与派生类this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象（指向实例），所有非静态方法会被添加到this的原型中。在派生类（子类）中的构造函数没有初始的this绑定（undefined），在构造函数中调用super()才能生成一个this绑定（返回一个指向当前派生类的this）。<br>&emsp;&emsp;② 静态方法不是this的属性，它们只是类自身的属性，不会被子类继承。派生类在super()前调用this会抛出异常，派生类不能在调用super()前返回，除非没有构造函数或者构造函数返回了对象。<br>&emsp;&emsp;③ 使用super对象时，super 调用父类的方法时，super 会绑定子类的 this。</p>
<p>&emsp;&emsp;(2) constructor()构造函数<br>&emsp;&emsp;初始化一个由class创建的对象。一个类中只能有唯一的constructor()方法，若代码未显式的定义，会默认添加该方法。在使用new关键字创建实例时，会执行该方法，其中的this指向创建的实例。默认会返回this实例，不过也可以显式的返回一个对象。</p>
<p>&emsp;&emsp;(3) super关键字<br>&emsp;&emsp;分为两种情况：<br>&emsp;&emsp;当做 super() 函数使用：这个函数会调用父类的构造函数，返回一个指向当前派生类的this，相当于A.prototype.constructor.call(this, props)<br>&emsp;&emsp;当做 super 对象使用：在普通方法中，super 指向父类的原型对象；在静态方法中，super 指向父类</p>
<p><em>&emsp;&emsp;[注] 静态方法，static修饰，可以被子类继承，但不会添加到类的实例上，方法名称可与其他方法重名。静态方法可以通过super调用。</em></p>
<p>&emsp;&emsp;(4) 取值函数（getter）和存值函数（setter）<br>&emsp;&emsp;在类中内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为（ES5可以提供getter、setter函数）。</p>
<p>&emsp;&emsp;(5) new.target属性<br>&emsp;&emsp;new命令的一个属性，只能在构造函数中使用。在类中使用时，返回当前类；在子类中使用时，返回当前子类。<u>用途：可以限制类只能通过new命令调用；或者编写只能继承而不能实例化的基类。</u></p>
<p>&emsp;&emsp;通过ES6 Class关键字实现上面Teacher类与Person类的继承关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;    </span><br><span class="line">  constructor(name, age, gender, interests)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.gender &#x3D; gender;</span><br><span class="line">    this.interests &#x3D; interests;</span><br><span class="line">  &#125;</span><br><span class="line">  greeting()&#123;</span><br><span class="line">    console.log(&quot;hello, I am &quot; + this.name + &quot;!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teather extends Person&#123;</span><br><span class="line">  constructor(name, age, gender, interests, subject)&#123;</span><br><span class="line">    super(name, age, gender, interests);</span><br><span class="line">    this.subject &#x3D; subject;</span><br><span class="line">  &#125;</span><br><span class="line">  greeting()&#123;</span><br><span class="line">    console.log(&quot;hello, I am a teather, I teath &quot; + this.subject + &quot;!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let t &#x3D; new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);</span><br><span class="line">t.greeting() &#x2F;&#x2F; hello, I am a teather, I teath english!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过Babel.js将上面的ES6转换为ES5代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function _typeof(obj) &#123;</span><br><span class="line">  &quot;@babel&#x2F;helpers - typeof&quot;;</span><br><span class="line">  if (typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; typeof Symbol.iterator &#x3D;&#x3D;&#x3D; &quot;symbol&quot;) &#123; _typeof &#x3D; function _typeof(obj) &#123; return typeof obj; &#125;; &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    _typeof &#x3D; function _typeof(obj) &#123;</span><br><span class="line">      return obj &amp;&amp; typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; obj.constructor &#x3D;&#x3D;&#x3D; Symbol &amp;&amp; obj !&#x3D;&#x3D; Symbol.prototype ? &quot;symbol&quot; : typeof obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits(subClass, superClass) &#123;</span><br><span class="line">  if (typeof superClass !&#x3D;&#x3D; &quot;function&quot; &amp;&amp; superClass !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new TypeError(&quot;Super expression must either be null or a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  subClass.prototype &#x3D; Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125; &#125;);</span><br><span class="line">  if (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _setPrototypeOf(o, p) &#123;</span><br><span class="line">  _setPrototypeOf &#x3D; Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123;</span><br><span class="line">    o.__proto__ &#x3D; p; return o;</span><br><span class="line">  &#125;;</span><br><span class="line">  return _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _createSuper(Derived) &#123;</span><br><span class="line">  var hasNativeReflectConstruct &#x3D; _isNativeReflectConstruct();</span><br><span class="line">  return function _createSuperInternal() &#123;</span><br><span class="line">    var Super &#x3D; _getPrototypeOf(Derived), result;</span><br><span class="line">    if (hasNativeReflectConstruct) &#123;</span><br><span class="line">      var NewTarget &#x3D; _getPrototypeOf(this).constructor;</span><br><span class="line">      result &#x3D; Reflect.construct(Super, arguments, NewTarget);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result &#x3D; Super.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return _possibleConstructorReturn(this, result);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _possibleConstructorReturn(self, call) &#123;</span><br><span class="line">  if (call &amp;&amp; (_typeof(call) &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof call &#x3D;&#x3D;&#x3D; &quot;function&quot;)) &#123;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line">  return _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _assertThisInitialized(self) &#123;</span><br><span class="line">  if (self &#x3D;&#x3D;&#x3D; void 0) &#123;</span><br><span class="line">    throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _isNativeReflectConstruct() &#123;</span><br><span class="line">  if (typeof Reflect &#x3D;&#x3D;&#x3D; &quot;undefined&quot; || !Reflect.construct) return false;</span><br><span class="line">  if (Reflect.construct.sham) return false;</span><br><span class="line">  if (typeof Proxy &#x3D;&#x3D;&#x3D; &quot;function&quot;) return true;</span><br><span class="line">  try &#123;</span><br><span class="line">    Date.prototype.toString.call(Reflect.construct(Date, [], function () &#123; &#125;));</span><br><span class="line">    return true;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _getPrototypeOf(o) &#123;</span><br><span class="line">  _getPrototypeOf &#x3D; Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123;</span><br><span class="line">    return o.__proto__ || Object.getPrototypeOf(o);</span><br><span class="line">  &#125;;</span><br><span class="line">  return _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _instanceof(left, right) &#123;</span><br><span class="line">  if (right !&#x3D; null &amp;&amp; typeof Symbol !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; right[Symbol.hasInstance]) &#123;</span><br><span class="line">    return !!right[Symbol.hasInstance](left);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return left instanceof right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123;</span><br><span class="line">  if (!_instanceof(instance, Constructor)) &#123;</span><br><span class="line">    throw new TypeError(&quot;Cannot call a class as a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _defineProperties(target, props) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; props.length; i++) &#123;</span><br><span class="line">    var descriptor &#x3D; props[i];</span><br><span class="line">    descriptor.enumerable &#x3D; descriptor.enumerable || false;</span><br><span class="line">    descriptor.configurable &#x3D; true;</span><br><span class="line">    if (&quot;value&quot; in descriptor) descriptor.writable &#x3D; true;</span><br><span class="line">    Object.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _createClass(Constructor, protoProps, staticProps) &#123;</span><br><span class="line">  if (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">  if (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">  return Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Person &#x3D; &#x2F;*#__PURE__*&#x2F;function () &#123;</span><br><span class="line">  function Person(name, age, gender, interests) &#123;</span><br><span class="line">    _classCallCheck(this, Person);</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.gender &#x3D; gender;</span><br><span class="line">    this.interests &#x3D; interests;</span><br><span class="line">  &#125;</span><br><span class="line">  _createClass(Person, [&#123;</span><br><span class="line">    key: &quot;greeting&quot;,</span><br><span class="line">    value: function greeting() &#123;</span><br><span class="line">      console.log(&quot;hello, I am &quot;.concat(this.name, &quot;!&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line">  return Person;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var Teather &#x3D; &#x2F;*#__PURE__*&#x2F;function (_Person) &#123;</span><br><span class="line">  _inherits(Teather, _Person);</span><br><span class="line">  var _super &#x3D; _createSuper(Teather);</span><br><span class="line">  function Teather(name, age, gender, interests, subject) &#123;</span><br><span class="line">    var _this;</span><br><span class="line">    _classCallCheck(this, Teather);</span><br><span class="line">    _this &#x3D; _super.call(this, name, age, gender, interests);</span><br><span class="line">    _this.subject &#x3D; subject;</span><br><span class="line">    return _this;</span><br><span class="line">  &#125;</span><br><span class="line">  _createClass(Teather, [&#123;</span><br><span class="line">    key: &quot;greeting&quot;,</span><br><span class="line">    value: function greeting() &#123;</span><br><span class="line">      console.log(&quot;hello, I am a teather, I teath &quot;.concat(this.subject));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line">  return Teather;</span><br><span class="line">&#125;(Person);</span><br><span class="line"></span><br><span class="line">var t &#x3D; new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);</span><br><span class="line">t.greeting(); &#x2F;&#x2F; hello, I am a teather, I teath english!</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ES6转换后的ES5代码与原来的ES5代码实现原理一致。我们来简单分析一下转换后的代码：<br>&emsp;&emsp;① 可以看到，定义Person和Teacher时，使用了立即执行函数，代码会立即执行，执行后返回Person构造函数以及继承于Person的Teacher构造函数。<br>&emsp;&emsp;② 在定义Person变量的立即执行函数中，定义了Person函数，函数中设置了相关属性。然后调用_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法给Person函数的原型prototype上添加上方法，(还可以给Person函数添加静态属性，这里示例代码未添加）。即_createClass()实现了Person函数方法与属性的添加，最后将Person函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;③ 在定义Teacher变量的立即执行函数中，将定义好的Person构造函数函数作为了参数，先调用_inherits()方法，将定义的Teacher函数（预编译会进行函数提升）与传入的Person构造函数作为参数，其中使用Object.create()方法以Person构造函数的原型prototype作为原型，设置了Teacher函数的原型，同时Teacher函数的原型也继承了Person构造函数原型链上的属性和方法，然后调用_setPrototypeOf()方法修正Teacher函数原型对象__proto__的指向，也就是_inherits()方法实现了继承关系。然后再调用了_createSuper(Teather)方法定义了_super变量，其值是一个函数，里面追溯了Teacher构造函数的原型链，定义了调用父构造函数Person时，使用了apply（this, arguments）方法绑定了子构造函数Teacher的this，实现了Teacher函数属性的设置（<u>返回的_super方法这里只是定义，还未执行，要在Teacher构造函数执行到_super.call()的时候才会执行</u>）。最后同理，调用了_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法在Teacher函数的原型prototype上重写了greeting()方法，将Teacher函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;④ 调用new Teacher()创建t实例，执行Teacher构造函数，调用_classCallCheck()防止构造函数被直接调用（即ES6中的类是不能被直接调用的）。然后再调用上面说到的定义了的_super()方法实现了实例属性的设置（在执行_super()函数时，会执行里面定义的父构造函数Person的方法来实现属性的继承与设置），再设置了Teacher构造函数实例特有的subject属性，此时获得的_this实例的原型指向Teacher构造函数，Teacherr构造函数又继承于Person构造函数。此时_this实例已经继承了原型链上的属性与方法，包括Teahcer构造函数重写的greeting()方法。返回_this。<br>&emsp;&emsp;⑤ 执行t.greeting()方法，可以看到方法被成功执行且为执行的重写后的方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS动画（时序函数、缓动函数、canvas粒子动画）</title>
    <url>/2021/01/02/javascript/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>CSS动画很强大，特别是CSS3动画。可以进行通过transform的2D/3D变换，以及改变高宽，方位，角度，透明度等，再结合transition过渡属性或者@keyframes规则，能做到几乎完美。但CSS动画也有一些局限，比如不能设置浏览器相关的属性，如scrollTop等。且对于canvas等动画（以及粒子动画），还是要利用计时器（setTimeout、setInterval）或者浏览器重绘回调函数（requestAnimationFrame），通过JavaScript动态更新元素状态来实现。此外，canvas小游戏的逻辑实现也必须使用JavaScript去处理用户鼠标键盘等交互事件，才能完成对应的动画以及功能。JavaScript动画还可以实现沿着其他<strong>自定义时序函数</strong>的进行移动与变化。</p>
<h2 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h2><h3 id="1）setTimeout（setInterval）与requestAnimationFrame对比"><a href="#1）setTimeout（setInterval）与requestAnimationFrame对比" class="headerlink" title="1）setTimeout（setInterval）与requestAnimationFrame对比"></a>1）setTimeout（setInterval）与requestAnimationFrame对比</h3><p>&emsp;&emsp;(1)setTimeout/setInterval：</p>
<p>&emsp;&emsp;① 计时器的回调的执行时是在内存中对元素属性进行相应的改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上（一般为16.7ms刷新一次）。setTimeout的执行步调和屏幕的刷新步调不一致。就会导致中间某些帧的更新被跳过，照成动画卡顿。比如计时器设置10ms更新一次（帧），而屏幕刷新时间间隔为16.7ms，此时就会出现丢帧现象(即有的内存中元素状态的更新（帧）没来得及被浏览器渲染就被覆盖了)。其实只要计时器设置的更新时间小于16.7ms，就会导致丢帧。<br>&emsp;&emsp;② setTimeout/setInterval 放在异步队列里执行，主线程同步任务会阻塞异步队列的任务，设置的间隔时间不一定是回调执行的时间间隔。同样会造成动画卡顿（停顿）的现象。</p>
<p><em>&emsp;&emsp;[注] 前面已讲过 <a href="/2020/12/25/javascript/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">定时器相关概念</a>，可点击查看~</em></p>
<p>&emsp;&emsp;③ 使用setTimeout等实现的动画，当页面被隐藏或最小化时，setTimeout仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画浪费 CPU 资源和电池寿命。</p>
<p>&emsp;&emsp;(2) requestAnimationFrame（标准动画时序，浏览器在下次重绘之前调用指定的回调函数来更新动画）：</p>
<p>&emsp;&emsp;① 与setTimeout等相比，requestAnimationFrame最大的优势是由浏览器来决定回调函数的执行时机，即紧跟浏览器的刷新步调，不会出现丢帧现象。</p>
<p>&emsp;&emsp;② 当页面处于未激活的状态下，该页面的屏幕绘制任务也会被浏览器暂停，跟着浏览器步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画才会恢复继续执行，有效节省了 CPU 资源与电池寿命。<br>&emsp;&emsp;③ 在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame 有节流的作用，可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。</p>
<p><em>&emsp;&emsp;[注] 通过对比，requestAnimationFrame 要比 setTimeout/setInterval 性能好。<u>特别的，requestAnimationFrame回调函数会被传入DOMHighResTimeStamp参数（一个double类型，用于存储毫秒级的时间值），DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳。</u></em></p>
<h3 id="2）JS动画中的时序函数"><a href="#2）JS动画中的时序函数" class="headerlink" title="2）JS动画中的时序函数"></a>2）JS动画中的时序函数</h3><p>&emsp;&emsp;<u>时序函数就是动画完成情况与时间的关系（一般时序函数的图像也是从（0,0）变化到（1,1），代表动画执行时间到达时动画刚好执行完成）。</u>在JS动画中我们可以更灵活的自定义这种关系，即定义更加多样的时序函数，例如n次幂等满足经过（0,0）变化到（1,1）的曲线都可以作为时序函数。</p>
<p>&emsp;&emsp;为了代码的结构以及代码的可复用，这里编写一个<u>通用的动画函数</u>，放在单独的animate.js文件中：（其中时序函数timing也作为参数传入）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; animate.js</span><br><span class="line">function animate(&#123; duration, timing, draw &#125;) &#123;</span><br><span class="line">  let startTime &#x3D; performance.now(); &#x2F;&#x2F; 获得一个一个精确到毫秒的DOMHighResTimeStamp来标识动画开始时间</span><br><span class="line">  requestAnimationFrame(function animate(executionTime) &#123; &#x2F;&#x2F; executionTime为requestAnimationFrame的本次回调函数触发执行时间</span><br><span class="line">    let time &#x3D; (executionTime - startTime) &#x2F; duration; &#x2F;&#x2F; 计算当当前动画已经执行时间与动画延迟总时间的比值，</span><br><span class="line">    &#x2F;&#x2F; 其值为时序函数的x轴的值（为0代表动画开始执行，1代码动画执行结束）</span><br><span class="line">    if (time &gt; 1) time &#x3D; 1;</span><br><span class="line">    let progress &#x3D; timing(time) &#x2F;&#x2F; 计算当前时间节点动画完成进度，其值为时序函数y轴的值</span><br><span class="line">    draw(progress); &#x2F;&#x2F; 根据当前动画完成进度更新动画</span><br><span class="line">    if (time &lt; 1) &#123; &#x2F;&#x2F; 动画未完成，继续更新</span><br><span class="line">      requestAnimationFrame(animate); &#x2F;&#x2F; 这里animate为function animate(executionTime)&#123;...&#125;函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中duration，timing，draw分别代码动画执行时间（ms）,时序函数，元素状态更新函数。首先调用performance.now()获取动画开始执行的精确时间，然后再根据当前动画执行的时间根据时序函数计算出当前动画应完成的状态，然后调用draw方法更新元素状态。动画若未完成，继续执行。</p>
<p>&emsp;&emsp;还是用 <a href="/2020/11/26/css/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/#CSS%E5%8A%A8%E7%94%BB">《CSS动画》</a> 中小球移动的示例，这里我们采用一个 y=Math.pow(2, 10 * (x - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * x) 的时序函数来定义动画，时序函数的图像为：</p>
<p><img src="/images/javascript/Js%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0.png" alt="Js自定义时序函数"></p>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #ball &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: chocolate;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;ball&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;js&#x2F;animate.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.getElementById(&quot;ball&quot;).onclick &#x3D; function () &#123;</span><br><span class="line">    animate(&#123;</span><br><span class="line">      duration: 3000,</span><br><span class="line">      timing: function (time) &#123;</span><br><span class="line">        return Math.pow(2, 10 * (time - 1)) * Math.cos(20 * Math.PI * 1.5 &#x2F; 3 * time)</span><br><span class="line">      &#125;,</span><br><span class="line">      draw: function (progress) &#123;</span><br><span class="line">        document.getElementById(&quot;ball&quot;).style.marginLeft &#x3D; 250 * progress + &#39;px&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;动画效果：</p>
<p><img src="/images/javascript/Js%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB.gif" alt="Js时序动画"></p>
<p>&emsp;&emsp;先引入我们animate.js文件，给小球添加onclick点击事件，事件回调函数里为小球创建动画：动画时长3s，时序函数为我们自定义较为复杂的函数（这个时序函数不是CSS里的3次贝塞尔曲线函数，这个动画仅使用CSS无法完成），然后再是小球状态更新的方法，根据动画的完成状态向右移动小球直至移动250px，即到达外层div最右侧时动画完成。</p>
<h3 id="3-JS动画中的缓动函数"><a href="#3-JS动画中的缓动函数" class="headerlink" title="3) JS动画中的缓动函数"></a>3) JS动画中的缓动函数</h3><p>&emsp;&emsp;与时序函数类似，在JS动画中，我们可以也用缓动公式来控制每帧动画中个元素的状态，来实现各种动画效果。<u>缓动函数是根据元素状态的初始值、变化量、当前时间与动画总持续时间按照一定的变化规则来控制元素的状态，比时序函数更加灵活，在实际使用应用中也更加常用。</u>著名的缓动公式算法是Tween.js缓动算法。部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* Tween.js</span><br><span class="line">* t: current time（当前时间）；</span><br><span class="line">* b: beginning value（初始值）；</span><br><span class="line">* c: change in value（总变化量）；</span><br><span class="line">* d: duration（持续时间）。</span><br><span class="line">*&#x2F;</span><br><span class="line">var Tween &#x3D; &#123;</span><br><span class="line">    Linear: function(t, b, c, d) &#123; </span><br><span class="line">        return c * t &#x2F; d + b; </span><br><span class="line">    &#125;,</span><br><span class="line">    Sine: &#123;</span><br><span class="line">        easeIn: function(t, b, c, d) &#123;</span><br><span class="line">            return -c * Math.cos(t&#x2F;d * (Math.PI&#x2F;2)) + c + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        easeOut: function(t, b, c, d) &#123;</span><br><span class="line">            return c * Math.sin(t&#x2F;d * (Math.PI&#x2F;2)) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        easeInOut: function(t, b, c, d) &#123;</span><br><span class="line">            return -c &#x2F; 2 * (Math.cos(Math.PI * t&#x2F;d) - 1) + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F; .....(其他代码省略）</span><br><span class="line">&#125;</span><br><span class="line">Math.tween &#x3D; Tween;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试Tweem.js算法</span><br><span class="line">&#x2F;&#x2F; 1、测试匀速运动</span><br><span class="line">console.log(&#39;1、匀速算法，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);</span><br><span class="line">console.log(Math.tween.Linear(5,0,100,10)); &#x2F;&#x2F; 50</span><br><span class="line">&#x2F;&#x2F; 2、测试正弦曲线</span><br><span class="line">console.log(&#39;2、测试正弦曲线，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);</span><br><span class="line">console.log(Math.tween.Sine.easeIn(5,0,100,10)); &#x2F;&#x2F; 29.289321881345245</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;算法中的4个参数分别他，t，b，c，d分别表示动画执行到当前帧的时间，元素的初始状态，动画过程中元素状态的变化量以及动画持续时间。如添加的测试1代码所示：有一个小球从0px的位置要移动到100px的位置，初始状态的坐标为0px，坐标的总变化量为100px(100px - 0px = 100px)，假设动画持续时间为10s，传入动画当前帧的时间5s，调用Tween.js的线性渐变算法就能得到当前小球应该处于50px的位置；调用正弦曲线算法能得到当前小球处于约29px的位置。从而以此来控制流畅的动画。</p>
<p>&emsp;&emsp;在Tween.js中，常用的经典动画场景都已实现，除了Linear，其余每种场景都有easeIn、easeOut和easeInOut方法，具体动画场景如下：<br>&emsp;&emsp;Linear：线性匀速运动效果；<br>&emsp;&emsp;Quadratic：二次方的缓动（t^2）；<br>&emsp;&emsp;Cubic：三次方的缓动（t^3）；<br>&emsp;&emsp;Quartic：四次方的缓动（t^4）；<br>&emsp;&emsp;Quintic：五次方的缓动（t^5）；<br>&emsp;&emsp;Sinusoidal：正弦曲线的缓动（sin(t)）；<br>&emsp;&emsp;Exponential：指数曲线的缓动（2^t）；<br>&emsp;&emsp;Circular：圆形曲线的缓动（sqrt(1-t^2)）；<br>&emsp;&emsp;Elastic：指数衰减的正弦曲线缓动；<br>&emsp;&emsp;Back：超过范围的三次方缓动（(s+1)<em>t^3 – s</em>t^2）；<br>&emsp;&emsp;Bounce：指数衰减的反弹缓动。</p>
<p>&emsp;&emsp;还是小球移动的例子，这里简单应用一下Tween.js的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">  &#125;</span><br><span class="line">  #ball &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: chocolate;</span><br><span class="line">    margin-left: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;ball&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;js&#x2F;Tween.js&quot;&gt;&lt;&#x2F;script&gt; &#x2F;&#x2F; 引入Tween.js文件</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let duration &#x3D; 3000;</span><br><span class="line">  let startTime &#x3D; performance.now(); &#x2F;&#x2F; 动画持续时间</span><br><span class="line">  let currentMarginLeft &#x3D; 0;</span><br><span class="line">  requestAnimationFrame(function update(executionTime) &#123;</span><br><span class="line">    currentMarginLeft &#x3D; Math.tween.Linear(executionTime, 0, 250, duration);  &#x2F;&#x2F; 匀速线性变化</span><br><span class="line">    &#x2F;&#x2F; currentMarginLeft &#x3D; Math.tween.Elastic.easeInOut(executionTime, 0, 250, duration); &#x2F;&#x2F; 衰减的正弦曲线变化</span><br><span class="line">    &#x2F;&#x2F; currentMarginLeft &#x3D; Math.tween.Bounce.easeOut(executionTime, 0, 250, duration); &#x2F;&#x2F; 指数衰减反弹变化</span><br><span class="line">    document.getElementById(&quot;ball&quot;).style.marginLeft &#x3D; currentMarginLeft + &#39;px&#39;;</span><br><span class="line">    if (executionTime &lt;&#x3D; duration) &#123;</span><br><span class="line">      requestAnimationFrame(update)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分别采用匀速、衰减正弦曲线以及指数衰减反弹对小球的margin-left属性进行相应变化，动画效果依次为：<br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB1.gif" alt="Tween时序动画1"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB2.gif" alt="Tween时序动画2"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB3.gif" alt="Tween时序动画3"></p>
<h3 id="4-canvas粒子动画"><a href="#4-canvas粒子动画" class="headerlink" title="4) canvas粒子动画"></a>4) canvas粒子动画</h3><p>&emsp;&emsp;canvas元素以及基础的动画，已在另一篇文章<a href="/2020/09/15/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89">《HTML Canvas（2D时序动画）》</a>讲到，canvas画布的上下文ctx对象有对应的API用，可以对相关元素进行旋转、缩放、位移、形变，也可以用martrix方式做更高级的变化。<u>canvas图像处理也可以用于图像压缩，图像裁剪，图像合成、图像滤镜、图像取色器、抠图等功能。</u>不过这里主要补充canvas粒子动画的实现：</p>
<p>&emsp;&emsp;canvas中的粒子，其实是对一个像素的抽象。它具有自己坐标，自己的色值，可以通过改变自身的属性使其按照一定的规律运动起来便可形成相应的粒子动画。<br>&emsp;&emsp;一般我们将粒子用一个对象抽象出来，形如：let particle = { x: 0, y: 0, rgba: ‘(0, 0, 0, 1)’ }，这个过程称为粒子对象化，实际制作粒子动画的过程是对这些粒子对象的属性（如位置，颜色等）进行相应的变化。<br>&emsp;&emsp;为了动画更加自然，我们一般不会采用匀速的变化，而是加入相应的时序函数来控制粒子运动效果，使粒子变化或快或慢，更加自然。<br>&emsp;&emsp;一般为了性能，我们不会把图像所有像素点都抽象出来，因为requestAnimationFrame，正常的情况下一般刷新频率在60HZ，能展现非常流畅的动画。但现在如果要处理庞大的粒子对象数据，浏览器处理压力太大，就会造成了降频现象，导致动画出现卡帧（卡顿）现象。一般我们选择性的来抽象粒子对象：抽象像素点r色值为155以上并且坐标为偶数的像素点；或隔一定距离(像素)用一个粒子来抽象一个像素块（连续多个像素组成）。这样抽象的粒子数量不会影响图像效果的展示，动画的处理过程来也比较流畅。</p>
<p>&emsp;&emsp;<strong>为了更好抽象粒子对象以及其色值信息，补充一个canvas图像滤镜处理的示例来引入<u>canvas像素图像信息</u>的概念：</strong></p>
<p>&emsp;&emsp;先介绍要用到的canvas的3个API：<br>&emsp;&emsp;① <strong>getImageData()</strong>：获得一个ImageData对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.getImageData(sx, sy, sw, sh); &#x2F;&#x2F; 返回ImageData对象</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：width、height、data，分别代表图片宽度(单位px)、高度(单位px)、像素数据（Uint8ClampedArray类型）。</p>
<p>&emsp;&emsp;其中data属性返回像素信息是一个 类型Uint8ClampedArray的一维数组。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份R的色值保存在数组的索引0位置。像素从左到右被处理，然后往下。Uint8ClampedArray  包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1，具体如下：</p>
<p><img src="/images/javascript/ImageData.png" alt="ImageData"></p>
<p>&emsp;&emsp;如图所示，ImgaeData的data属性保存了图片每个像素的RAGA色值信息。第一个像素点的色值RGBA分别保存在Uint8ClampedArray数组索引0到3的位置，第二个像素点的色值保存在数组索引4-7的位置，先行后列，以此类推…。能很容易得到第i行第j列像素点的色值R保存在ImageData.data数组索引 [(j - 1) * width + (i - 1) ] * 4的位置。若像素点色值R在数组的索引为index，则每个像素的位置(i, j)与index的关系为：index=[(j - 1) * width + (i - 1) ] * 4，色值G的索引为index+1，色值B的索引为index+2，透明度A的索引为index+3。 </p>
<p>&emsp;&emsp;② <strong>createImageData()</strong>：Canvas 2D API 创建一个新的、空白的、指定大小的 ImageData 对象。 所有的像素在新对象中都是透明的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.createImageData(width, height); &#x2F;&#x2F; 返回ImageData对象</span><br><span class="line">ctx.createImageData(imagedata); &#x2F;&#x2F; 返回ImageData对象</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;③ <strong>putImageData()</strong>：Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.putImageData(imagedata, dx, dy);</span><br><span class="line">ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;canvas图像滤镜处理效果：</p>
<p><img src="/images/javascript/canvas%E5%9B%BE%E5%83%8F%E6%BB%A4%E9%95%9C%E5%A4%84%E7%90%86.png" alt="canvas图像滤镜处理"></p>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const TYPE &#x3D; &#39;grayscale&#39;; &#x2F;&#x2F; grayscale - 灰度(默认)、sepia - 复古、inert - 反向</span><br><span class="line">  let canvas &#x3D; document.getElementById(&#39;canvas&#39;);</span><br><span class="line">  let ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">  const img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">  img.src &#x3D; &#39;&#x2F;img&#x2F;filter.jpg&#39;;</span><br><span class="line">  img.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    canvas.width &#x3D; img.width;</span><br><span class="line">    canvas.height &#x3D; img.height;</span><br><span class="line">    ctx.drawImage(img, 0, 0); &#x2F;&#x2F; 将原图渲染到canvas画布上</span><br><span class="line">    let originImage &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height); &#x2F;&#x2F; 获取图片像素信息</span><br><span class="line">    let outputImage &#x3D; filter(originImage, TYPE); &#x2F;&#x2F; 按照滤镜风格处理像素信息</span><br><span class="line">    ctx.putImageData(outputImage, 0, 0); &#x2F;&#x2F; 将处理后的像素信息覆盖到canvas画布上</span><br><span class="line">  &#125;)</span><br><span class="line">  function filter(originImage, type) &#123; &#x2F;&#x2F; 图像处理函数</span><br><span class="line">    let index, r, g, b;</span><br><span class="line">    let originImageData &#x3D; originImage.data;</span><br><span class="line">    let width &#x3D; originImage.width;</span><br><span class="line">    let height &#x3D; originImage.height;</span><br><span class="line">    let outputImage &#x3D; ctx.createImageData(width, height);</span><br><span class="line">    let outputImageData &#x3D; outputImage.data;</span><br><span class="line">    for (let x &#x3D; 1; x &lt;&#x3D; width; x++) &#123;</span><br><span class="line">      for (let y &#x3D; 1; y &lt;&#x3D; height; y++) &#123;</span><br><span class="line">        index &#x3D; [(y - 1) * width + (x - 1)] * 4;</span><br><span class="line">        r &#x3D; originImageData[index];</span><br><span class="line">        g &#x3D; originImageData[index + 1];</span><br><span class="line">        b &#x3D; originImageData[index + 2];</span><br><span class="line">        if (type &#x3D;&#x3D; &#39;sepia&#39;) &#123; &#x2F;&#x2F; 复古滤镜风格下对色值的处理</span><br><span class="line">          outputImageData[index] &#x3D; (r * 0.393) + (g * 0.769) + (b * 0.189);</span><br><span class="line">          outputImageData[index + 1] &#x3D; (r * 0.349) + (g * 0.686) + (b * 0.168);</span><br><span class="line">          outputImageData[index + 2] &#x3D; (r * 0.272) + (g * 0.534) + (b * 0.131);</span><br><span class="line">        &#125; else if (type &#x3D;&#x3D; &#39;inert&#39;) &#123; &#x2F;&#x2F; 反向滤镜风格下对色值的处理</span><br><span class="line">          outputImageData[index] &#x3D; 255 - r;</span><br><span class="line">          outputImageData[index + 1] &#x3D; 255 - g;</span><br><span class="line">          outputImageData[index + 2] &#x3D; 255 - b;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 灰度滤镜风格下对图像的处理</span><br><span class="line">          outputImageData[index] &#x3D; outputImageData[index + 1] &#x3D; outputImageData[index + 2] &#x3D; (r + g + b) &#x2F; 3;</span><br><span class="line">        &#125;</span><br><span class="line">        outputImageData[index + 3] &#x3D; 255;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return outputImage;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;简单说明：思路就是先讲图片渲染到canvas画布上，再调用getImageData()方法获得canvas元素上的像素信息。根据滤镜风格分别对像素信息进行相应的处理，最后调用putImageData()方法将imageData对象渲染(覆盖)到canvas画布上即可。示例中我们已经获取到了画布上图像的像素信息，也以利用获取到的图片像素信息，监听鼠标指针相对于画布的水平垂直方向偏移的距离（px）获得当前鼠标指针指向的像素点(i, j)的位置，可以做<u>图像取色器</u>等功能。</p>
<p>&emsp;&emsp;正式介绍<u>粒子动画</u>，先看效果：</p>
<p><img src="/images/javascript/Js%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB.gif" alt="Js粒子动画"></p>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;canvas粒子动画&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body &#123; background: midnightblue; margin: 0; padding: 0; &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">  &lt;!-- 使用Tween.js缓动函数控制动画 --&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;js&#x2F;Tween.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    let cw &#x3D; document.documentElement.clientWidth;</span><br><span class="line">    let ch &#x3D; document.documentElement.clientHeight;</span><br><span class="line">    let maxDelay &#x3D; 0; &#x2F;&#x2F; 保存粒子动画开始最长延时时间，用于动画完成介绍requestAnimationFrame动画回调</span><br><span class="line">    let canvas &#x3D; document.getElementById(&#39;canvas&#39;);</span><br><span class="line">    let ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">    const img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">    img.src &#x3D; &#39;&#x2F;img&#x2F;canvas-img.jpg&#39;;</span><br><span class="line">    img.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">      canvas.width &#x3D; cw;</span><br><span class="line">      canvas.height &#x3D; ch;</span><br><span class="line">      console.log(cw, ch)</span><br><span class="line">      let sx &#x3D; (cw &#x2F; 2) - (img.width &#x2F; 2); &#x2F;&#x2F; 把图片画在canvas(屏幕)中间</span><br><span class="line">      ctx.drawImage(img, sx, 0, img.width, img.height);</span><br><span class="line">      let originImage &#x3D; ctx.getImageData(0, 0, cw, ch);</span><br><span class="line">      let particles &#x3D; dataToObject(originImage.data, originImage.width, originImage.height);</span><br><span class="line">      draw(particles);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    function dataToObject(imageData, width, height) &#123; &#x2F;&#x2F; 粒子对象化函数</span><br><span class="line">      let inx;</span><br><span class="line">      let particle &#x3D; &#123;&#125;;</span><br><span class="line">      let particles &#x3D; [];</span><br><span class="line">      let threshold &#x3D; 50; &#x2F;&#x2F; 设置色值阈值，颜色较浅的像素不进行粒子对象化操作</span><br><span class="line">      let delay &#x3D; 0;</span><br><span class="line">      for (let x &#x3D; 1; x &lt;&#x3D; width; x +&#x3D; 2) &#123;</span><br><span class="line">        for (let y &#x3D; 1; y &lt;&#x3D; height; y +&#x3D; 2) &#123;</span><br><span class="line">          inx &#x3D; [(y - 1) * width + (x - 1)] * 4;</span><br><span class="line">          if ((imageData[inx] + imageData[inx + 1] + imageData[inx + 2]) &#x2F; 3 &gt; threshold) &#123;</span><br><span class="line">            delay &#x3D; Math.random() * 3000;</span><br><span class="line">            maxDelay &lt; delay &amp;&amp; (maxDelay &#x3D; delay)</span><br><span class="line">            particle &#x3D; &#123;</span><br><span class="line">              x0: 100,</span><br><span class="line">              y0: ch,</span><br><span class="line">              x1: x - 1,</span><br><span class="line">              y1: y - 1,</span><br><span class="line">              delay: delay,</span><br><span class="line">              rgba: &#96;rgba($&#123;imageData[inx]&#125;, $&#123;imageData[inx + 1]&#125;, $&#123;imageData[inx + 2]&#125;, $&#123;imageData[inx + 3]&#125;)&#96;</span><br><span class="line">            &#125;;</span><br><span class="line">            particles.push(particle);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return particles;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function draw(particles) &#123; &#x2F;&#x2F;画图</span><br><span class="line">      let duration &#x3D; 5000; &#x2F;&#x2F; 动画持续时间</span><br><span class="line">      let particle, cur_x, cur_y, cur_time;</span><br><span class="line">      let startTime &#x3D; performance.now(); &#x2F;&#x2F; 动画开始时间</span><br><span class="line">      let AnimationFrameId &#x3D; requestAnimationFrame(function update(executionTime) &#123; &#x2F;&#x2F; 每帧更新画布</span><br><span class="line">        ctx.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">        for (let i &#x3D; 0, len &#x3D; particles.length; i &lt; len; i++) &#123;</span><br><span class="line">          particle &#x3D; particles[i]</span><br><span class="line">          if (executionTime &gt; particle.delay + duration) &#123;</span><br><span class="line">            ctx.fillStyle &#x3D; particle.rgba;</span><br><span class="line">            ctx.fillRect(particle.x1, particle.y1, 1, 1)</span><br><span class="line">          &#125; else if (executionTime &gt; particle.delay) &#123;</span><br><span class="line">            ctx.fillStyle &#x3D; particle.rgba;</span><br><span class="line">            cur_time &#x3D; executionTime - particle.delay;</span><br><span class="line">            cur_x &#x3D; Math.tween.Elastic.easeInOut(cur_time, particle.x0, particle.x1 - particle.x0, duration);</span><br><span class="line">            cur_y &#x3D; Math.tween.Bounce.easeOut(cur_time, particle.y0, particle.y1 - particle.y0, duration);</span><br><span class="line">            ctx.fillRect(cur_x, cur_y, 1, 1)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (executionTime &gt; maxDelay + duration) &#123;</span><br><span class="line">          cancelAnimationFrame(AnimationFrameId);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          AnimationFrameId &#x3D; requestAnimationFrame(update)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实现思路：使用drawImage()方法将图片对象先放在画布上，然后调用getImageData()获取图片的像素信息。<u>根据将像素信息，生成对象来表示每个像素点的信息，对象属性包括初始位置，结束位置（像素点在canvas画布中原本的位置），颜色等信息。</u>这里为了然动画效果更加自然协调，加入了动画开始延迟时间delay属性。然后根据Tween.js缓动函数对粒子从初始位置移动到对应的结束位置的状态进行控制，调用requestAnimationFrame()方法设置回调来对粒子对象的状态进行刷新，便形成了动画。<br><em>&emsp;&emsp;[注] 有时我们会加入阈值（如代码中设置的阈值threshold为50）、增加对象化像素点的间距（如代码中循环粒子对象化操作时循环步长为2）来减少生成的对象数量，从而减少浏览器每一帧的处理压力，使动画更加流畅自然。</em></p>
<p>&emsp;&emsp;代码中的dataToObject()函数完成的功能就是用对象去标识图像的像素信息，每个对象表示一个像素点，即我们所说的‘粒子’。<u>实际上，粒子动画并不是总要使用getImageData()去抽象图片的信息，然后生成粒子对象。有时我们会直接构造出粒子类，按照我们的需求生成粒子对象，然后根据一定的规则使粒子运动起来即可。粒子动画本质是canvas动画，还可以与鼠标等输入设备交互，作出像放烟花、炫彩小球、小球自由落体、球体运动碰撞等有趣的动画。</u></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS常用API（字符串、数组、对象、正则、日期）</title>
    <url>/2021/01/16/javascript/JS%E5%B8%B8%E7%94%A8API%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%97%A5%E6%9C%9F%EF%BC%89/</url>
    <content><![CDATA[<p>JS中常用的API有字符串、数组、对象、正则与日期对象等。</p>
<h2 id="1、字符串（String）"><a href="#1、字符串（String）" class="headerlink" title="1、字符串（String）"></a>1、字符串（String）</h2><p>&emsp;&emsp;字符串，是由零个或多个字符组成的有限序列。在JavaScript中，字符串实例有字符串对象和基本字符串值的区别  ( 对于 Boolean 和Numbers 也同理)。字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。<u>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str1 &#x3D; &#39;abc&#39;; &#x2F;&#x2F; 基本字符串实例</span><br><span class="line">const str2 &#x3D; new String(&#39;abc&#39;); &#x2F;&#x2F; 字符串对象实例</span><br><span class="line">console.log(str1);</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure>
<p>打印结果如下（特殊的，可以看到基本字符串实例与字符串对象实例区别很大；其他对象如<u>数组</u>、<u>对象</u>等字面量定义与构造函数实例化<u>区别并不大</u>）：</p>
<p><img src="/images/javascript/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89.png" alt="字符串（String）"></p>
<p>&emsp;&emsp;字符串String对象的属性：String.prototype（显式原型，允许您向对象添加属性和方法）<br>&emsp;&emsp;字符串String对象的方法：String.fromCharCode() （通过一串 Unicode 创建字符串）、String.raw()（通过模板字符串创建字符串）等<br>&emsp;&emsp;字符串实例对象的属性：String.prototype.constructor（构造函数，创建改对象的函数的引用）、String.prototype.length（字符串长度）、N（用于访问第N个位置的字符，其中N是小于 length 和 0之间的正整数，‘只读’性质，不可编辑。eg: str1[1]结果为‘b’）</p>
<p>&emsp;&emsp;字符串实例对象常用方法（<strong>String.prototype上的方法</strong>）：<br>&emsp;&emsp;charAt()：返回在指定位置的字符<br>&emsp;&emsp;concat()：连接两个或更多字符串，并返回新的字符串<br>&emsp;&emsp;includes()：查找字符串中是否包含指定的子字符串<br>&emsp;&emsp;startsWith()：查看字符串是否以指定的子字符串开头<br>&emsp;&emsp;endsWith()：查看字符串是否以指定的子字符串结尾<br>&emsp;&emsp;indexOf()：返回某个指定的字符串值在字符串中首次出现的位置<br>&emsp;&emsp;lastIndexOf()：从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置<br>&emsp;&emsp;<u>match()</u>：查找找到一个或多个正则表达式的匹配<br>&emsp;&emsp;<u>search()</u>：查找与正则表达式相匹配的值<br>&emsp;&emsp;padStart()：在当前字符串头部填充指定的字符串，直到达到指定的长度。返回一个新的字符串<br>&emsp;&emsp;padEnd()：在当前字符串尾部填充指定的字符串，直到达到指定的长度。返回一个新的字符串<br>&emsp;&emsp;repeat()：复制字符串指定次数，并将它们连接在一起返回<br>&emsp;&emsp;replace()：在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串<br>&emsp;&emsp;slice()：提取字符串的片断，并在新的字符串中返回被提取的部分<br>&emsp;&emsp;split()：把字符串分割为字符串数组<br>&emsp;&emsp;substring()：提取字符串中两个指定的索引号之间的字符<br>&emsp;&emsp;toLocaleLowerCase()、toLocaleUpperCase()：将字符串中的字符转成小写或大写<br>&emsp;&emsp;trim()、trimStart()/trimLeft()、trimEnd()/trimRight()：去掉字符串开始或结尾的空格<br>&emsp;&emsp;toString()：返回一个字符串。屏蔽了原型链上的 Object.prototype.toString() 方法</p>
<p><em>&emsp;&emsp;[注] 这里列举的方法都是访问方法，不会改变对象自身的值</em></p>
<p>&emsp;&emsp;字符串常用方法示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str1 &#x3D; &#39;aAbBcCc&#39;</span><br><span class="line">const str2 &#x3D; new String(&#39;  123  456&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; chatAt() 返回特定位置的字符</span><br><span class="line">console.log(str1.charAt(0)); &#x2F;&#x2F; a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; concat() 连接两个字符串文本，并返回一个新的字符串</span><br><span class="line">console.log(str1.concat(str2)); &#x2F;&#x2F; aAbBcCc  123  456</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; includes() 判断一个字符串里是否包含其他字符串</span><br><span class="line">console.log(str1.includes(&#39;c&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; startsWith() 判断字符串的起始位置是否匹配其他字符串中的字符</span><br><span class="line">console.log(str1.startsWith(&#39;a&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; endsWith() 判断一个字符串里是否包含其他字符串</span><br><span class="line">console.log(str1.endsWith(&#39;a&#39;)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; indexOf() 从字符串对象中返回首个被发现的给定值的索引值，如果没有找到则返回-1</span><br><span class="line">console.log(str1.indexOf(&#39;a&#39;)) &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; lastIndexOf() 从字符串对象中返回最后一个被发现的给定值的索引值，如果没有找到则返回-1</span><br><span class="line">console.log(str1.lastIndexOf(&#39;C&#39;)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; match() 使用正则表达式与字符串相比较，返回匹配成功的结果数组</span><br><span class="line">console.log(str1.match(&#x2F;a&#x2F;gi)) &#x2F;&#x2F; [&quot;a&quot;, &#39;B&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; search() 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标</span><br><span class="line">console.log(str1.search(&#x2F;b&#x2F;g)) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; padStart() 在当前字符串头部填充指定的字符串，直到达到指定的长度。返回一个新的字符串</span><br><span class="line">console.log(str1.padStart(10, &#39;X&#39;)) &#x2F;&#x2F; XXXaAbBcCc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; padEnd() 在当前字符串尾部填充指定的字符串，直到达到指定的长度。返回一个新的字符串</span><br><span class="line">console.log(str1.padEnd(10, &#39;X&#39;)) &#x2F;&#x2F; aAbBcCcXXX</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; repeat() 返回指定重复次数的由元素组成的字符串对象</span><br><span class="line">console.log(str1.repeat(2)) &#x2F;&#x2F; aAbBcCcaAbBcCc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; replace() 被用来在字符或正则表达式与字符串直接比较，然后用新的子串来替换被匹配的子串</span><br><span class="line">console.log(str1.replace(&#x2F;a&#x2F;g, &#39;X&#39;)) &#x2F;&#x2F; XAbBcCc</span><br><span class="line">console.log(str1.replace(&#x2F;a&#x2F;gi, &#39;X&#39;)) &#x2F;&#x2F; XXbBcCc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; slice() 摘取一个字符串区域，返回一个新的字符串</span><br><span class="line">console.log(str1.slice(2,4)) &#x2F;&#x2F; bB</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; split() 通过分离字符串成字串，将字符串对象分割成字符串数组</span><br><span class="line">console.log(str1.split(&#39;&#39;)) &#x2F;&#x2F; [&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; substring() 返回在字符串中指定两个下标之间的字符</span><br><span class="line">console.log(str1.substring(2,4)) &#x2F;&#x2F; bB</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; toLocaleLowerCase()、toLocaleUpperCase() 将字符串中的字符转成小写或大写</span><br><span class="line">console.log(str1.toLocaleLowerCase()) &#x2F;&#x2F; aabbccc</span><br><span class="line">console.log(str1.toLocaleUpperCase()) &#x2F;&#x2F; AABBCCC</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; trim()、trimStart()&#x2F;trimLeft()、trimEnd()&#x2F;trimRight() 去掉字符串开始或结尾的空格</span><br><span class="line">console.log(str2.trim()) &#x2F;&#x2F; 123  456</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; toString() 返回用字符串表示的特定对象</span><br><span class="line">console.log([1,2,3,4,5].toString()) &#x2F;&#x2F; &quot;1,2,3,4,5&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2、数组（Array）"><a href="#2、数组（Array）" class="headerlink" title="2、数组（Array）"></a>2、数组（Array）</h2><p>&emsp;&emsp;数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。<br><em>&emsp;&emsp;[注] 只能用整数作为数组元素的索引，而不能用字符串。后者称为关联数组（Map）。使用非整数并通过方括号或点号来访问或设置数组元素时，所操作的并不是数组列表中的元素，而是数组对象的属性集合上的变量（例如length）。<u>数组对象的属性和数组元素列表是分开存储的，并且数组的遍历和修改操作也不能作用于这些命名属性。</u>数组的索引是从0开始的，第一个元素的索引为0，最后一个元素的索引等于该数组的长度减1。<u>如果指定的索引是一个无效值，JavaScript 数组并不会报错，而是会返回 undefined</u></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, 5, 6]</span><br><span class="line">console.log(arr[2]) &#x2F;&#x2F; 3</span><br><span class="line">console.log(arr[-1]) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(arr[10]) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;数组Array对象的属性：Array.length (Array构造函数的 length 属性，其值为1)、Array.prototype (通过数组的原型对象可以为所有数组对象添加属性)<br>&emsp;&emsp;数组Array对象的方法：Array.from() (从类数组对象或者可迭代对象中创建一个新的数组实例)、Array.isArray() (用来判断某个变量是否是一个数组对象)、Array.of() (根据一组参数来创建新的数组实例，支持任意的参数数量和类型)<br>&emsp;&emsp;数组实例对象的属性：Array.prototype.constructor（构造函数，创建改对象的函数的引用）、Array.prototype.length（数组长度）</p>
<p>&emsp;&emsp;数组实例对象的方法（Array.prototype上的方法）：</p>
<p>&emsp;&emsp;1) 修改器方法（这些方法调用<u>会</u>改变对象自身的值）<br>&emsp;&emsp;copyWithin()：在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值<br>&emsp;&emsp;fill()：将数组中指定区间的所有元素的值，都替换成某个固定的值<br>&emsp;&emsp;pop()：删除数组的最后一个元素，并返回这个元素<br>&emsp;&emsp;push()：在数组的末尾增加一个u或多个元素，并返回数组的新长度<br>&emsp;&emsp;reverse()：颠倒数组中元素的排列顺序<br>&emsp;&emsp;shift()：删除数组的第一个元素，并返回这个元素<br>&emsp;&emsp;sort()：对数组元素进行排序，并返回当前数组<br>&emsp;&emsp;splice()：在任意的位置给数组添加或删除任意个元素<br>&emsp;&emsp;unshift()：在数组的开头增加一个或多个元素，并返回数组的新长度</p>
<p>&emsp;&emsp;2) 访问方法（这些方法调用<u>不会</u>改变对象自身的值）<br>&emsp;&emsp;concat()：返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组<br>&emsp;&emsp;includes()：判断当前数组是否包含某指定的值，返回ture/false<br>&emsp;&emsp;join()：连接所有数组元素组成一个字符串<br>&emsp;&emsp;slice()：抽取当前数组中的一段元素组合成一个新数组<br>&emsp;&emsp;toString()：返回一个由所有数组元素组合而成的字符串。屏蔽了原型链上的 Object.prototype.toString() 方法<br>&emsp;&emsp;indexOf()：返回数组中第一个与指定值相等的元素的索引，如果找不到返回-1<br>&emsp;&emsp;lastIndexOf()：返回数组中最后一个与指定值相等的元素的索引，如果找不到返回-1</p>
<p>&emsp;&emsp;3) 迭代方法（<u>一般都需要指定回调函数，在回调函数中length会被缓存，尽量不要在遍历过程中对原数组进行任何修改，会对遍历操作带来未预期的影响</u>）<br>&emsp;&emsp;forEach()：为数组中的每个元素执行一次回调函数<br>&emsp;&emsp;entries()：返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对<br>&emsp;&emsp;every()：如果数组中的每个元素都满足测试函数，返回true，否则返回false<br>&emsp;&emsp;some()：如果数组中至少有一个元素满足测试函数，返回 true，否则返回 false<br>&emsp;&emsp;filter()：将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回<br>&emsp;&emsp;find()：找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined<br>&emsp;&emsp;findIndex()：找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1<br>&emsp;&emsp;keys()：返回一个数组迭代器对象，该迭代器会包含所有数组元素的键<br>&emsp;&emsp;<u>map()：返回一个由回调函数的返回值组成的新数组</u><br>&emsp;&emsp;<u>reduce()：从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值</u><br>&emsp;&emsp;reduceRight()：从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值<br>&emsp;&emsp;values()：返回一个数组迭代器对象，该迭代器会包含所有数组元素的值</p>
<p>&emsp;&emsp;数组常用方法示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、修改器方法 - 会改变原数组    </span><br><span class="line">console.log(&#39;生成长度为5的空数组实例&#39;)</span><br><span class="line">let array &#x3D; new Array(5)</span><br><span class="line">console.log(array) &#x2F;&#x2F; [empty × 5]</span><br><span class="line">console.log(&#39;初始化数组所有元素为0&#39;)</span><br><span class="line">array.fill(0)</span><br><span class="line">console.log(array) &#x2F;&#x2F; [0, 0, 0, 0, 0]</span><br><span class="line">console.log(&#39;在数组末尾添加元素2，6和1&#39;)</span><br><span class="line">array.push(2, 6, 1)</span><br><span class="line">console.log(array) &#x2F;&#x2F; [0, 0, 0, 0, 0, 2, 6, 1]</span><br><span class="line">console.log(&#39;删除数组最后一个元素并输出该元素与删除后的数组&#39;)</span><br><span class="line">console.log(array.pop()) &#x2F;&#x2F; 1</span><br><span class="line">console.log(array) &#x2F;&#x2F; [0, 0, 0, 0, 0, 2, 6]</span><br><span class="line">console.log(&#39;在数组开头添加元素6，3和7&#39;)</span><br><span class="line">array.unshift(6, 3, 7)</span><br><span class="line">console.log(array) &#x2F;&#x2F; [6, 3, 7, 0, 0, 0, 0, 0, 2, 6]</span><br><span class="line">console.log(&#39;删除数组第一个元素并输出该元素与删除后的数组&#39;)</span><br><span class="line">console.log(array.shift()) &#x2F;&#x2F; 6</span><br><span class="line">console.log(array) &#x2F;&#x2F; [3, 7, 0, 0, 0, 0, 0, 2, 6]</span><br><span class="line">console.log(&#39;数组元素反序&#39;)</span><br><span class="line">array.reverse()</span><br><span class="line">console.log(array) [6, 2, 0, 0, 0, 0, 0, 7, 3]</span><br><span class="line">console.log(&#39;数组排序，默认从小到大&#39;)</span><br><span class="line">array.sort()</span><br><span class="line">console.log(array) &#x2F;&#x2F; [0, 0, 0, 0, 0, 2, 3, 6, 7]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、访问方法 - 不会改变原数组</span><br><span class="line">console.log(&#39;连接数组[1,2]与[3,4]&#39;)</span><br><span class="line">console.log(array.concat([1, 2], [3, 4])) &#x2F;&#x2F; [0, 0, 0, 0, 0, 2, 3, 6, 7, 1, 2, 3, 4]</span><br><span class="line">console.log(&#39;截取数组下标从3到数组末尾所有元素&#39;)</span><br><span class="line">console.log(array.slice(3, array.length)) &#x2F;&#x2F; [0, 0, 2, 3, 6, 7]]</span><br><span class="line">console.log(array) &#x2F;&#x2F; [0, 0, 0, 0, 0, 2, 3, 6, 7]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、迭代方法 - 返回预期数组结果，不会影响原数组</span><br><span class="line">console.log(&#39;过滤掉数组小于等于0的项&#39;)</span><br><span class="line">console.log(array.filter(item &#x3D;&gt; item &gt; 0)) &#x2F;&#x2F; [2, 3, 6, 7]</span><br><span class="line">console.log(&#39;数组各项求和&#39;)</span><br><span class="line">console.log(array.reduce((sum, item) &#x3D;&gt; sum+&#x3D;item)) &#x2F;&#x2F; 18</span><br><span class="line">console.log(array) &#x2F;&#x2F; [0, 0, 0, 0, 0, 2, 3, 6, 7]</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] JavaScritp的数据类型有：数值类型、字符串类型、布尔类型、null、undefined、对象；将他们可以大致分成两种：基本数据类型、引用数据类型</em><br><em>&emsp;&emsp;① 基本数据类型：数值、字符串、布尔、null、undefined （值类型）</em><br><em>&emsp;&emsp;② 复杂(复合)数据类型：对象 (引用类型)</em></p>
<p><em>&emsp;&emsp;基础数据类型保存在栈内存中；引用类型数据保存在堆内存中，对应的引用地址是存储在栈内存中的，这个引用地址指向引用类型数据在堆内存储的存储单元。调用基础数据类型时直接调用了对应的值，而操作对象等引用类型数据时，实际上是通过调用其引用地址来操作的<strong>（如果是基础数据类型，拷贝会拷贝其对应的值；如果是引用数据类型，只会拷贝这个引用地址，引用地址指向共用一个堆内存，并不是一个新的对象，数据会同步变化）</strong></em></p>
<h2 id="3、对象（Object）"><a href="#3、对象（Object）" class="headerlink" title="3、对象（Object）"></a>3、对象（Object）</h2><p>&emsp;&emsp;在JavaScript中，几乎所有的对象都是Object类型的实例，它们都会从Object.prototype继承属性和方法。Object 构造函数为给定值创建一个对象包装器。给定值是 null 或 undefined，将会创建并返回一个空对象；给定值是一个基本类型的值，则会构造其包装类型的对象；给定值是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址</p>
<p>&emsp;&emsp;对象Object构造函数属性：<u>Object.length（值为1）</u>、Object.prototype（可以为所有 Object 类型的对象添加属性）</p>
<p>&emsp;&emsp;对象Object构造函数方法：<br>&emsp;&emsp;Object.assign()：通过复制一个或多个对象来创建一个新的对象<br>&emsp;&emsp;Object.create()：使用指定的原型对象和属性创建一个新对象<br>&emsp;&emsp;Object.defineProperty()/Object.defineProperties()：给对象添加一个/多个属性并指定该属性的配置<br>&emsp;&emsp;Object.entries()：返回给定对象自身可枚举属性的 [key, value] 数组<br>&emsp;&emsp;Object.freeze()：冻结对象：其他代码不能删除或更改任何属性<br>&emsp;&emsp;Object.isFrozen()：判断对象是否已经冻结<br>&emsp;&emsp;Object.seal()：防止其他代码删除对象的属性<br>&emsp;&emsp;Object.isSealed()：判断对象是否已经密封<br>&emsp;&emsp;Object.is()：比较两个值是否相同。所有 NaN 值都相等（与==和===有区别）<br>&emsp;&emsp;Object.getPrototypeOf()：返回指定对象的原型对象<br>&emsp;&emsp;Object.setPrototypeOf()：设置对象的原型（即内部 [[Prototype]] 属性）<br>&emsp;&emsp;Object.keys()：返回一个包含所有给定对象自身可枚举属性名称的数组<br>&emsp;&emsp;Object.values()：返回给定对象自身可枚举值的数组</p>
<p>&emsp;&emsp;对象实例的属性：Object.prototype.constructor (对象的构造函数)、Object.prototype.<strong>proto</strong> (指向当对象被实例化的时候，用作原型的对象)</p>
<p>&emsp;&emsp;对象实例的方法 (Object.prototype上的方法)：<br>&emsp;&emsp;hasOwnProperty()：返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的<br>&emsp;&emsp;isPrototypeOf()：返回一个布尔值，表示指定的对象是否在本对象的原型链中<br>&emsp;&emsp;toSource()：返回字符串表示此对象的源代码形式，可以使用此字符串生成一个新的相同的对象<br>&emsp;&emsp;toString()：返回对象的字符串表示<br>&emsp;&emsp;valueOf()：返回指定对象的原始值<br>&emsp;&emsp;watch()/unwatch()：添加/移除对象某个属性的监听</p>
<p>&emsp;&emsp;对象(Object)以及实例方法示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const origin &#x3D; &#123;</span><br><span class="line">  name: &#39;original Object&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过Object.create知道origin为原型创建obj对象</span><br><span class="line">const obj &#x3D; Object.create(origin)</span><br><span class="line">console.log(&#39;输出obj实例对象的原型&#39;)</span><br><span class="line">console.log(obj.__proto__) &#x2F;&#x2F; &#123;name: &quot;original Object&quot;&#125;</span><br><span class="line">console.log(&#39;输出obj实例对象&#39;)</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">console.log(&#39;输出obj实例对象的name&#39;)</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; original Object (obj实例没有name属性，打印出的name属性是原型链上origin对象的name属性)</span><br><span class="line">console.log(&#39;设置并输出obj的name属性值为obj&#39;)</span><br><span class="line">obj.name &#x3D; &#39;obj&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; obj</span><br><span class="line">console.log(&#39;使用Object.defineProperty设置obj属性age为18,添加修饰符设置为其可枚举，但不可修改与删除&#39;)</span><br><span class="line">Object.defineProperty(obj, &#39;age&#39;, &#123;</span><br><span class="line">  value: 18,</span><br><span class="line">  writable: false, &#x2F;&#x2F; 对象属性值是否能被修改（默认false）</span><br><span class="line">  enumerable: true, &#x2F;&#x2F; 对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举（默认false）</span><br><span class="line">  configurable: false &#x2F;&#x2F;设置属性是否能被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改（默认false）</span><br><span class="line">&#125;)</span><br><span class="line">console.log(obj.age) &#x2F;&#x2F; 18</span><br><span class="line">console.log(&#39;输出obj中可枚举的属性列表&#39;)</span><br><span class="line">console.log(Object.keys(obj)) &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">delete obj.age</span><br><span class="line">obj.age &#x3D; 20</span><br><span class="line">console.log(&#39;obj的age属性删除与修改无效&#39;)</span><br><span class="line">console.log(Object.keys(obj), obj.age)  &#x2F;&#x2F; [&quot;name&quot;, &quot;age&quot;] 18</span><br><span class="line">console.log(&#39;使用Object.defineProperty设置obj属性num,添加get、set方法，[注]存取修饰符get和set不能与value或writable等数据修饰符同时使用&#39;)</span><br><span class="line">Object.defineProperty(obj, &#39;num&#39;, &#123;</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    console.log(&#39;---获取了num的值为&#39; + value)</span><br><span class="line">    return value</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (x) &#123;</span><br><span class="line">    value &#x3D; x</span><br><span class="line">    console.log(&#39;---设置了num的值为&#39; + value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;设置与访问obj对象num值为100&#39;)</span><br><span class="line">obj.num &#x3D; 100 &#x2F;&#x2F; ---设置了num的值为100 (set函数打印)</span><br><span class="line">console.log(obj.num) &#x2F;&#x2F; ---获取了num的值为100 (get函数打印)  100</span><br><span class="line">console.log(&#39;设置与访问obj对象num值为200&#39;)</span><br><span class="line">obj.num &#x3D; 200 &#x2F;&#x2F; ---设置了num的值为200 (set函数打印)</span><br><span class="line">console.log(obj.num) &#x2F;&#x2F; ---获取了num的值为200 (get函数打印)  200</span><br><span class="line">console.log(&#39;obj添加的num属性默认不可枚举&#39;)</span><br><span class="line">console.log(Object.keys(obj)) &#x2F;&#x2F;  [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line"></span><br><span class="line">console.log(&#39;使用实例方法hasOwnProperty()判断obj对象是否有num属性&#39;)</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;num&#39;)) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h2 id="4、正则（RegExp）"><a href="#4、正则（RegExp）" class="headerlink" title="4、正则（RegExp）"></a>4、正则（RegExp）</h2><p>&emsp;&emsp;正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。</p>
<p>&emsp;&emsp;创建正则实例对象的两种方法：<br>&emsp;&emsp;正则表达式字面量：由斜杠(/)包围而不是引号包围<br>&emsp;&emsp;RegExp对象的构造函数：构造函数传入字符串参数，由引号而不是斜杠包围 （可以动态参数正则表达式实例，[注] 需要使用常规的字符转义规则）</p>
<p>&emsp;&emsp;正则实例对象方法 (RegExp.prototype上的方法)：<br>&emsp;&emsp;compile()：编译正则表达式<br>&emsp;&emsp;<u>exec()</u>：在字符串中执行匹配项的搜索<br>&emsp;&emsp;<u>test()</u>：该正则在字符串里是否有匹配<br>&emsp;&emsp;toString()：返回表示指定对象的字符串，屏蔽了Object.prototype.toString()方法</p>
<p>正则实例对象方法示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str &#x3D; &#39;apple orange banana&#39;</span><br><span class="line">console.log(&#39;检测str字符串是否匹配到字符串Orange&#39;)</span><br><span class="line">const reg &#x3D; &#x2F;Orange&#x2F;</span><br><span class="line">console.log(reg.test(str)) &#x2F;&#x2F; false</span><br><span class="line">console.log(&#39;检测str字符串是否匹配到字符串OrAnge，忽略字母大小写&#39;)</span><br><span class="line">const reg1 &#x3D; &#x2F;OrAnge&#x2F;i</span><br><span class="line">console.log(reg1.test(str)) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;检测str字符串是否以字符串orange开头&#39;)</span><br><span class="line">const reg2 &#x3D; &#x2F;^orange&#x2F;</span><br><span class="line">console.log(reg2.test(str)) &#x2F;&#x2F; false</span><br><span class="line">console.log(&#39;检测str字符串是否以字符串apple开头&#39;)</span><br><span class="line">const reg3 &#x3D; &#x2F;^apple&#x2F;</span><br><span class="line">console.log(reg3.test(str)) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;检测str字符串是否以字符串banana结尾&#39;)</span><br><span class="line">const reg4 &#x3D; &#x2F;banana$&#x2F;</span><br><span class="line">console.log(reg4.test(str)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">const str1 &#x3D; &#39;abaccabaa&#39;</span><br><span class="line">console.log(&#39;检索str1字符串中是否有aa、ab或ac的字符串&#39;)</span><br><span class="line">const reg5 &#x3D; &#x2F;a[abc]&#x2F;g</span><br><span class="line">let result</span><br><span class="line">while ((result &#x3D; reg5.exec(str1)) !&#x3D; null) &#123;</span><br><span class="line">  console.log(&#96;在字符串$&#123;str1&#125;检索到$&#123;result[0]&#125;，下次匹配从位置$&#123;reg5.lastIndex&#125;开始&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环输出</span><br><span class="line">在字符串abaccabaa检索到ab，下次匹配从位置2开始</span><br><span class="line">在字符串abaccabaa检索到ac，下次匹配从位置4开始</span><br><span class="line">在字符串abaccabaa检索到ab，下次匹配从位置7开始</span><br><span class="line">在字符串abaccabaa检索到aa，下次匹配从位置9开始</span><br><span class="line"></span><br><span class="line">console.log(reg5.lastIndex) &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">console.log(&#39;使用字符串match方法检索字符串&#39;)</span><br><span class="line">console.log(str1.match(reg5)) &#x2F;&#x2F; [&quot;ab&quot;, &quot;ac&quot;, &quot;ab&quot;, &quot;aa&quot;]</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 当正则表达式使用 ‘g’ 标志时，可以多次执行exec()、test()方法来查找同一个字符串中的成功匹配。查找将从正则表达式的 lastIndex(下一次匹配开始的位置)属性指定的位置开始。如果匹配成功, lastIndex会被更新，即使再次查找的字符串不是原查找字符串时，lastIndex 也不会被重置，它依旧会从记录的 lastIndex 开始；如果匹配失败，exec()方法返回 null，lastIndex会重置为0 。</em></p>
<p>&emsp;&emsp;正则表达式中的特殊字符与含义：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个表达式 0 次或多次。等价于 {0,}</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面一个表达式 1 次或者多次。等价于 {1,}</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}</td>
</tr>
<tr>
<td>.</td>
<td>(小数点) 默认匹配除换行符之外的任何单个字符，如果 s (“dotAll”) 标志位被设为 true，它也会匹配换行符</td>
</tr>
<tr>
<td>(x)</td>
<td>匹配 ‘x’ 并且记住匹配项，其中括号被称为捕获括号</td>
</tr>
<tr>
<td>(?:x)</td>
<td>匹配 ‘x’ 但是不记住匹配项，这种括号叫作非捕获括号</td>
</tr>
<tr>
<td>x(?=y)</td>
<td>匹配’x’仅仅当’x’后面跟着’y’（先行断言）</td>
</tr>
<tr>
<td>(?&lt;=y)x</td>
<td>匹配’x’仅当’x’前面是’y’（后行断言）</td>
</tr>
<tr>
<td>x(?!y)</td>
<td>仅当’x’后面不跟着’y’时匹配’x’（正向否定查找）</td>
</tr>
<tr>
<td>(?&lt;!y)x</td>
<td>仅当’x’后面不是’y’时匹配’x’（反向否定查找）</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配’x’或者’y’</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配了前面一个字符刚好出现了 n 次 (n 是一个正整数)</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配了前面一个字符至少出现了 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0，这个值被忽略 (m也是一个正整数)</td>
</tr>
<tr>
<td>[xyz]</td>
<td>一个字符集合，匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>一个反向字符集，匹配任何没有包含在方括号中的字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个词的边界，不要和[\b]混淆，后者匹配一个退格</td>
</tr>
<tr>
<td>\B</td>
<td>匹配一个非单词边界</td>
</tr>
<tr>
<td>\cX</td>
<td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符，例如，反斜杠cM匹配字符串中的 control-M</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>\0</td>
<td>匹配 NULL字符  <em>[注]不要在这后面跟其它小数，\0&lt;digits&gt; 是一个八进制转义序列</em></td>
</tr>
<tr>
<td>\s</td>
<td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配一个非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个非单字字符。等价于 [^A-Za-z0-9_]</td>
</tr>
</tbody></table>
<h2 id="5、日期（Date）"><a href="#5、日期（Date）" class="headerlink" title="5、日期（Date）"></a>5、日期（Date）</h2><p>&emsp;&emsp;Date 对象则基于 Unix Time Stamp，即自1970年1月1日（UTC）起经过的毫秒数。<br>&emsp;&emsp;创建一个新Date实例对象的唯一方法是通过new 操作符，若不使用new关键字，将Date()当做常规函数调用，会返回一个表示时间的字符串。</p>
<p>&emsp;&emsp;Date()构造函数有4种基本形式：<br>&emsp;&emsp;① 没有参数，新创建的Date对象表示当前的日期和时间<br>&emsp;&emsp;② Unix时间戳：整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数<br>&emsp;&emsp;③ 时间戳字符串：表示日期的字符串值（字符串应该能被 Date.parse() 方法正确识别）<br>&emsp;&emsp;④ 提供日期与时间的各个成员：至少提供了年份与月份时，没有提供的成员将使用最小可能值（如日期为1，其他为0）</p>
<p>&emsp;&emsp;日期Date对象的属性：Date.prototype (允许为 Date 对象添加属性)、<u>Date.length (值是7,因为该构造函数可接受的参数个数)</u></p>
<p>&emsp;&emsp;日期Date对象的方法：<br>&emsp;&emsp;Date.now()：返回自 1970-1-1 00:00:00  UTC（世界标准时间）至今所经过的毫秒数<br><em>&emsp;&emsp;[注] <u>与performance.now()方法不同，performance.now()返回一个精确到毫秒的 DOMHighResTimeStamp，并不是高精度的，常与requestAnimationFrame一起使用来判断当前动画已执行了多少时间。requestAnimationFrame()的回调函数会被传入DOMHighResTimeStamp参数，表示当前被排序的回调函数被触发的时间</u></em><br>&emsp;&emsp;Date.parse()：解析表示日期的字符串，并返回从1970-1-1 00:00:00所经过的毫秒数（不同浏览器有差异）<br>&emsp;&emsp;Date.UTC()：接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数</p>
<p>&emsp;&emsp;日期实例对象的属性：Date.prototype.constructor （返回创建了实例的构造函数，默认是 Date 构造函数）</p>
<p>&emsp;&emsp;日期实例对象的方法 (Date.prototype上的方法)：<br>&emsp;&emsp;getDay()：返回指定日期对象的星期中的第几天（0-6）<br>&emsp;&emsp;getFullYear()/setFullYear()：返回指定日期对象的年份/指定日期对象设置完整年份（四位数年份时返回四位数字）<br>&emsp;&emsp;getMonth()/setMonth()：返回指定日期对象的月份/指定日期对象设置月份（0-11）<br>&emsp;&emsp;getDate()/setDate()：返回指定日期对象的月份中的第几天/指定的日期对象设置月份中的第几天（1-31）<br>&emsp;&emsp;getHours()/setHours()：返回指定日期对象的小时/指定日期对象设置小时数（0-23）<br>&emsp;&emsp;getMinutes()/setMinutes()：返回指定日期对象的分钟/指定日期对象设置分钟数（0-59）<br>&emsp;&emsp;getSeconds()/setSeconds()：返回指定日期对象的秒数/指定日期对象设置秒数（0-59）<br>&emsp;&emsp;getMilliseconds()/setMilliseconds()：返回指定日期对象的毫秒/指定日期对象设置毫秒数（0-999）<br>&emsp;&emsp;getTime()/setTime()：<u>返回从1970-1-1 00:00:00 UTC到该日期经过的毫秒数</u>/通过指定从 1970-1-1 00:00:00 UTC 开始经过的毫秒数来设置日期对象的时间(1970-1-1 00:00:00 UTC之前的时间返回负值)<br>&emsp;&emsp;toDateString()：以易读的形式返回该日期对象日期部分的字符串</p>
<p>&emsp;&emsp;日期实例方法示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const timeStamp &#x3D; new Date()</span><br><span class="line">const year &#x3D; timeStamp.getFullYear()</span><br><span class="line">const month &#x3D; timeStamp.getMonth() + 1</span><br><span class="line">const day &#x3D; timeStamp.getDate()</span><br><span class="line">const hh &#x3D; timeStamp.getHours()</span><br><span class="line">const mm &#x3D; timeStamp.getMinutes()</span><br><span class="line">const ss &#x3D; timeStamp.getSeconds()</span><br><span class="line">console.log(&#39;当前时间为: &#39; + year + &#39;年&#39; + month + &#39;月&#39; + day + &#39;日 &#39; + hh + &#39;时&#39; + mm + &#39;分&#39; + ss + &#39;秒&#39;)</span><br><span class="line">&#x2F;&#x2F; 当前时间为: 2021年5月28日 0时26分31秒</span><br><span class="line"></span><br><span class="line">console.log(&#39;以易读的形式返回该日期对象日期部分&#39;)</span><br><span class="line">console.log(timeStamp.toDateString()) &#x2F;&#x2F; Fri May 28 2021</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS预解析、作用域、执行上下文、this</title>
    <url>/2020/12/05/javascript/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/</url>
    <content><![CDATA[<p>这部分是JavaScript比较基础的部分。JS代码运行前的极短时间内会进行语法分析、代码预解析以及解释执行。其中预解析最重要。分为全局预解析和局部预解析，全局预解析发生在页面加载完成时执行，而局部预解析发生在函数执行的前一刻(在极短时间内完成)。会进行变量与函数声明（变量提升）、生成执行上下文（作用域）等工作。</p>
<h2 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h2><p>&emsp;&emsp;JavaScript采用<u>词法作用域</u>，作用域在代码定义时就确定，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限，执行时并且不会改变（作用域访问的变量是编写代码的结构确定的）。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文对象构成的链表就叫做作用域链。函数的原型（prototype）属性存在[[Scopes]]属性保存着当前函数的作用域链信息。</p>
<p>&emsp;&emsp;作用域分为全局作用域、函数(局部)作用域、块级作用域（ES6引入）。<br>&emsp;&emsp;① 在代码中任何地方都能访问到的对象拥有全局作用域。<u>全局作用域的变量是全局对象(window)的属性</u>，不论在什么函数中都可以直接访问，而不需要通过全局对象，<u>但加上全局对象，可以提供搜索效率。</u><br><em>&emsp;&emsp;[注] 隐式的声明变量，或在最外层函数外部声明的变量，以及给window对象添加的属性都是全局变量，<strong>隐式声明的变量不存在变量提升</strong></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">console.log(b) &#x2F;&#x2F; Uncaught ReferenceError: b is not defined (异常，代码停止执行，变量b没有提升)</span><br><span class="line">  b &#x3D; a</span><br><span class="line">&#125;</span><br><span class="line">foo(2)</span><br><span class="line">console.log(b) &#x2F;&#x2F; 未执行</span><br><span class="line"></span><br><span class="line">function foo(a) &#123;</span><br><span class="line">  b &#x3D; a</span><br><span class="line">&#125;</span><br><span class="line">foo(2)</span><br><span class="line">console.log(b) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;② 在函数内部用var关键字声明的变量，函数的参数会存在于该函数的局部作用域中。<br><em>&emsp;&emsp;[注] 局部变量的优先级高于全局变量</em><br>&emsp;&emsp;③ 用let、const声明的变量会存在于块级作用域中。</p>
<h2 id="2、预解析与执行上下文"><a href="#2、预解析与执行上下文" class="headerlink" title="2、预解析与执行上下文"></a>2、预解析与执行上下文</h2><p>&emsp;&emsp;JavaScript代码在执行前的瞬间会存在预解析的阶段，会对代码进行相应的处理，对声明的变量与函数进行变量提升，以及生成对应的执行上下文，执行上下文除了保存代码执行信息外，还会将当前作用域信息也保存在执行上下文中，他们有相应的存储关系。随着代码进行的进行，执行上下文会进行相应的改变，执行上下文是用于跟踪代码的运行情况。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p>
<p>&emsp;&emsp;预解析过程创建执行上下文的步骤：<br>&emsp;&emsp;① 隐式的创建GO（全局上下文）/AO（函数上下文）对象<br>&emsp;&emsp;② 找形参和变量声明，将变量和形参名作为GO/AO的属性名，值为undefined（这个过程也常称为变量提升）<br>&emsp;&emsp;③ 将实参值和形参统一<br>&emsp;&emsp;④ 在函数体里面找函数声明，作为GO/AO的属性，值赋予函数体（这个过程也常称为函数提升）<br><em>&emsp;&emsp;[注] 在全局预解析中，由于全局中没有参数的的概念，所以省去了第2步的找参数。第2步中的找变量声明与第3步实参形参相统一一同处理。GO全局上下文对象，它优于局部预解析AO局部上下文对象的创建与执行</em></p>
<p>&emsp;&emsp;例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(b) &#x2F;&#x2F; Uncaught ReferenceError: b is not defined</span><br><span class="line">var a &#x3D; 5</span><br><span class="line">console.log(a) &#x2F;&#x2F; 5</span><br><span class="line">console.log(test) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(fn) &#x2F;&#x2F; function fn () &#123;&#125;</span><br><span class="line">console.log(fn(3)) &#x2F;&#x2F; 11</span><br><span class="line">var test &#x3D; function () &#123;</span><br><span class="line">  return 10</span><br><span class="line">&#125;</span><br><span class="line">function fn(x) &#123;</span><br><span class="line">  console.log(a) &#x2F;&#x2F; undefined</span><br><span class="line">  var a &#x3D; b &#x3D; 8</span><br><span class="line">  var c &#x3D; 6</span><br><span class="line">  return a + x</span><br><span class="line">&#125;</span><br><span class="line">console.log(a) &#x2F;&#x2F; 5</span><br><span class="line">console.log(b) &#x2F;&#x2F; 8</span><br><span class="line">console.log(c) &#x2F;&#x2F; Uncaught ReferenceError: c is not defined</span><br><span class="line">console.log(test()) &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>上面的代码在执行前的瞬间，会先进行全局预解析。过程如下：（这里只列举了执行上下文中的部分信息）</strong></p>
<p>&emsp;&emsp;(1) 进行全局预解析的第1步：创建全局上下文GO对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(2) 进行全局预解析的第2步：找变量声明，将变量作为GO的属性名，值为undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">  a: undefined,</span><br><span class="line">  test: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(3) 进行全局预解析3步：在函数体里面找函数声明，作为GO的属性，值赋予函数体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">  a: undefined,</span><br><span class="line">  test: undefined</span><br><span class="line">  fn: function fn () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>全局预解析完成，代码开始执行，执行过程如下：</strong><br>&emsp;&emsp;执行第1行，输出a为undefined<br>&emsp;&emsp;执行第2行，因为全局上下文没有声明b变量，所以程序抛出异常：Uncaught ReferenceError: b is not defined<br>&emsp;&emsp;执行第3行，将全局上下文中a赋值为5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO:&#123;</span><br><span class="line">  a: 5,</span><br><span class="line">  test: undefined</span><br><span class="line">  fn: function fn () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行第4行，输出a为5<br>&emsp;&emsp;执行第5行，输出test为undefined<br>&emsp;&emsp;执行第6行，输出fn为function fn () {}</p>
<p>&emsp;&emsp;<strong>执行第7行，调用fn并传入参数3，在fn执行前瞬间，会进行局部预编译，过程如下：</strong></p>
<p>&emsp;&emsp;(1) 进行局部预解析的第1步： 创建对应的函数上下文AO对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO: &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(2) 进行局部预解析的第2步：找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO: &#123;</span><br><span class="line">  x: undefined,</span><br><span class="line">  a: undefined,</span><br><span class="line">  c: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] <u>在第13行’var a = b = 8’，这里隐式的声明了全局变量b，此时应该将变量b添加到GO对象中，</u>此时的GO对象为：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">  a: 5,</span><br><span class="line">  test: undefined,</span><br><span class="line">  fn: function fn () &#123;&#125;,</span><br><span class="line">  b: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(3) 进行局部预解析第3步：将实参与形参统一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO:&#123;</span><br><span class="line">  x: 3,</span><br><span class="line">  a: undefined,</span><br><span class="line">  c: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(4) 对于fn函数，进行预解析第4步：在函数体里面找函数声明，作为AO的属性，值赋予函数体<br>&emsp;&emsp;fn函数内无函数声明，AO对象不变</p>
<p>&emsp;&emsp;<strong>fn函数执行前预解析完成，11-16行的<u>函数入栈执行！</u></strong><br>&emsp;&emsp;执行第12行，输出a为undefined（先在当前执行的函数上下文AO的作用域对象中查找变量a，若AO的作用域对象中没有，通过AO中的作用域链，再去全局上下文GO中去查找）<br>&emsp;&emsp;执行第13行，将变量b赋值为8，变量a赋值为8。其中变量b存在于全局上下文GO中，这里的a为当前执行的函数上下文AO中的a，此时的GO、AO对象为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO:&#123;</span><br><span class="line">  a: 5,</span><br><span class="line">  test: undefined,</span><br><span class="line">  fn: function fn () &#123;&#125;,</span><br><span class="line">  b: 8</span><br><span class="line">&#125;</span><br><span class="line">AO:&#123;</span><br><span class="line">    x: 3,</span><br><span class="line">    a: 8,</span><br><span class="line">    c:undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行第14行，将AO中的c变量赋值为6，此时的AO为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO:&#123;</span><br><span class="line">  x: 3,</span><br><span class="line">  a: 8,</span><br><span class="line">  c: 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>执行第15行，计算a+x的值为11，并返回函数调用的地方。所以第7行输出函数fn(3)的执行结果11。<u>函数执行完成，函数出栈，当前执行上下文AO对象被销毁。 </u></strong><br>&emsp;&emsp;执行第8行，将GO中test赋值为function () { return 10 }，此时的GO对象为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">  a: 5,</span><br><span class="line">  test: undefined,</span><br><span class="line">  fn: function fn () &#123;&#125;,</span><br><span class="line">  b: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行第17行，输出a为5<br>&emsp;&emsp;执行第18行，输出b为8<br>&emsp;&emsp;执行第19行，因为全局上下文没有声明c变量，所以程序抛出异常：Uncaught ReferenceError: c is not defined<br>&emsp;&emsp;执行第20行，<u>这里调用test()函数与上面调用fn(3)函数类似，执行前也会进行相应的局部预解析，创建对应的AO对象。然后函数入栈执行，</u>这最后函数返回执行结果为10<br>&emsp;&emsp;代码执行完成！</p>
<p><em>&emsp;&emsp;[注] 这里分析比较简单的一段代码的执行过程，这里在函数内部没有函数的声明，也没有异步处理。一般的，如果函数内部存在函数，在内部函数调用时也会进行对应的局部预处理以及入栈执行；如果代码内包含异步逻辑，会把异步逻辑放在异步队列里面进行相应的调度执行。</em><br><em>&emsp;&emsp;[注] 如果在某个作用域中使用了某变量，而该变量并未在对应的（静态）作用域中声明，而在其它作用域（父级）中声明，该变量称为<u>自由变量（即跨域了当前对应的作用域的变量叫做自由变量）。</u></em></p>
<h2 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h2><p>&emsp;&emsp;一个函数和对其周围状态（词法环境）的引用捆绑在一起，这样的组合就是闭包（closure）。闭包让你可以在一个内层函数中访问到其外层函数的作用域（即能够读取其他函数内部变量的函数）。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。<strong>函数就会形成闭包。</strong><u>闭包是由函数以及声明该函数的词法环境组合而成的。</u>该环境包含了这个闭包创建时作用域内的任何局部变量。</p>
<p>&emsp;&emsp;例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(x) &#123;</span><br><span class="line">  console.log(inner.__proto__)</span><br><span class="line">  function inner(y) &#123;</span><br><span class="line">      return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  return inner;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(3)(4))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; &#123;constructor: ƒ&#125;</span><br><span class="line">&#x2F;&#x2F; constructor: ƒ inner(y)</span><br><span class="line">&#x2F;&#x2F; arguments: null</span><br><span class="line">&#x2F;&#x2F; caller: null</span><br><span class="line">&#x2F;&#x2F; length: 1</span><br><span class="line">&#x2F;&#x2F; name: &quot;inner&quot;</span><br><span class="line">&#x2F;&#x2F; prototype: &#123;constructor: ƒ&#125;</span><br><span class="line">&#x2F;&#x2F; __proto__: ƒ ()</span><br><span class="line">&#x2F;&#x2F; [[FunctionLocation]]: scopes.html:14</span><br><span class="line">&#x2F;&#x2F; [[Scopes]]: Scopes[2]</span><br><span class="line">&#x2F;&#x2F; 0: Closure (add) &#123;x: 3&#125;</span><br><span class="line">&#x2F;&#x2F; 1: Global &#123;window: Window, self: Window, document: document, name: &quot;&quot;, location: Location, …&#125;</span><br><span class="line">&#x2F;&#x2F; __proto__: Object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码中：add函数内部定义了inner函数，inner函数可以访问词法环境外部add函数作用域中变量，如这里的形参x。从打印的inner.prototype对象可以看出，在inner函数的作用域链的栈底为Global全局作用域，栈顶为inner函数所在的add函数的作用域，这里形成了Closure闭包。add(3)函数调用后返回的inner(y){ return x + y; }函数(x=3)与inner函数的词法环境形成了闭包，<u>inner函数中保留了对add函数内部变量x的应用，且此时x=3</u>，所以在add(3)(4)继续调用inner函数时返回结果7。</p>
<p><em>&emsp;&emsp;[注] 这里<u>是否形成闭包与内部的inner函数是否返回无关，函数便会形成闭包。</u></em></p>
<h2 id="4、this关键字"><a href="#4、this关键字" class="headerlink" title="4、this关键字"></a>4、this关键字</h2><p>&emsp;&emsp;在绝大多数情况下，<u>函数的调用方式决定了 this 的值（<strong>运行时绑定</strong>）。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同（<strong>与调用方式有关</strong>）。</u>ES5 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。ES2015 引入了箭头函数，箭头函数不提供自身的 this 绑定，此时this 的值将保持为当前闭合词法上下文的值。即函数中this的取值为当前执行上下文（global、function 或 eval）的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。</p>
<p>&emsp;&emsp;① 在全局上下文中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this) &#x2F;&#x2F; Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">console.log(this) &#x2F;&#x2F; Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;② 在函数上下文中，this指向取决于函数被调用的方式：在非严格模式下，this的值不由调用者设置，this指向window。在严格模式下，this指向调用者，若执行前没有设置this的值，也没有作为对象的属性或方法而是直接调用，this为undefined。<br><em>&emsp;&emsp;[注] 可以通过call、apply方法修改this指向的环境。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  console.log(this) &#x2F;&#x2F; Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">(function () &#123;</span><br><span class="line">  console.log(this) &#x2F;&#x2F; undefined</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">function test() &#123;</span><br><span class="line">  console.log(this) &#x2F;&#x2F; Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;</span><br><span class="line">&#125;</span><br><span class="line">test.apply(window)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;③ 类上下文中，基类与派生类构造函数constructor()中this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象，所有非静态方法会被添加到this的原型中。在派生类中的构造函数没有初始的this绑定，在构造函数中调用super()才能生成一个this绑定。<u>注意的是，使用super对象时，super 调用父类的方法时，super 会绑定当前子类的 this。</u><br><em>&emsp;&emsp;[注] 静态方法不是this的属性，它们只是类自身的属性。派生类（子类）在super()前调用this会抛出异常(ReferenceError)，派生类不能在调用super前返回，除非没有构造函数或者构造函数返回了对象。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    console.log(this) &#x2F;&#x2F; A &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A()</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    console.log(this) &#x2F;&#x2F; Uncaught ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new B()</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    console.log(this) &#x2F;&#x2F; B &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    console.log(this) &#x2F;&#x2F; B &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new B()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特别的~</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    return &#123; a: 1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new B()) &#x2F;&#x2F; &#123; a: 1 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="欺骗词法作用域"><a href="#欺骗词法作用域" class="headerlink" title="欺骗词法作用域"></a>欺骗词法作用域</h2><p>&emsp;&emsp;词法作用域完全由写代码期间所声明的位置决定，在JavaScript中有两种机制来实现在运行时“修改”（欺骗）所处的词法作用域。一般并不推荐使用，因为<u>欺骗词法作用域会导致性能下降</u>。</p>
<p>&emsp;&emsp;1) 两种机制(<u>对应编码方式并不推荐使用</u>)：</p>
<p>&emsp;&emsp;① eval<br>&emsp;&emsp;Javascript中的eval()函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时代码就存在于程序这个位置，无论何种情况，eval()都可以在运行期修改所在的作用域。在执行eval()之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态的形式插入进来，并已对词法作用域环境进行修改。引擎只会如往常地进行查找。</p>
<p>&emsp;&emsp;滥用eval()动态执行代码可能造成一些问题(变量泄漏、污染全局作用域、性能损失)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(str, a) &#123;</span><br><span class="line">  eval(str)</span><br><span class="line">  console.log(a, b) &#x2F;&#x2F; 1 3</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; 2</span><br><span class="line">foo(&#39;var b &#x3D; 3&#39;, 1)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;foo()函数中使用eval()函数动态插入’var b = 3’，这段代码实际上在foo()内部创建了一个变量b，并遮蔽了外部（全局）作用域中的同名变量。当console.log()被执行时，在foo()函数的作用域内同时找到了a和b，所以永远不会找到外部的b，因此输出1、3。</p>
<p><em>&emsp;&emsp;[注] 在严格模式的程序中，eval()在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(str) &#123;</span><br><span class="line">  &quot;use strict&quot;</span><br><span class="line">  eval(str)</span><br><span class="line">  console.log(a) &#x2F;&#x2F; Uncaught ReferenceError: a is not defined</span><br><span class="line">&#125;</span><br><span class="line">foo(&#39;var a &#x3D; 3&#39;)</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] JavaScript中还有其他一些功能效果和eval()很相似。setTimeout()与setInterval()的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码，这些功能已经过时且不被提倡，也会造成变量泄漏、污染全局作用域、性能损失。new Function()函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成函数的形参）。这种构建比eval()略微安全一些，但也要尽量避免使用。<u>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</u></em></p>
<p>&emsp;&emsp;② with<br>&emsp;&emsp;with通常被当做重复引用同一个对象中的多个属性的快捷方法，可以不需要重复引用对象本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">with(obj) &#123; a &#x3D; 3,  b &#x3D; 4, c &#x3D; 5 &#125;</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;a: 3, b: 4, c: 5&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;滥用with也可能造成一些问题(变量泄漏、污染全局作用域、性能损失)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(obj) &#123;</span><br><span class="line">  with (obj) &#123; a &#x3D; 2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o1 &#x3D; &#123; a: 3 &#125;</span><br><span class="line">let o2 &#x3D; &#123; b: 3 &#125;</span><br><span class="line"></span><br><span class="line">foo(o1)</span><br><span class="line">console.log(o1.a) &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; console.log(a) &#x2F;&#x2F; ReferenceError: a is not defined</span><br><span class="line"></span><br><span class="line">foo(o2)</span><br><span class="line">console.log(o2.a) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(a) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] with可以将一个对象处理为词法作用域。当传递o1给with时，with中所声明的作用域是o1，在o1作用域中执行‘a=2’时，查询到属性a并对a赋值为2。当后面with将o2作为作用域时，在o2的作用域、foo函数作用域、全局作用域都没有找到属性a,因此执行‘a=2’时，会隐式的创建一个全局变量a并赋值为2(当前代码运行在非严格模式下)</em></p>
<p><em>&emsp;&emsp;[注] eval()与with性能问题：</em></p>
<p><em>&emsp;&emsp;JavaScript引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是如果引擎在代码中发现了eval()与with，它只简单的假设关于标识符的位置判断搜索无效的，因为无法在词法分析阶段明确知道eval()会接收到什么代码，这些代码会对作用域进行怎样的修改，也无法知道传的给with用来创建新词法作用域的对象内容到底是什么。</em></p>
<p><em>&emsp;&emsp;最悲观的情况是如果出现了eval()和with，所有的优化可能都是无意义的，因此最简单最谨慎的做法是<u>完全不做任何优化。</u>如果代码中大量使用eval()和with，那么运行起来会变得非常缓慢。无论引擎多聪明，试图将这些悲观的情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</em></p>
<p><em>&emsp;&emsp;[注] 在JavaScript中，作用域是由函数(function)和块级作用域(ES6 let、const定义块级作用域)划分的。不是由语句块划分的，在while、for、if语句中，隐式定义的变量都是全局变量，在 for 循环里使用了 var 关键字定义的变量也是全局变量，因为在while、for、if中的区域属于全局作用域。有时编码时把 == 或 === 误写成 = 便会出现意想不到的错误。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (a &#x3D; 1) &#123; b &#x3D; 2; break &#125;</span><br><span class="line">console.log(a, b) &#x2F;&#x2F; 1 2</span><br><span class="line">for (var c &#x3D; 2; c &lt; 3; c++) &#123; d &#x3D; 4 &#125;</span><br><span class="line">console.log(c, d) &#x2F;&#x2F; 3 4</span><br><span class="line">if (e &#x3D; 5) &#123; f &#x3D; 6 &#125;</span><br><span class="line">console.log(e, f) &#x2F;&#x2F; 5, 6</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;for语句条件部分使用 let 定义会形成多个块级作用域，定义的循环变量不会污染全局变量。但执行语句里的 var 关键字声明或隐式声明会污染全局变量。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let c &#x3D; 2; c &lt; 3; c++) &#123; var d &#x3D; 4 &#125;</span><br><span class="line">&#x2F;&#x2F; console.log(c) &#x2F;&#x2F; Uncaught ReferenceError: c is not defined</span><br><span class="line">console.log(d) &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;为了及时发现将 == 或 === 误写成 = 的错误，可进行如下编码(将常量放在 == 或 === 前面，变量名放后面)：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (1 &#x3D;&#x3D; a) &#123; break &#125;</span><br><span class="line">if (5 &#x3D;&#x3D; e) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;如果将上面的代码中的判等符号误写成了 = 符号，代码也不会通过编译，会抛出 Uncaught SyntaxError: Invalid left-hand side in assignment 的错误，因为永远不可能将一个变量的值赋值给一个常量~</em></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件语法</title>
    <url>/2021/10/22/vue/Vue%E7%BB%84%E4%BB%B6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>这部分主要讲创建Vue实例时的配置选项、Vue实例的属性、Vue实例的方法等内容</p>
<h2 id="1、配置选项"><a href="#1、配置选项" class="headerlink" title="1、配置选项"></a>1、配置选项</h2><h3 id="1-数据类选项"><a href="#1-数据类选项" class="headerlink" title="1) 数据类选项"></a>1) 数据类选项</h3><p>&emsp;&emsp;组件的 data 选项是一个函数。Vue 在创建新组件实例的过程中调用此函数，它应该返回一个对象。然后 Vue 会通过响应性系统将其包裹起来，并以 $data 的形式存储在组件实例中，数据类选项就是定义于维护组件数据的相关操作规范</p>
<p>&emsp;&emsp;(1) data(Function)<br>&emsp;&emsp;一般写成函数形式，将组件内部变量进行私有化，data()函数返回组件实例的data对象。如上面的例子，在JS中可以使用this.name来访问，在&lt;template&gt;中直接使用&#123;&#123;name&#125;&#125;来展示</p>
<p>&emsp;&emsp;(2) props(Array&lt;string&gt; | Object)<br>&emsp;&emsp;从父组件接受参数，其值可以是简单的对应参数名称组成的数组或参数以参数名称作为键，带类型检测与数据校验等内容的对象作为值的对象类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单数组形式</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  props: [&#39;name&#39;, &#39;age&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象形式</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;用户A&#39;,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      validator: (value) &#x3D;&gt; value &gt; 18</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;若父组件没有传递name，控制台会发出警告：[Vue warn]: Missing required prop: “name” at &lt;App&gt;。若age没有通过校验，也会发出类似警告</p>
<p>&emsp;&emsp;(3) computed({[key: string]: Function | { get: Function, set: Function }})<br>&emsp;&emsp;计算属性，通过已有的data对象的状态（属性）来派生新的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只有get时的简写形式</span><br><span class="line">computed: &#123;</span><br><span class="line">  isAdult() &#123;</span><br><span class="line">    return this.age &gt;&#x3D; 18</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 举一个同时有get、set的例子</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Test&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        list: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      length: &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">          return this.list.length</span><br><span class="line">        &#125;,</span><br><span class="line">        set(len) &#123;</span><br><span class="line">          if (len &lt; this.list.length) &#123;</span><br><span class="line">            this.list &#x3D; this.list.slice(0, len)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            for (let i &#x3D; this.list.length; i &lt; len; i++) &#123;</span><br><span class="line">              this.list[i] &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(this.length, JSON.parse(JSON.stringify(this.list))) &#x2F;&#x2F; 0, []</span><br><span class="line">      this.list.push(1, 2, 3)</span><br><span class="line">      console.log(this.length, JSON.parse(JSON.stringify(this.list))) &#x2F;&#x2F; 3, [1, 2, 3]</span><br><span class="line">      this.length &#x3D; 2</span><br><span class="line">      console.log(this.length, JSON.parse(JSON.stringify(this.list))) &#x2F;&#x2F; 2 [1, 2]</span><br><span class="line">      this.length &#x3D; 4</span><br><span class="line">      console.log(this.length, JSON.parse(JSON.stringify(this.list))) &#x2F;&#x2F; 4 [1, 2, 0, 0]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面代码中定义了一个list，定义了一个计算属性length，功能是维护length始终于list长度相等。若给length赋的值小于了list的长度，便截取list；若length赋的值大于list长度，则给list尾部追加相应个数的0<br>&emsp;&emsp;list输出时使用了JSON.parse(JSON.stringify())，原因是在Vue3中getter输出的值被Proxy对象包裹</p>
<p><em>&emsp;&emsp;[注] 如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，但可以通过该函数的第一个参数重新获取this</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  isAdult: (that) &#x3D;&gt; &#123; &#x2F;&#x2F; 计算属性箭头函数this为undefined，但可以在回调函数里接收this</span><br><span class="line">    return that.age &gt;&#x3D; 18</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;(4) methods({[key: string]: Function })<br>&emsp;&emsp;methods可以定义一些方法，这些方法的this会被绑定为组件实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  add () &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;定义一个add()函数，使得页面点击一个按钮时触发计数器加1</p>
<p><em>&emsp;&emsp;[注] 特别的，<strong>不应该</strong>在 methods 方法里使用箭头函数，箭头函数绑定了父级作用域的上下文，不会指向这个组件的实例，<u>也不能</u>通过计算属性那样通过回调函数的第一个参数重新获取this</em></p>
<p>&emsp;&emsp;(5) watch({[key: string]: string | Function | Object | Array})<br>&emsp;&emsp;一个对象，键是要侦听的响应式属性——包含了 data 或 computed 的属性，而值是对应的回调函数、方法名、对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt; &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#39;count&#39;: function(newValue, oldValue) &#123; &#x2F;&#x2F; 一般在watch里使用实例的$emit方法，触发父组件更新数据的回调函数</span><br><span class="line">      console.log(newValue, oldValue)</span><br><span class="line">      &#x2F;&#x2F; this.$emit(&#123;string&#125; eventName, [...args])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; 1 0</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 特别的，不应该使用箭头函数来定义 watcher 函数 ，箭头函数绑定了父级作用域的上下文，所以 this 将不会指向组件实例</em></p>
<p>&emsp;&emsp;(6) emits(Array&lt;string&gt; | Object)<br>&emsp;&emsp;emits可以是数组活对虾，当为对象时，以 $emit 事件名为 key 对应的值为一个验证函数，函数将接收传递给 $emit 调用的其他参数验证函数应返回布尔值，以表示事件参数是否有效。<u>但无论是否有效，父组件对应的回调函数好像都被触发了</u>~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;formData.email&quot; placeholder&#x3D;&quot;请输入邮箱&quot; &#x2F;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;formData.password&quot; placeholder&#x3D;&quot;请输入密码&quot; &#x2F;&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;submitHandle&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        formData: &#123;</span><br><span class="line">          email: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    emits: &#123;</span><br><span class="line">      submit: (payload) &#x3D;&gt; &#123;</span><br><span class="line">        if (payload.email &amp;&amp; payload.password) &#123;</span><br><span class="line">          return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&#39;请将邮箱、密码信息填写完整&#39;); &#x2F;&#x2F; 邮箱或密码为空时将输出：请将邮箱、密码信息填写完整</span><br><span class="line">          return false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      submitHandle() &#123;</span><br><span class="line">        this.$emit(&#39;submit&#39;, this.formData)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .form-box &#123; width: 300px; height: 100px; display: flex; flex-direction: column; </span><br><span class="line">    justify-content: space-between; align-items: center; padding: 20px 0;</span><br><span class="line">    border-radius: 4px; border: 1px solid gainsboro;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;(7) expose (Array&lt;string&gt;)<br>&emsp;&emsp;定义哪些属性(方法)将暴露在公共组件实例上供其他组件访问，默认暴露所以属性(方法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; test.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; expose: [],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;test ref&#x3D;&quot;test&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Test from &#39;.&#x2F;components&#x2F;test.vue&#39;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Test</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      console.log(this.$refs.test.count)</span><br><span class="line">      console.log(this.$refs.test.add)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ① 当test.vue没有expose选项时，App.vue输出：</span><br><span class="line">&#x2F;&#x2F;   0</span><br><span class="line">&#x2F;&#x2F;   ƒ add() &#123; this.count++; &#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ② 当test.vue存在expose选项时且为空数组时(即不暴露当前组件任何属性供外部访问)，App.vue输出：</span><br><span class="line">&#x2F;&#x2F;   undefined</span><br><span class="line">&#x2F;&#x2F;   undefined</span><br></pre></td></tr></table></figure>

<p><em>&emsp;&emsp;[注] 默认情况下，通过 $refs、$parent 或 $root 访问到的公共实例与模板使用的组件内部实例是一样的</em></p>
<p><em>&emsp;&emsp;[注] <strong>Vue3中 filters 已经被删除，不再支持过滤器，建议使用计算属性（computed）代替</strong></em></p>
<h3 id="2-DOM选项"><a href="#2-DOM选项" class="headerlink" title="2) DOM选项"></a>2) DOM选项</h3><p>&emsp;&emsp;(1) template(string)<br>&emsp;&emsp;字符串模板，用作组件实例的标记。模板将会<strong>替换</strong>所挂载元素的innerHTML。挂载元素的任何现有标记都将被忽略，除非模板中存在通过插槽（slot）分发的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; test.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Hello Vue3~&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;Test&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong>[补充] template模板语法</strong></p>
<p>&emsp;&emsp;数据绑定：&#123;&#123;&#125;&#125;，&#123;&#123;&#125;&#125;中也可使用表达式</p>
<p>&emsp;&emsp;<strong>指令</strong>：<br>&emsp;&emsp;v-text: 相当于&#123;&#123;&#125;&#125;<br>&emsp;&emsp;v-html: 插入HTML代码，不会作为 Vue 模板进行编译<br>&emsp;&emsp;v-show: 根据表达式的真假值，切换元素的css display 属性值<br>&emsp;&emsp;v-if、v-else-if、v-else： 根据表达式的真假值来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建<br>&emsp;&emsp;v-for：基于源数据多次渲染元素或模板块，一般需要给每个元素一个唯一的key属性提高页面渲染效率（key存在时，Vue 虚拟DOM diffing 算法效率更高）<br>&emsp;&emsp;v-on：缩写@，绑定事件监听器<br>&emsp;&emsp;&emsp;&emsp;修饰符：<br>&emsp;&emsp;&emsp;&emsp;.stop - 调用 event.stopPropagation()。<br>&emsp;&emsp;&emsp;&emsp;.prevent - 调用 event.preventDefault()。<br>&emsp;&emsp;&emsp;&emsp;.capture - 添加事件侦听器时使用 capture 模式。<br>&emsp;&emsp;&emsp;&emsp;.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。<br>&emsp;&emsp;&emsp;&emsp;.{keyAlias} - 仅当事件是从特定键触发时才触发回调。<br>&emsp;&emsp;&emsp;&emsp;.once - 只触发一次回调。<br>&emsp;&emsp;&emsp;&emsp;.left - 只当点击鼠标左键时触发。<br>&emsp;&emsp;&emsp;&emsp;.right - 只当点击鼠标右键时触发。<br>&emsp;&emsp;&emsp;&emsp;.middle - 只当点击鼠标中键时触发。<br>&emsp;&emsp;&emsp;&emsp;.passive - { passive: true } 模式添加侦听器<br>&emsp;&emsp;v-bind：动态地绑定一个或多个 attribute，或一个组件 prop 到表达式<br>&emsp;&emsp;v-model：在表单控件或者组件上创建双向绑定<br>&emsp;&emsp;&emsp;&emsp;修饰符：<br>&emsp;&emsp;&emsp;&emsp;.lazy - 监听 change 而不是 input 事件<br>&emsp;&emsp;&emsp;&emsp;.number - 输入字符串转为有效的数字<br>&emsp;&emsp;&emsp;&emsp;.trim - 输入首尾空格过滤<br>&emsp;&emsp;&emsp;&emsp;v-slot：提供具名插槽或需要接收 prop 的插槽<br>&emsp;&emsp;v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译<br>&emsp;&emsp;v-cloak：可以隐藏未编译的 Mustache 标签直到组件实例准备完毕<br>&emsp;&emsp;v-once：只渲染元素和组件<u>一次</u><br>&emsp;&emsp;v-memo：记住一个模板的子树</p>
<p>&emsp;&emsp;<strong>Vue特殊属性</strong>：<br>&emsp;&emsp;key：用做 Vue 的虚拟 DOM 算法的提示，以在比对新旧节点组时辨识 VNodes<br>&emsp;&emsp;ref：给元素或子组件注册引用信息。引用信息将会被注册在父组件的 $refs 对象上，在普通的 DOM 元素上使用，引用指向的就是那个 DOM 元素；如果用在子组件上，引用就指向组件实例<br>&emsp;&emsp;is：使用动态组件需要用到的一个属性</p>
<p>&emsp;&emsp;<strong>Vue内置组件</strong>：<br>&emsp;&emsp;<u>内置组件可以直接在模板中使用，不需要注册</u><br>&emsp;&emsp;&lt;component&gt;：渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染<br>&emsp;&emsp;&lt;transition&gt;：作为<strong>单个</strong>元素/组件的过渡效果。&lt;transition&gt; 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中<br>&emsp;&emsp;&lt;transition-group&gt;:提供了作为<strong>多个</strong>元素/组件的过渡效果<br>&emsp;&emsp;&lt;keep-alive&gt;：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们.它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中<br>&emsp;&emsp;&lt;slot&gt;：组件模板之中的内容分发插槽<br>&emsp;&emsp;&lt;teleport&gt;：提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML</p>
<p>&emsp;&emsp;(2) render(Function)<br>&emsp;&emsp;字符串模板之外的另一种选择，允许你充分利用 JavaScript 的编程功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; test.vue</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; h &#125; from &#39;vue&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;Test&#39;,</span><br><span class="line">    render() &#123;</span><br><span class="line">      return h(&#39;p&#39;, &#123;&#125;, &#39;Vue3, Hello~&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;(2)中的代码与(1)中的代码效果一样，当 template 与 render 函数同时存在时，<u>render 函数的优先级高于根据 template 选项</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Hello Vue3~&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; h &#125; from &#39;vue&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;Test&#39;,</span><br><span class="line">    render() &#123;</span><br><span class="line">      return h(&#39;p&#39;, &#123;&#125;, &#39;Vue3, Hello~&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码在页面上显示：Vue3, Hello~</p>
<h3 id="3-生命周期钩子-函数"><a href="#3-生命周期钩子-函数" class="headerlink" title="3) 生命周期钩子(函数)"></a>3) 生命周期钩子(函数)</h3><p>&emsp;&emsp;生命周期钩子是一些回调函数，在Vue项目运行对应阶段被执行，在这些生命周期回调函数内编写逻辑来实现在一些相应的功能，生命周期函数被执行时机如下：<br><img src="/images/vue/vue_lifecycle.svg" alt="vue_lifecycle"><br><em>&emsp;&emsp;[注] 所有生命周期钩子的 this 上下文将自动绑定实例，因此可以通过 this 访问 data、computed 和 methods，<strong>不应该</strong>使用箭头函数来定义一个生命周期方法</em></p>
<p>&emsp;&emsp;(1) beforeCreate<br>&emsp;&emsp;在实例初始化之后、进行数据侦听和事件/侦听器的配置之前同步调用  </p>
<p>&emsp;&emsp;(2) created<br>&emsp;&emsp;在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项（数据侦听、计算属性、方法、事件/侦听器的回调函数的绑定）的处理，但实例挂载阶段还没开始。一般在这个生命周期内执行数据请求等逻辑  </p>
<p>&emsp;&emsp;(3) beforeMount<br>&emsp;&emsp;在挂载开始之前被调用，相关的 render 函数首次被调用<br><em>&emsp;&emsp;[注] 该钩子在服务器端渲染期间不被调用</em></p>
<p>&emsp;&emsp;(4) mounted<br>&emsp;&emsp;在实例挂载完成后被调用，mounted 不会保证所有的子组件也都被挂载完成。如果希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 仅在整个视图都被渲染之后才会运行的代码</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 该钩子在服务器端渲染期间不被调用</em></p>
<p>&emsp;&emsp;(5) beforeUpdate<br>&emsp;&emsp;在数据发生改变后，DOM 被更新之前被调用，一般在这个回调里执行移除手动添加的事件监听器等逻辑<br><em>&emsp;&emsp;[注] 该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行</em></p>
<p>&emsp;&emsp;(6) updated<br>&emsp;&emsp;在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用，updated 不会保证所有的子组件也都被重新渲染完毕。如果希望等待整个视图都渲染完毕，可以在 updated 内部使用 vm.$nextTick</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updated() &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 仅在整个视图都被重新渲染完毕之后才会运行的代码</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>&emsp;&emsp;[注] 该钩子在服务器端渲染期间不被调用</em></p>
<p>&emsp;&emsp;(7) beforeUnmount<br>&emsp;&emsp;在卸载组件实例之前调用<br><em>&emsp;&emsp;[注] 该钩子在服务器端渲染期间不被调用</em></p>
<p>&emsp;&emsp;(8) unmounted<br>&emsp;&emsp;卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。一般还在这个回调里清除计算器等逻辑<br><em>&emsp;&emsp;[注] 该钩子在服务器端渲染期间不被调用</em></p>
<p>&emsp;&emsp;其他钩子函数：<br>&emsp;&emsp;activated/deactivated：被 keep-alive 缓存的组件激活/失活时调用 （该钩子在服务器端渲染期间不被调用）<br>&emsp;&emsp;errorCaptured：捕获一个来自后代组件的错误时被调用<br>&emsp;&emsp;renderTracked：跟踪虚拟 DOM 重新渲染时调用，跟踪了组件以及该操作的目标对象和键<br>&emsp;&emsp;renderTriggered：当虚拟 DOM 重新渲染被触发时调用，通过这个钩子能知道操作触发了重新渲染，以及该操作的目标对象和键</p>
<h3 id="4-自定义指令与组件"><a href="#4-自定义指令与组件" class="headerlink" title="4) 自定义指令与组件"></a>4) 自定义指令与组件</h3><p>&emsp;&emsp;(1) directives(Object)<br>&emsp;&emsp;声明一组可用于组件实例中的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input  v-model&#x3D;&quot;phoneNumber&quot; v-status&#x3D;&quot;phoneNumber&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;Test&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        phoneNumber: &#39;&#39;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">      status: &#123;</span><br><span class="line">        updated(el, binding) &#123;</span><br><span class="line">          el.style.color &#x3D; &#39;#ffffff&#39;</span><br><span class="line">          if(&#x2F;^[1][3,4,5,7,8][0-9]&#123;9&#125;$&#x2F;.test(binding.value)) &#123;</span><br><span class="line">            el.style.backgroundColor &#x3D; &#39;rgb(108, 179, 3)&#39;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            el.style.backgroundColor &#x3D; &#39;rgb(231, 85, 85)&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  input &#123;  margin: 0 10px; &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>如上代码，自定义了一个status指令，根据input输入框内的值（电话号码），对input设置不同的数据校验状态，效果如下：<br><img src="/images/vue/v_status.gif" alt="v-status"></p>
<p>&emsp;&emsp;(2) components(Object)<br>&emsp;&emsp;声明一组可用于组件实例中的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; &#123;</span><br><span class="line">  template: &#96;&lt;div&gt;Foo&lt;&#x2F;div&gt;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Foo</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#96;&lt;Foo &#x2F;&gt;&#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上代码声明了一个自定义的&lt;Foo&gt;并在&lt;template&gt;中使用，组件定义相关详情请浏览<a href="">《Vue自定义指令与组件》</a></p>
<h3 id="5-更强大的组合功能"><a href="#5-更强大的组合功能" class="headerlink" title="5) 更强大的组合功能"></a>5) 更强大的组合功能</h3><p>&emsp;&emsp;(1) mixins(Array&lt;Object&gt;)<br>&emsp;&emsp;mixins 选项接收一个 mixin 对象的数组。这些 mixin 对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用特定的选项合并逻辑<br>&emsp;&emsp;每个 mixin 可以拥有自己的 data 函数。每个 data 函数都会被调用，并将返回结果合并。在数据发生冲突时，会以组件自身的数据为优先。同名钩子函数将合并为一个数组，因此都将被调用，并在调用组件自身的钩子之前被调用<br>&emsp;&emsp;值为对象的选项，如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件自身的键值对<br>&emsp;&emsp;避免重复应用 mixin，建议将mixin作为<trong>插件</strong>发布</p>
<p><em>&emsp;&emsp;[注] Vue 3 继续支持 mixin 的同时，组合式 API 是<u>更推荐</u>的在组件之间共享代码的方式。mixin很容易命名冲突，也不能给mixin传递参数来完成更灵活的功能</em></p>
<p>&emsp;&emsp;(2) extends(Object)<br>&emsp;&emsp;允许一个组件扩展到另一个组件，且继承该组件选项，和 mixins 类似，任何选项都会通过对应的合并策略被合并</p>
<p>&emsp;&emsp;(3) provide/inject<br>&emsp;&emsp;这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效<br><em>&emsp;&emsp;[]注 默认情况下，provide/inject 绑定并不是响应式的。我们可以通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为</em>  </p>
<p>&emsp;&emsp;(4) setup</p>
<p>&emsp;&emsp;-待完善-</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>面试备注 (2021.09)</title>
    <url>/2021/09/28/note/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%B3%A8%20(2021.09)/</url>
    <content><![CDATA[<h4 id="1、ES常见数据类型："><a href="#1、ES常见数据类型：" class="headerlink" title="1、ES常见数据类型："></a>1、ES常见数据类型：</h4><p>&emsp;&emsp;基本类型：Number、String、Boolean、undefined、null<br>&emsp;&emsp;引用类型：Object</p>
<p><em>&emsp;&emsp;[注] 判断变量数据类型：typeof、instanceof、constructor、Object.prototype.toString.call()</em></p>
<h4 id="2、使用数据构造函数与new-数据类型构造的区别"><a href="#2、使用数据构造函数与new-数据类型构造的区别" class="headerlink" title="2、使用数据构造函数与new 数据类型构造的区别"></a>2、使用数据构造函数与new 数据类型构造的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(1) &#x3D;&#x3D;&#x3D; new Number(1) &#x2F;&#x2F; false</span><br><span class="line">typeof Number(1) &#x2F;&#x2F; number</span><br><span class="line">typeof new Number(1) &#x2F;&#x2F; object</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如上代码，像普通函数一样直接调用构造函数，会执行相应的<u>类型转换</u>返回原始数据类型。new关键字调用构造函数，返回实例化新创建的对象</p>
<h4 id="3、JS预编译过程"><a href="#3、JS预编译过程" class="headerlink" title="3、JS预编译过程"></a>3、JS预编译过程</h4><p>&emsp;&emsp;全局预编译：<br>&emsp;&emsp;① 创建GO对象<br>&emsp;&emsp;② 找变量申明，将变量名作为GO对象的属性名，赋值undefined<br>&emsp;&emsp;③ 在函数体里面找函数申明，将函数名作为GO对象的属性名，赋值对应函数体</p>
<p>&emsp;&emsp;函数预编译：<br>&emsp;&emsp;① 创建AO对象<br>&emsp;&emsp;② 找变量申明与函数形参，将变量与函数形参名作为AO对象的属性名，赋值undefined<br>&emsp;&emsp;③ 将函数实参与形参统一<br>&emsp;&emsp;③ 在函数体里面找函数申明，将函数名作为GO对象的属性名，赋值对应函数体</p>
<p><em>&emsp;&emsp;[注] 函数预编译发生在代码运行前的瞬间，具体过程见文章：<a href="/2020/12/05/javascript/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/#2%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">《JS预解析、作用域、执行上下文、this》</a></em></p>
<h4 id="4、CSS选择器优先级顺序"><a href="#4、CSS选择器优先级顺序" class="headerlink" title="4、CSS选择器优先级顺序"></a>4、CSS选择器优先级顺序</h4><p>&emsp;&emsp;!important &gt; 行内样式 &gt; id选择器 &gt; class选择器 &gt; 标签(伪元素)选择器 &gt; *(通配符) &gt; 继承样式 &gt; 默认样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">   div &#123; width: 100px; height: 100px &#125;</span><br><span class="line">   .parnel &#123; background-color: black; &#125;</span><br><span class="line">   .container .parnel &#123; background-color: blue; &#125;</span><br><span class="line">   #frist-box &#123; background-color: green; &#125;</span><br><span class="line">   .container #ce-box &#123; background-color: red; &#125;</span><br><span class="line">   .container div#ce-box &#123; background-color: yellow; &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;parnel&quot; id&#x3D;&quot;frist-box&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F; green (绿色)</span><br><span class="line">      &lt;div class&#x3D;&quot;parnel&quot; id&#x3D;&quot;ce-box&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F; yellow (黄色)</span><br><span class="line">      &lt;div class&#x3D;&quot;parnel&quot; style&#x3D;&quot;background: blue;&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F; blue (蓝色)</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5、JS事件捕获和事件冒泡的执行顺序"><a href="#5、JS事件捕获和事件冒泡的执行顺序" class="headerlink" title="5、JS事件捕获和事件冒泡的执行顺序"></a>5、JS事件捕获和事件冒泡的执行顺序</h4><p>&emsp;&emsp;JS事件处理机制是：先捕获，后冒泡。捕获从上到下，冒泡从下到上。(比喻：捕获像石头沉海底，冒泡则像触底的石头产生的气泡冒出水面)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div id&#x3D;&quot;box1&quot;&gt;</span><br><span class="line">      &lt;div id&#x3D;&quot;box2&quot; style&#x3D;&quot;width: 100%; height: 100%;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      const box1 &#x3D; document.getElementById(&#39;box1&#39;)</span><br><span class="line">      const box2 &#x3D; document.getElementById(&#39;box2&#39;)</span><br><span class="line">      document.body.addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">         console.log(1)</span><br><span class="line">      &#125;, true)</span><br><span class="line">      box1.onclick &#x3D; function () &#123;</span><br><span class="line">         console.log(2)</span><br><span class="line">      &#125;</span><br><span class="line">      box1.addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">         console.log(3)</span><br><span class="line">      &#125;, true)</span><br><span class="line">      box2.onclick &#x3D; function (e) &#123;</span><br><span class="line">         console.log(4)</span><br><span class="line">      &#125;</span><br><span class="line">      box2.addEventListener(&#39;click&#39;, function(e) &#123;</span><br><span class="line">         &#x2F;&#x2F; e.stopPropagation()</span><br><span class="line">         console.log(5)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 依次输出：1、3、4、5、2</span><br><span class="line">      &#x2F;&#x2F; 若在box2的onclick或addEventListener事件回调里事件阻止冒泡，则依次输出：1、3、4、5</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><em>&emsp;&emsp;[注] element.addEventListener(event, function, useCapture)中的useCapture为可选参数.true，表示回调函数在事件捕获阶段执行；false，默认值，表示回调函数在冒泡阶段执行</em></p>
<h4 id="6、JS创建、删除、替换、插入节点"><a href="#6、JS创建、删除、替换、插入节点" class="headerlink" title="6、JS创建、删除、替换、插入节点"></a>6、JS创建、删除、替换、插入节点</h4><p>&emsp;&emsp;doument全局HTML文档对象对应方法分别为：createElement、removeChild、replaceChild、appendChild/insertBefore</p>
<h4 id="7、网站性能优化"><a href="#7、网站性能优化" class="headerlink" title="7、网站性能优化"></a>7、网站性能优化</h4><p>&emsp;&emsp;① CDN<br>&emsp;&emsp;② 减少HTTP请求<br>&emsp;&emsp;③ 减少DOM请求<br>&emsp;&emsp;④ gzip (压缩网站静态资源)<br>&emsp;&emsp;⑤ 代码压缩<br>&emsp;&emsp;⑥ 代码级优化 (减少cookie传输、分批延迟进行HTTP请求、异步执行内嵌脚本)</p>
<h4 id="8、跨域"><a href="#8、跨域" class="headerlink" title="8、跨域"></a>8、跨域</h4><p>&emsp;&emsp;浏览器同源策略规定的一种安全机制<br><em>&emsp;&emsp;[注] 当一个 url 的协议、域名与端口号三者任意一个与当前页面的 url 不同则为跨域</em></p>
<p>&emsp;&emsp;非同源限制：<br>&emsp;&emsp;① 无法读取其cookie、localStorage、indexedDB等数据<br>&emsp;&emsp;② 无法获取其DOM<br>&emsp;&emsp;③ 无法向非同源地址发送Ajax请求</p>
<p>&emsp;&emsp;<strong>跨域是在浏览器环境限制了Ajax请求响应，浏览器对HTTP请求无限制，如浏览器地址栏访问URL、通过form表单发起的请求都是HTTP请求，无跨域问题 。代理服务器与服务器之间是HTTP请求，无跨域问题。 <u>跨域时Ajax请求已被服务器接收并处理，只是服务器响应被浏览器拦截了</u></strong></p>
<p>&emsp;&emsp;解决方法：<br>&emsp;&emsp;jsonp、CORS跨域资源共享、代理、Nodejs中间层…</p>
<p>&emsp;&emsp;① jsonp严格来说并没有解决跨域，而是通过&lt;script&gt;来发送一个HTTP请求绕过了同源策略的限制。将&lt;script&gt;标签的src属性设置为请求地址，地址里包含当前请求在本地的回调函数名称，假设名称为showHandle。服务器处理完请求返回函数调用的形式，将处理结果data当做入返回，如showHandle(data)。此时&lt;script&gt;的src的结果为showHandle(data)，由于&lt;script&gt;会加载并执行脚本，所以本地的showHandle(data)函数被执行，入参即为接口返回的数据</p>
<p><em>&emsp;&emsp; [注] 只能通过&lt;script&gt;发送GET请求、而且需要前端与后端项目共同做出相应配置。除&lt;script&gt;标签外，还有&lt;img&gt;、&lt;video&gt;等标签加载资源时发送的也是HTTP请求，没有跨域的问题</em></p>
<p>&emsp;&emsp;② CORS跨域资源共享<br>服务端设置Access-Control-Allow-Origin来开启CORS。通过该属性设置哪些域名可以跨域访问资源</p>
<p><em>&emsp;&emsp; [注] 需要后端项目做出相应配置（也需要浏览器支持，对于服务端允许访问的跨域请求，在响应时不会被浏览器拦截），无需前端项目作出任何更改。这种方式前端请求有简单请求和复杂请求的分别，复杂请求在正式通信之前，增加一次HTTP查询请求（预检请求，OPTION方法）来确认服务端是否允许跨域请求</em></p>
<p>&emsp;&emsp;③ 代理<br>&emsp;&emsp;一般情况下，客户端（浏览器）可以直接与服务器进行交互。但有时由于浏览器的同源策略限制（发生跨域问题）、浏览器与服务器间存在防火墙等以及为了提高服务器性能（实现负载均衡或者缓存静态内容等功能），我们会使用代理服务器<br>&emsp;&emsp;代理按类型分为正向代理（解决跨域、防火墙问题、服务器对访问来源做了限制）与反向代理（提高服务器性能）。其中正向代理是使用服务器来代理客户端与真实的服务器进行交互；反向代理是使用服务器来代理真实的服务器与客户端进行交互</p>
<p><img src="/images/note/proxy.jpg" alt="proxy"></p>
<p>&emsp;&emsp;在解决跨域问题上，我们一般采用本地服务器来代理前端来与服务器进行交互（还可以使用其他代理工具进行反向代理，来实现跨域请求）<br>&emsp;&emsp;如在React/Vue框架中webpack里面都使用了 http-proxy-middleware 这个库，在项目里创建一个本地Nodejs服务器（本地服务器可以通过webpack对应配置文件proxy属性进行定义），前端与这个本地服务器是同源的，所以不存在跨域。本地服务器与后台服务器通过HTTP协议进行交互，他们之间也没有跨域问题</p>
<p><img src="/images/note/local_proxy.jpg" alt="local_proxy"></p>
<p><em>&emsp;&emsp; [注] 前端与后端项目均无需更改，但需要在前端添加 http-proxy-middleware 库对应的代理（proxy）配置</em></p>
<p>&emsp;&emsp;④ Nodejs中间层<br>&emsp;&emsp;搭建线上Nodejs项目来转发与响应前端请求。同时在项目中实现负载均衡或者缓存静态内容等更高级的功能将Nodejs中间层打造成一个强大的中台系统</p>
<p><img src="/images/note/node_proxy.jpg" alt="node_proxy"></p>
<p><em>&emsp;&emsp; [注] 前端与后端项目均无需更改，但需要额外搭建Nodejs中间层项目，并配置CORS跨域策略，转发前端请求，并将服务器响应结果返回给前端项目</em></p>
<h4 id="9、this"><a href="#9、this" class="headerlink" title="9、this"></a>9、this</h4><p>&emsp;&emsp;① 在全局上下文中，无论是否在严格模式下，this指向window或者调用对象<br>&emsp;&emsp;② 在函数上下文中，this指向取决于函数调用方式。在非严格模式下，this指向window；<u>在严格模式下，this指向调用对象，若无调用对象，即直接调用函数，this为undefined</u><br>&emsp;&emsp;③ 在类中，基类与派生类表现形式不同。在基类中，this是一个常规对象，所有非静态方法都会添加到this的原型上。在派生类中，构造函数constructor没有初始化this绑定，需要在构造函数中调用super()函数才能生成一个this，否则为undefined</p>
<p><em>&emsp;&emsp;[注] 在Class类中，直接使用 super 对象调用父级方法时，super 会绑定当前子类的 this</em></p>
<h4 id="10、异步任务的优先级"><a href="#10、异步任务的优先级" class="headerlink" title="10、异步任务的优先级"></a>10、异步任务的优先级</h4><p>&emsp;&emsp;process.nextTick(Nodejs) &gt; Promise(微任务) &gt; setImmediate(Nodejs) &gt; setTimeout/setInterval</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">var p1 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">   console.log(2)</span><br><span class="line">   resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(function()&#123;</span><br><span class="line">   console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(4)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(5)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(6)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;依次输出：1、2、6、3、4、5</span><br></pre></td></tr></table></figure>

<p><em>&emsp;&emsp;[注] 异步线程与主线程通信依赖于事件循环 (Event Loop) 机制</em></p>
<h4 id="11、深浅拷贝"><a href="#11、深浅拷贝" class="headerlink" title="11、深浅拷贝"></a>11、深浅拷贝</h4><p>深浅拷贝主要是针对Object和Array这样的引用数据类型来说的。浅拷贝只复制指向某个对象的指针(不复制对象本身，仅仅复制了对象被存储的内存地址)，新旧对象数据还是共享同一块内存空间，状态会相互影响；深拷贝会复制对象数据本身，再存储到新的内存地址空间中，新旧对象被存储的内存地址不同，状态也不会相互影响</p>
<p>&emsp;&emsp;一道笔试题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user &#x3D; &#123;age: 30&#125;</span><br><span class="line">function change(user) &#123;</span><br><span class="line">   &#x2F;&#x2F; user.age &#x3D; 40 &#x2F;&#x2F;(1) &#123;age: 40&#125;</span><br><span class="line">   user &#x3D; &#123;age: 50&#125; &#x2F;&#x2F;(2) &#123;age: 30&#125;</span><br><span class="line">&#125;</span><br><span class="line">change(user)</span><br><span class="line">console.log(user)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;函数中对象类型的参数在传递时使用浅拷贝。这里形参user与实参user都指向前面let定义的{age: 30}对象。在函数内部，第(1)种情况使用形参user指针访问到存储空间的{age: 30}对象，并将修改age的值为40，由于形参user与实参user指向同一内存地址，状态会同步变化，所以输出{user: 40}。第二种情况，直接将形参user指向一个新对象{user: 50}对象。这并不会影响实参user的指向，所以输出先前定义的{age: 30}对象</p>
<h4 id="12、Ajax-axios-fetch之间的区别"><a href="#12、Ajax-axios-fetch之间的区别" class="headerlink" title="12、Ajax,axios,fetch之间的区别"></a>12、Ajax,axios,fetch之间的区别</h4><p>&emsp;&emsp;三者都是与服务器交换数据的技术，也有一定的区别：<br>&emsp;&emsp;(1) 在原生JS中，Ajax是基于XMLHttpRequest对象，实现了网页的局部刷新数据的技术<br>&emsp;&emsp;(2) axios利用Promise对原生Ajax进行封装，支持 Promise API，可以链式调用从而避免了原生Ajax回调地狱的问题，还封装了并发请求等功能<br>&emsp;&emsp;(3) fecth是在ES6中，Ajax的替代品，是原生JS技术，请求实现时不基于XMLHttpRequest对象。fetch请求返回了一个HTTP响应，还需要调用json()方法来获取服务端返回的JSON数据</p>
<h4 id="13、webpack的打包原理"><a href="#13、webpack的打包原理" class="headerlink" title="13、webpack的打包原理"></a>13、webpack的打包原理</h4><p>&emsp;&emsp;webpack是一个现代JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块要经过Loader，Plugin一系列翻译处理流程后，打包成一个或多个bundle文件。</p>
<p>&emsp;&emsp;webpack打包区器有Entry、Output、Module、Chunk、Loader以及Plugin等核心概念，但最新的前端框架(React、Vue等)初始化项目时,都主动隐藏了webpack的相关配置文件。以此减少开发者的开发工作，使开发者只需关注对应项目核心逻辑</p>
<p><em>&emsp;&emsp; [注] webpack官方文档地址：<a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a></em></p>
<h4 id="14、Vue-history模式发布注意什么？与hash模式的区别？"><a href="#14、Vue-history模式发布注意什么？与hash模式的区别？" class="headerlink" title="14、Vue history模式发布注意什么？与hash模式的区别？"></a>14、Vue history模式发布注意什么？与hash模式的区别？</h4><p>&emsp;&emsp;history与hash模式可以在不刷新页面的前提下，改变了页面的URL，从而Vue等框架监听到页面URL变化，通过一定规则，来实现页面中部分组件的移除或更新，从而达到局部更新页面的状态的目的</p>
<p>&emsp;&emsp;history与hash模式的区别：</p>
<p>&emsp;&emsp;(1) history模式是基于HTML5中新增的pushState()和replaceState()方法来完成改变URL<br>&emsp;&emsp;&emsp;&emsp;① URL(包含匹配路由的相关信息)与服务器请求时可能造成一些请求出现404的问题<br>&emsp;&emsp;&emsp;&emsp;② 可能需要服务器重定向逻辑的支持，否则某些二级路由页面可以出现样式丢失等问题</p>
<p>&emsp;&emsp;(2) hash模式路径中带有’#’(锚点)符号<br>&emsp;&emsp;&emsp;&emsp;① 影响美观<br>&emsp;&emsp;&emsp;&emsp;② 不符合规范，一些第三方分享链接可能不支持URL中带有’#’号<br>&emsp;&emsp;&emsp;&emsp;③ 原有的锚点功能会失效<br>&emsp;&emsp;&emsp;&emsp;④ 传参基于URL，浏览器对长度有限制</p>
<p>&emsp;&emsp;所以，Vue history模式发布发布时，要确认在静态文件夹public目录下的index.html模板文件等文件中有没有采用<u>相对路径</u>引入样式、字体，JS脚本文件等，<strong>[ 需修改为绝对路径 ]</strong>。否则可能导致浏览器在某些二级路由页面刷新时，公用组件的组件的样式，JS脚本等文件加载失败(服务器返回404)，从而导致组件样式与功能出现问题</p>
<h3 id="15、MVVM模式-Vue如何实现数据动态响应"><a href="#15、MVVM模式-Vue如何实现数据动态响应" class="headerlink" title="15、MVVM模式 Vue如何实现数据动态响应"></a>15、MVVM模式 Vue如何实现数据动态响应</h3><p>&emsp;&emsp;MVVM（Model View ViewModel）是MVC的升级版，采用ViewModel层将视图（View）与数据模型（Model）进行解耦。将视图DOM封装，利用观察者模式（发布订阅）实现视图与数据模型的动态响应与同步更新</p>
<p><img src="/images/note/mvvm.webp" alt="avatar"></p>
<p>&emsp;&emsp;(1) 数据模型层数据同步更新到视图<br>&emsp;&emsp;① 实现数据劫持，Vue2.x中采用Object.defineProperty()实现；Vue3.x中采用新的API Proxy()来实现检测数据变化<br>&emsp;&emsp;② 实现发布订阅者模式，视图层订阅数据模型层数据更新的消息。当数据模型层数据更新时，会将更新函数发布到对应的全部的订阅者<br>&emsp;&emsp;③ 结合数据劫持和发布订阅模式，解析 HTML 结构中绑定的变量（订阅者），当数据模型中对应数据更新后，对应变量会通过数据模型层发布的更新函数进行更新，从而达到更新视图层的目的</p>
<p>&emsp;&emsp;(2) 视图层输入（数据模型层某些数据的数据源）更新到数据模型层<br>&emsp;&emsp;视图层通过事件绑定监听数据变化，从而在对应的事件回调函数里更新数据模型层的数据</p>
<h3 id="16、函数柯里化"><a href="#16、函数柯里化" class="headerlink" title="16、函数柯里化"></a>16、函数柯里化</h3><p>&emsp;&emsp;函数柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">  return a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3) &#x2F;&#x2F; 6</span><br><span class="line"></span><br><span class="line">function add(a) &#123;</span><br><span class="line">  return function (b) &#123;</span><br><span class="line">    return function (c) &#123;</span><br><span class="line">      return a + b + c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(1)(2)(3) &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<p><em>&emsp;&emsp;[注] 函数作为参数或者返回值是函数的函数成为<u>高阶函数</u></em></p>
<p>&emsp;&emsp;一个通用的柯里化方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">   return fn.length &gt; args.length ? (...args2) &#x3D;&gt; curry(fn, ...args, ...args2) : fn(...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(a, b, c, d) &#123;</span><br><span class="line">  console.log(a + b + c + d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn &#x3D; curry(fn)</span><br><span class="line">fn(1)(2)(3, 4)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;函数柯里化与柯里化函数执行过程如下：</p>
<p><img src="/images/note/curry_1.png" alt="curry_1"><br><img src="/images/note/curry_2.png" alt="curry_2"><br><img src="/images/note/curry_3.png" alt="curry_3"></p>
<p>&emsp;&emsp;函数柯里化的特点：<br>&emsp;&emsp;提高了代码的通用性，可实现函数延迟到最后一起执行来完成特定场景的功能，编码灵活执行效率高，但编码逻辑比较复杂，不利于代码维护。</p>
<h3 id="17、WEB安全问题"><a href="#17、WEB安全问题" class="headerlink" title="17、WEB安全问题"></a>17、WEB安全问题</h3><p>&emsp;&emsp;一般来说，WEB安全问题大部分还是更依赖于后端的过滤和拦截措施，毕竟服务器直接在操作数据库，服务器在接收到前端脚本和不加以限制的执行。或是服务器500时，直接返回服务器错误（如数据库对应错误），会暴露数据库信息导致很多潜在的安全问题。不管怎样，网络也没有绝对的安全~</p>
<p>&emsp;&emsp;WEB基本攻击大致可以分为：</p>
<p>&emsp;&emsp;(1) 资源枚举获取站点代码文件<br>&emsp;&emsp;别有用心的人或网络爬虫会遍历你站点所有可访问的目录，通过分析文件或文件夹命名，将类似项目或重要的文件（如网站备份文件等）进行下载；或者直接全部下载。也可以通过一定的线索获取到数据库的数据，比如服务器不够健壮，页面url被随意篡改后返回了数据库错误信息，也存在一定安全隐患</p>
<p>&emsp;&emsp;(2) 通过参数操纵获取数据库信息<br>&emsp;&emsp;主要包括了SQL注入(以及XPath注入)、XSS和会话劫持等</p>
<p>&emsp;&emsp;① SQL注入很好理解，前端将含有SQL操作语句的信息给后端，后端没做过滤直接执行暴露了数据库信息，前端提交方式可以是表单输入以Ajax的方式被提交，或是直接更改一些带参的url导致SQL语句被提交的数据库<br>如一个url的地址site.com/list?id=1被改成site.com/list?id=1’ or ‘1’=’1，可能执行select * from table where id=’1’ or ‘1’=’1’，将会导致数据库table表的所有信息被返回。还有更高级的SQL注入，不局限与某个数据表，可直接获取数据库更多信息。XPath注入与SQL注入思路是相同的，只是采用xml的格式获取数据</p>
<p>&emsp;&emsp;② XSS（cross-site scripting跨域脚本攻击），有两个特点；跨域，客户端执行<br>&emsp;&emsp;Reflected XSS（基于反射的XSS攻击），如利用&lt;script&gt;发送一些恶意代码给服务器，服务器返回相关信息（如用户cookie，token等信息），在客户端对这些信息进行收集<br>&emsp;&emsp;Stored XSS（基于存储的XSS攻击），将恶意代码存储在可访问文件内，文件在部署到服务器，访问这个文件的用户可能会被恶意收集一些信息<br>&emsp;&emsp;DOM-based or local XSS（基于DOM或本地的XSS攻击），通过&lt;script&gt;（植入脚本）在页面插入相关DOM节点，用户点击可以触发一些恶意事件处理函数，不需要经过服务器就能获取用户本地数据</p>
<p>&emsp;&emsp;③ 利用HTTP协议的不安全特点，别有用心的人或网络爬虫会通过分析报文信息，将合法的访问者断开，伪装成合法用户让继续与服务器交换数据</p>
<p>&emsp;&emsp;(3) CSRF攻击、钓鱼攻击和拒绝服务攻击<br>&emsp;&emsp;CSRF攻击与XSS非常相似，但XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击，利用img、script、iframe无跨域问题，如在页面或邮件放置这些标签，进行一些恶意访问操作。如在邮件中插入&lt;img src=’xxx.com/xxx’/&gt;发送然后发送给用户，用户只要打开邮件，img立即就会请求xxx.com/xxx带上用户cookie完成一些恶意操作<br>&emsp;&emsp;钓鱼攻击就是伪造站点恶意收集用户信息<br>&emsp;&emsp;拒绝服务就是采用脚本疯狂向服务器发送请求，导致服务器超负荷并关闭</p>
<p>&emsp;&emsp;<strong>安全问题解决方式：</strong><br>&emsp;&emsp;不要将重要备份文件放在公网上<br>&emsp;&emsp;服务器不要相信前端传递的任何信息，对用户输入也要谨慎返回<br>&emsp;&emsp;不要随意使用免费的WiFi网络<br>&emsp;&emsp;网站使用HTTPS协议<br>&emsp;&emsp;服务器要限制用户频繁请求，或采用一定的技术来解决网络延迟和阻塞问题</p>
<h3 id="18、HTTP缓存策略"><a href="#18、HTTP缓存策略" class="headerlink" title="18、HTTP缓存策略"></a>18、HTTP缓存策略</h3><p>&emsp;&emsp;为了减少请求时冗余的数据传输，缓解了服务器的压力从而提高服务器的响应速度。我们一般会有意识使用HTTP缓存。一般说的HTTP缓存都是指缓存GET请求响应的资源。HTTP缓存可分为：强制缓存、协商缓存</p>
<p>&emsp;&emsp;(1) 强缓存，服务器在第一次处理请求返回时，在Response Header设置Pragma、Cache-Control、Expires（优先级依次变低）响应的配置信息（如Cache-Control：max-age=30表示缓存30s）。第二次请求时，Request Header里会带上Pragma、Cache-Control、Expires等信息。浏览器判断这些请求参数，如果Cache-Control：max-age或者Expires未过期，会直接使用浏览器的缓存数据，不再向服务器发送当前请求。强制缓性能很高，生效时HTTP状态码为200。<u>但是在缓存配置失效前，浏览器无法获取到服务器更新后的资源</u>。</p>
<p>&emsp;&emsp;(2) 协商缓存：服务器在第一次处理请求返回时，在Response Header中没有设置没有Pragma、Cache-Control、Expires或者将其对应属性设置为no-cache时(即不使用强缓存)。第二次请求时会与服务器进行协商，服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态（减少服务器传输压力）告诉浏览器可以使用缓存中的数据。如果数据有更新就会返回200状态码、最新资源、缓存信息（Etag、Last-Modified等信息）</p>
<p><em>&emsp;&emsp;[注] 强缓存机制存在获取不到服务器最新资源的问题；协商缓存每次要与服务器进行交互，性能不高</u></em></p>
<h3 id="19、Vue虚拟DOM-Diff算法"><a href="#19、Vue虚拟DOM-Diff算法" class="headerlink" title="19、Vue虚拟DOM Diff算法"></a>19、Vue虚拟DOM Diff算法</h3><p>&emsp;&emsp;在Vue与React等框架中，为了避免页面更新时频繁的进行页面重绘等操作，减少浏览器性能消耗，使用JS对象来描述页面真实的DOM。在页面数据更新时，会将更新后的虚拟DOM结构与之前的虚拟DOM结构采用Diff算法进行对比，最后将对比出来的差异的部分进行重新的真实DOM的渲染</p>
<p><img src="/images/note/vNode.png" alt="vNode"></p>
<p>&emsp;&emsp;在页面数据发生变化时，根据Vue相关响应式原理，会生成新的虚拟DOM结构，进行Diff算法（React Diff算法与Vue一致）来计算页面最小更新。匹配的最小单位是标签，只进行只进行同层级比较，忽略跨级操作。如上图中的&lt;ul&gt;结构不会与&lt;li&gt;结构进行比较。若&lt;ul&gt;结构一致，还有子元素时，会对里面的&lt;li&gt;进行一一比较，若&lt;ul&gt;已经不同，直接回新的&lt;ul&gt;更新页面上对应的真实DOM</p>
<p>&emsp;&emsp;为了提高效率，框架一般要求在循环出来的最外层元素添加唯一的key标识，便于Diff算法比较时具有更高效率</p>
<p><em>&emsp;&emsp;[注] 一般不使用 index 作为 key 的值，因为在对数据进行逆序添加、逆序删除等破坏顺序操作时：①会造成没必要的真实DOM的更新 ② DOM 结构中包含输入类元素，会导致元素绑定的值出现错误，因为Diff 算法无法知道输出类元素绑定的值是什么。如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的</em></p>
<h3 id="20、数据去重与排序"><a href="#20、数据去重与排序" class="headerlink" title="20、数据去重与排序"></a>20、数据去重与排序</h3><p>&emsp;&emsp;(1) 数据去重<br>&emsp;&emsp;数据去重相对来说较简单，这里直接提供几种实现方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; indexOf去重</span><br><span class="line">function unique (arr) &#123;</span><br><span class="line">   const list &#x3D; []</span><br><span class="line">   for (let i &#x3D; 0, cnt &#x3D; arr.length; i &lt; cnt; i++) &#123;</span><br><span class="line">      if (list.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">         list.push(arr[i])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、filter + indexOf去重</span><br><span class="line">function unique (arr) &#123;</span><br><span class="line">   return arr.filter((item, index) &#x3D;&gt; arr.indexOf(item) &#x3D;&#x3D;&#x3D; index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;(2) 排序<br>&emsp;&emsp;排序思想有很多，这里简单分享几种常用的：冒泡排序、选择排序、快速排序<br>&emsp;&emsp;① 冒泡排序<br>&emsp;&emsp;思路：冒泡排序就是依次比较两个相邻元素，若结果与要求的排列顺序不一致，交互两个元素的位置。这样每次能将最大或最小元素移动到当前排序区间的末尾。若有n个元数需要排序，重复上面的步骤n-1次，每次将当前排序区间最大或最小元素移动到当前区间末尾后，得到的序列就是有序的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sort(arr) &#123;</span><br><span class="line">   for (let i &#x3D; 0, len &#x3D; arr.length; i &lt; len - 1; i++) &#123;</span><br><span class="line">      for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">         if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">            [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;冒泡排序时间复杂度O(n<sup>2</sup>)，一般来说是稳定的<br><em>&emsp;&emsp;[注] <u>对于排序算法是否稳定的定义：当存在多个相同元素时，排序结果不影响这些相同元素的初始时的相对顺序，我们称该排序算法是稳定的，否则是不稳定的。</u>这里若将 if 的判断条件 arr[j] &gt; arr[j + 1] 改为 arr[j] &gt;= arr[j + 1] 时，会交换相邻的两个相同元素，这时的冒泡排序算法是<strong>不稳定的</strong></em></p>
<p>&emsp;&emsp;② 选择排序<br>&emsp;&emsp;思路：选择排序先选择当前排序区间第一个元素为基数，依次与其余元素进行比较，每次选择出最大或最小元素放置在区间末尾。若有n个元数需要排序，重复上面的步骤n-1次，每次选择出当前排序区间最大或最小元素放置到当前区间末尾后，得到的序列就是有序的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sort(arr) &#123;</span><br><span class="line">   let inx</span><br><span class="line">   for (let i &#x3D; 0, len &#x3D; arr.length; i &lt; len - 1; i++) &#123;</span><br><span class="line">      inx &#x3D; i</span><br><span class="line">      for (let j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">         if (arr[inx] &gt; arr[j]) &#123;</span><br><span class="line">         inx &#x3D; j</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      [arr[inx], arr[i]] &#x3D; [arr[i], arr[inx]]</span><br><span class="line">   &#125;</span><br><span class="line">   return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;选择排序时间复杂度O(n<sup>2</sup>)，不稳定</p>
<p>&emsp;&emsp;③ 快速排序<br>&emsp;&emsp;思路：在当前排序区间中选择一个任意元素为分界值，通过该分界值，将当前区间内的其他值按大小放在该值左右两边。依次对左右两边的区间递归进行上面的排序步骤，直到当前排序区间长度为1时进行回溯。回溯完成得到的序列就是有序的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">   if (left &gt;&#x3D; right) return</span><br><span class="line">   let i &#x3D; left, j &#x3D; right, base &#x3D; arr[i]</span><br><span class="line">   while (i &lt; j) &#123;</span><br><span class="line">      while (i &lt; j &amp;&amp; arr[j] &gt; base) &#123;</span><br><span class="line">         j--</span><br><span class="line">      &#125;</span><br><span class="line">      while (i &lt; j &amp;&amp; a[i] &lt;&#x3D; base) &#123;</span><br><span class="line">         i++</span><br><span class="line">      &#125;</span><br><span class="line">      if (i &lt; j) &#123;</span><br><span class="line">         [a[i], a[j]] &#x3D; [a[j], a[i]]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   arr[left] &#x3D; arr[i]</span><br><span class="line">   a[i] &#x3D; base</span><br><span class="line">   quickSort(arr, left, i - 1)</span><br><span class="line">   quickSort(arr, i + 1, right)</span><br><span class="line">   return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;快速排序时间复杂度一般来说是O(nlogn)，不稳定</p>
]]></content>
      <categories>
        <category>面试备注</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步操作以及流程控制（串行、并行）</title>
    <url>/2020/12/25/javascript/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/</url>
    <content><![CDATA[<p>Javascript语言的执行环境是”单线程”（single thread），单个脚本只能在一个线程上运行（主线程）。原因在于浏览器内核中JavaScript引擎中负责解释和执行JavaScript代码的主线程是唯一的，同一时间只能执行一件任务。在浏览器内核中，GUI 渲染线程与 JavaScript 引擎线程是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。所以如果JavaScript执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步。”同步模式”指一个任务等待前一个任务执行结束再执行，程序的执行顺序与任务的排列顺序（即与程序的编码顺序）是一致的、同步的；”异步模式”是每一个任务有一个或多个回调函数，一个任务不用等待前一个任务执行完成就便开始执行，当前任务执行完成后，不是立即执行后一个任务，而是查询回调函数队列里，是否有前面的已任务的回调函数，会立即执行回调函数，回调函数执行完后再执行后一个任务。程序的执行顺序与任务的排列顺序是不一致的，同步的；而是异步的。（<u>此外，JS运行时还有宏任务、微任务、事件循环的概念。</u>）</p>
<h2 id="说在前面-进程（Process）与线程（Thread）"><a href="#说在前面-进程（Process）与线程（Thread）" class="headerlink" title="说在前面 - 进程（Process）与线程（Thread）"></a>说在前面 - 进程（Process）与线程（Thread）</h2><p>&emsp;&emsp;目前的操作系统都是多任务系统，操作系统接管了所有硬件资源并持有对硬件控制的最高权限。在操作系统中执行的程序，都以进程的方式运行在更低的权限中。所有的硬件资源，由操作系统根据进程的优先级以及进程的运行状况进行统一的调配，<u>即操作系统是以进程为单位去分配空间和执行的。</u></p>
<p><em>&emsp;&emsp;[注] 区分程序与进程：程序是一组指令集合，它本身没有任何运行的含义，它只是一个静态的实体，存储于磁盘之内的存储器中；当一个程序被操作系统执行时，会被载入内存并在逻辑上产生一个独立的实例，这就是进程。进程和程序并不是一 一对应的；一个程序有可能没有与之对应的进程(因为它并未执行)，也有可能有多个进程与之对应(程序运行在几个不同的数据集上)。<u>一个程序在运行时，至少有一个进程,一个进程至少有一个线程。</u></em></p>
<p>&emsp;&emsp;线程是操作系统进行任务调度的最小单元。<strong>线程存活于进程之中；同一个进程中的线程，共享一个虚拟内存空间以及其中的资源；</strong>线程之间各自持有自己的线程 ID、当前指令的指针（PC）、寄存器集合以及栈。</p>
<p>&emsp;&emsp;<strong>就浏览器来说，浏览器在运行时是多进程的：</strong><br>&emsp;&emsp;Browser进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等<br>&emsp;&emsp;PU 进程：用于3D 绘制等<br>&emsp;&emsp;第三方插件进程：每种类型的插件对应一个进程，仅当使用该浏览器插件时才创建<br>&emsp;&emsp;浏览器渲染进程（浏览器内核）：每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</p>
<p>&emsp;&emsp;<strong>每个渲染进程（浏览器内核）又分为多个线程：</strong><br>&emsp;&emsp;GUI渲染线程：负责渲染浏览器界面，当界面需要重绘或由于某种操作引发回流时，该线程就会执行<br>&emsp;&emsp;JavaScript引擎线程：也称为JavaScript内核，负责处理Javascript脚本程序、解析与运行Javascript代码等，例如 V8 引擎<br>&emsp;&emsp;事件触发线程：用来控制浏览器的事件循环，当事件被触发时，该线程才会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理<br>&emsp;&emsp;定时触发器线程：setInterval与setTimeout所在线程（<u>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</u>）<br>&emsp;&emsp;异步http请求线程：在XMLHttpRequest连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行</p>
<p><em>&emsp;&emsp;[注] <u>GUI 渲染线程与 JavaScript 引擎线程是互斥的。</u></em></p>
<h2 id="1、JS异步操作的几种方式"><a href="#1、JS异步操作的几种方式" class="headerlink" title="1、JS异步操作的几种方式"></a>1、JS异步操作的几种方式</h2><p>&emsp;&emsp;JavaScript中的任务分为同步任务和异步任务。<br>&emsp;&emsp;同步任务是那些没有被引擎挂起、<u>在主线程上排队执行的任务。</u>只有前一个任务执行完毕，才能执行后一个任务。<br>&emsp;&emsp;异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列（根据异步任务的类型，引擎实际上存在多个任务队列）的任务。只有引擎认为某个异步任务可以被执行了，该任务才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运。即异步任务不具有堵塞效应。</p>
<p>&emsp;&emsp;主线程会排队去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行。等到执行完，下一个异步任务再进入主线程开始执行。一旦同步与异步任务队列清空，程序就结束执行。</p>
<p>&emsp;&emsp;同步任务执行完成，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<u>事件循环（Event Loop）</u>。</p>
<p>&emsp;&emsp;异步操作的几种模式：回调函数、事件监听、发布/订阅模式、Generator 函数、Promise、async/await。</p>
<hr>
<h3 id="定时器相关概念"><a href="#定时器相关概念" class="headerlink" title="定时器相关概念"></a>定时器相关概念</h3><p>&emsp;&emsp;JavaScript 提供定时执行代码的功能，叫做定时器，主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。<u>定时器的运行机制是，将指定的代码移出本轮事件循环（即使设置延迟执行为0ms)，等到下一轮事件循环，再检查是否到了指定时间。如果到了，再将对应代码放入主线程进行执行；如果没到，就继续等待。</u></p>
<p>&emsp;&emsp;<u>setTimeout()</u>：用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，可以将该编号作为参数调用clearTimeout()方法来取消这个定时器。setTimeout()可以接收多个参数，第一个参数为回调函数或字符串代码，会在定时时间到达时执行，第二个参数为延迟执行的时间（单位ms），后面的参数列表会作为第一个参数回调函数的参数传入。<u>特别的，回调函数是如果是某一对象的方法，内部this指向是是全局环境的而不是定义所在的那个对象。</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let id &#x3D; setTimeout(function | code, delay, [a, b, c...]);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;定时任务开始执行，&#39; + new Date())</span><br><span class="line">let id &#x3D;  setTimeout((a,b,c) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;定时任务执行完成，&#39;+ new Date() +&#39;，回调函数已开始执行&#39;);</span><br><span class="line">  console.log(&#39;回调函数计算结果为：&#39;+ (a+b+c));</span><br><span class="line">&#125;,1000, 1,2,3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; 定时任务开始执行，Wed May 26 2021 16:40:09 GMT+0800 (中国标准时间)</span><br><span class="line">&#x2F;&#x2F; 定时任务执行完成，Wed May 26 2021 16:40:10 GMT+0800 (中国标准时间)，回调函数已开始执行</span><br><span class="line">&#x2F;&#x2F; 回调函数计算结果为：6</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<u>setInterval()</u>：setInterval()函数的用法与setTimeout()完全一致，区别仅仅在于setInterval()指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。特别的，指定的是<u>“开始执行”</u>之间的间隔，并不考虑每次任务执行本身所消耗的时间。实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 1000ms 执行一次，每次执行需要 500ms，那么第一次执行结束后等待500毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要1500毫秒，那么它结束后，下一次任务执行才会立即开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let count &#x3D; 0; &#x2F;&#x2F; 计时器，控制任务执行5次    </span><br><span class="line">console.log(new Date() + &#39;，延迟2s后开始执行定时任务~&#39;);</span><br><span class="line">let id &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">  let delay &#x3D; Math.floor(Math.random() * 5 + 1) * 1000;</span><br><span class="line">  console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务开始执行，需要&#39; + delay + &#39;ms才能完成&#39;)</span><br><span class="line">  sleep(delay);</span><br><span class="line">  console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务执行完成&#39;)</span><br><span class="line">  count++;</span><br><span class="line">  if (count &#x3D;&#x3D; 5) &#123;</span><br><span class="line">    clearInterval(id)</span><br><span class="line">    console.log(&#39;任务已执行5次，结束定时器任务~&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 2000)</span><br><span class="line">function sleep(ms) &#123; &#x2F;&#x2F; 通过循环阻塞代码执行来模拟同步操作</span><br><span class="line">  var start &#x3D; Date.now();</span><br><span class="line">  while ((Date.now() - start) &lt; ms) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:39 GMT+0800 (中国标准时间)，延迟2s后开始执行定时任务~</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:41 GMT+0800 (中国标准时间)，第1次任务开始执行，需要1000ms才能完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:42 GMT+0800 (中国标准时间)，第1次任务执行完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:43 GMT+0800 (中国标准时间)，第2次任务开始执行，需要4000ms才能完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第2次任务执行完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第3次任务开始执行，需要3000ms才能完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第3次任务执行完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第4次任务开始执行，需要3000ms才能完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第4次任务执行完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第5次任务开始执行，需要4000ms才能完成</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:13:57 GMT+0800 (中国标准时间)，第5次任务执行完成</span><br><span class="line">&#x2F;&#x2F; 任务已执行5次，结束定时器任务~</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，第一次任务开始在13:13:41，需要执行1s，在13:13:42第一次任务就执行完成。由于设置的执行时间间隔是2s，等待1s后13:13:43才开始执行第二次任务。第二次任务需要执行4s，在13:13:47秒时第二次任务才执行完成；虽然设置的时间间隔为2s，但第二次任务执行时间大于设置的2s，第三次任务在第二次任务执行完后才开始执行。后面的任务执行情况同理。</p>
<p>&emsp;&emsp;注意，setTimeout()定时任务也会被阻塞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(new Date() + &#39;，延迟1s后开始执行定时任务~&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(new Date() + &#39;，延迟任务执行完成~&#39;)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">sleep(2000);</span><br><span class="line">function sleep(ms) &#123; &#x2F;&#x2F; 通过循环阻塞代码执行来模拟同步操作</span><br><span class="line">  var start &#x3D; Date.now();</span><br><span class="line">  console.log(&#39;当前sleep任务要执行&#39; + ms + &#39;ms&#39;)</span><br><span class="line">  while ((Date.now() - start) &lt; ms) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:34:00 GMT+0800 (中国标准时间)，延迟1s后开始执行定时任务~</span><br><span class="line">&#x2F;&#x2F; 当前sleep任务要执行2000ms</span><br><span class="line">&#x2F;&#x2F; Thu Nov 26 2020 13:34:02 GMT+0800 (中国标准时间)，延迟任务执行完成~</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到在13:34:00时，setTimeout()的回调函数本应该延迟1s执行，但sleep操作要执行2s。导致setTimeout()回调函数在13:34:02时才被执行。</p>
<p>&emsp;&emsp;<strong>setTimeout()与setInterval()可能会被同步任务阻塞，和定时器的运行机制有关。setTimeout和setInterval指定的回调函数，<u>必须等到本轮事件循环的所有同步任务都执行完成（上面代码中sleep()函数循环来模拟同步任务），才会被添加到主线程开始执行，而且此时的回调函数执行是同步的，只有回调函数执行完成，才会进行下一轮事件循环。</u>由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。<u>即使使用嵌套的setTimeout()来实现每两次任务执行之间有固定的间隔，也是有被阻塞的风险。</u></strong></p>
<hr>
<h3 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1) 回调函数"></a>1) 回调函数</h3><p>&emsp;&emsp;回调函数实现异步操作是指在开始执行的异步函数指定为参数的函数（回调函数不会立即被执行），当异步函数包含的异步操作执行完成时，再调用执行该回调函数。<u>回调函数是异步编程的最基本的方法。</u></p>
<p>&emsp;&emsp;将处理函数当做参数，在相关任务执行完成再调用执行，形如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1&#123;</span><br><span class="line">  &#x2F;&#x2F; 相关代码</span><br><span class="line">&#125;</span><br><span class="line">function f2(cb)&#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2(f1);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面模拟一个读取文件列表（3个文件）获取对应文件的总行数的示例，这里采用回调函数的方式进行依次读取（还有其他或更好的方式实现，这里只是为了用来说明回调函数）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fileLines &#x3D; [];    </span><br><span class="line">function asyncFn(inx, cb) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s</span><br><span class="line">    let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟本次读取的文件的行数</span><br><span class="line">    fileLines.push(lines)</span><br><span class="line">    console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">    cb();</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function consoleResult() &#123;</span><br><span class="line">  console.log(&#39;代码执行完成，文件行数依次为：&#39;);</span><br><span class="line">  console.log(fileLines)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);</span><br><span class="line">&#x2F;&#x2F; 假设文件列表有3个文件，这里调用3次文件读取函数asyncFn()</span><br><span class="line">asyncFn(1, function () &#123;</span><br><span class="line">  asyncFn(2, function () &#123;</span><br><span class="line">    asyncFn(3, consoleResult)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 16:23:40 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 16:23:41 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 95</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 16:23:42 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 88</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 16:23:43 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 51</span><br><span class="line">&#x2F;&#x2F; 代码执行完成，文件行数依次为：</span><br><span class="line">&#x2F;&#x2F; 95,88,51</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里asyncFn()负责读取文件获取文件行数，里面使用了计时器来模拟异步操作，用随机数模拟获取的文件行数。假设文件列表只有3个文件，这里asyncFn()调用了3次，每次分别传入了一个函数，这个函数就是我们说的回调函数，在成功读取文件获得行数后立即被执行。第1个读取文件时，将读取第2个文件的任务放在了回调函数里，在第1个文件读取完成后，执行回调函数，开始了第2个文件的读取；同理，把读取第3个文件的任务放在了读取第2个文件的回调函数里，在第2个文件读取完成后，执行回调函数，第3个文件的读取开始执行。特别的，读取第3个文件的回调函数里放入了我们输出结果的函数consoleResult()，所以当第3个文件读取完成时，回调函数立即被执行，回调函数输出了依次读取到的文件行数信息。</p>
<p>&emsp;&emsp;<u>回调函数的比较好理解，就是在异步任务完成后，再继续执行后续的任务，比较容易理解与实现。但回调函数的代码是高度耦合的，执行取决于代码的结构（代码顺序），特别是多个异步任务作为回调函数嵌套执行的时候（例如上面的代码，这种现象也成‘回调地狱’），相关代码比较分散，不利于阅读和维护。</u></p>
<h3 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2) 事件监听"></a>2) 事件监听</h3><p>&emsp;&emsp;采用事件驱动的形式，任务被执行不取决于代码结构，取决于相关联的事件是否发生。</p>
<p>&emsp;&emsp;形如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eventSource.on(&#39;done&#39;,fn); &#x2F;&#x2F; eventSource对象监听done事件，并添加fn后续处理函数</span><br><span class="line">eventSource.tigger(&#39;done&#39;); &#x2F;&#x2F; eventSource触发done事件</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还是上面的示例，这里采用jQuery的自定义事件。输出结果也完全一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let times &#x3D; 0;</span><br><span class="line">let fileLines &#x3D; [];</span><br><span class="line">$(document).on(&#39;done&#39;, doneFn) &#x2F;&#x2F; 给document绑定done事件，若document的done事件发生，执行doneFn()处理函数</span><br><span class="line">function doneFn(event, lines)&#123;</span><br><span class="line">  console.log(new Date() + &#39; 第&#39; + times + &#39;次读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">  fileLines.push(lines)</span><br><span class="line">&#125;</span><br><span class="line">function asyncFn() &#123;</span><br><span class="line">  let id &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    times++;</span><br><span class="line">    if (times &lt;&#x3D; 3) &#123;</span><br><span class="line">      let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟本次读取的文件的行数</span><br><span class="line">      $(document).trigger(&#39;done&#39;, lines) &#x2F;&#x2F; 触发document done事件发生，驱动doneFn()处理函数执行</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clearInterval(id)</span><br><span class="line">      console.log(&#39;代码执行完成，文件行数依次为：&#39;);</span><br><span class="line">      console.log(fileLines)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);</span><br><span class="line">asyncFn()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:01:10 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:01:11 GMT+0800 (中国标准时间) 第1次读取文件完成，文件总行数为 61</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:01:12 GMT+0800 (中国标准时间) 第2次读取文件完成，文件总行数为 91</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:01:13 GMT+0800 (中国标准时间) 第3次读取文件完成，文件总行数为 73</span><br><span class="line">&#x2F;&#x2F; 代码执行完成，文件行数依次为：61 91 73</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里使用setInterval()来模拟3次读取文件任务，在第3次文件读取完成后清空计时器并输出结果。可以看到，在每次文件读取完成后，使用$(document).trigger(‘done’, lines)触发‘done’事件，通过事件监听器$(document).on(‘done’, doneFn)关联的doneFn()处理函数被执行。<u>其中，这里的document称为为事件源，‘done’称为为事件，‘on’称为事件监听器，doneFn()函数称为处理方法。</u></p>
<p>&emsp;&emsp;<u>事件驱动比较容易理解，就是在任务完成后继续触发后续任务的执行。可以绑定多个事件，每个事件可以指定多个回调函数，与回调函数相比，大大降低了代码的耦合度（但代码还是耦合的，绑定在同一个事件源上），有利于实现模块化。但事情驱动代码也较为分散，不利于阅读与维护。</u></p>
<h3 id="3-发布-订阅模式"><a href="#3-发布-订阅模式" class="headerlink" title="3) 发布/订阅模式"></a>3) 发布/订阅模式</h3><p>&emsp;&emsp;如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”一个信号，其他任务可以向信号中心“订阅”这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。</p>
<p>&emsp;&emsp;发布/订阅模式的性质与“事件监听”类似，但功能上优于事件监听的方式。因为可以通过查看“信号中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="4-Generator-函数（ES6新增）"><a href="#4-Generator-函数（ES6新增）" class="headerlink" title="4) Generator 函数（ES6新增）"></a>4) Generator 函数（<u>ES6新增</u>）</h3><p>&emsp;&emsp;Generator 函数是一直特殊的函数，最大特点就是可以交出函数的执行权（即暂停执行）。可以把理解成，Generator 函数是一个状态机，封装了多个内部状态。Generator 函数内部使用yield表达式定义内部状态，为了与普通函数区别，一般在function关键字与函数名直接添加‘*’来标识（非必须，在函数内部使用yield的关键字这个函数就是 Generator 函数）。<u>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的迭代对象。必须调用next方法依次对状态进行迭代（恢复代码执行），内部指针就从函数头部或上一次停下来的地方开始执行（暂停执行的地方），直到遇到下一个yield关键字定义的状态时又会停止执行。每次调用next()会返回本次迭代的结果对象，其中的value属性表示当前的内部状态（结果），done属性标识整个迭代对象的迭代是否完成。</u></p>
<p>&emsp;&emsp;举个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  console.log(new Date() + &#39; status 1&#39;);</span><br><span class="line">  yield &#39;status 1&#39;;</span><br><span class="line">  console.log(new Date() + &#39; status 2&#39;);</span><br><span class="line">  yield &#39;status 2&#39;;</span><br><span class="line">  console.log(new Date() + &#39; status 3&#39;);</span><br><span class="line">  yield &#39;status 3&#39;;</span><br><span class="line">  console.log(new Date() + &#39; status 4&#39;);</span><br><span class="line">  yield &#39;status 4&#39;;</span><br><span class="line">  console.log(new Date() + &#39; status 5&#39;);</span><br><span class="line">&#125;</span><br><span class="line">let g &#x3D; gen();</span><br><span class="line">let id &#x3D; setInterval(() &#x3D;&gt; &#123; &#x2F;&#x2F; 用计时器进行迭代来模拟异步操作</span><br><span class="line">  if(g.next().done)&#123;</span><br><span class="line">    clearInterval(id);</span><br><span class="line">    console.log(&#39;状态迭代完成~&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:24:24 GMT+0800 (中国标准时间) status 1</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:24:25 GMT+0800 (中国标准时间) status 2</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:24:26 GMT+0800 (中国标准时间) status 3</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:24:27 GMT+0800 (中国标准时间) status 4</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:24:28 GMT+0800 (中国标准时间) status 5</span><br><span class="line">&#x2F;&#x2F; 状态迭代完成~</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用Generator函数来模拟上面异步读取文件行数示例的代码：（_[注] 这种实现方式并不是最优的，结合Promise来确定每次异步操作已执行完成再进行下一次迭代操作比这里简单使用计时器模拟更为合理；使用Thunk函数或者co函数库来实现状态自动迭代的流程管理更加优雅_）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fileLines &#x3D; [];</span><br><span class="line">function readFile(inx) &#123;</span><br><span class="line">  let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟这些文件的总行数</span><br><span class="line">  fileLines.push(lines)</span><br><span class="line">  console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">&#125;</span><br><span class="line">function* asyncFn() &#123;</span><br><span class="line">  yield readFile(1);</span><br><span class="line">  yield readFile(2);</span><br><span class="line">  readFile(3);</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行~&#39;);</span><br><span class="line">let g &#x3D; asyncFn();</span><br><span class="line">let id &#x3D; setInterval(() &#x3D;&gt; &#123; &#x2F;&#x2F; 模拟异步</span><br><span class="line">  if(g.next().done)&#123;</span><br><span class="line">    clearInterval(id)</span><br><span class="line">    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);</span><br><span class="line">    console.log(fileLines)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:04:39 GMT+0800 (中国标准时间) 代码开始执行~</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:04:40 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 69</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:04:41 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 57</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:04:42 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 86</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:04:42 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：69 57 86</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<u>Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即各个状态间的管理不方便）。不过使用thunk函数或者co函数库能够解决这个问题。</u></p>
<h3 id="5-Promise（ES6新增）"><a href="#5-Promise（ES6新增）" class="headerlink" title="5) Promise（ES6新增）"></a>5) Promise（<u>ES6新增</u>）</h3><p>&emsp;&emsp;promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。一个 promise 必然处于以下几种状态之一：pending（初始状态）、fulfilled（操作成功完成）、rejected（操作失败）。</p>
<p>&emsp;&emsp;<u>处理待定状态（pending）的 Promise 对象要么会通过一个值被成功执行（fulfilled），要么会通过一个原因或错误被拒绝（rejected）。当这些情况之一发生时，promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用。Promise.prototype.then 和  Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。</u></p>
<p>&emsp;&emsp;一般我们使用Promise()构造函数来创建一个 promise 对象，以此对还没有添加 promise 支持的函数进行相应的封装使用。<u>在适当的时候，调用resolve()方法将新的promise 对象的pending状态改变为fulfilled状态，或者调用reject()将pending状态改变为rejected状态。</u>若不使用这两个静态方法，新的 promise 对象的状态仍为pending初始化状态。</p>
<p>&emsp;&emsp;<strong>Promise有一些静态方法：</strong></p>
<p>&emsp;&emsp;all()：所有promise对象都完成且都成功（fulfilled）时触发（执行then()分支），会把所有promise返回值的数组作为成功回调的返回值，顺序跟promise的顺序保持一致，任意一个promise失败（rejected）则立即触发该失败（执行catch分支），第一个触发失败的promise对象的错误信息将作为它的失败错误信息，<u>此时，其他的pending状态的promise还是会执行直至完成（promise开始执行后不能被取消）。Promise.all方法常被用于处理多个promise对象的状态集合。</u></p>
<p>&emsp;&emsp;allSettled() ：所有promise对象都完成(fulfilled/rejected)时触发（执行then()分支），返回一个promise结果对象的数组，顺序与promise的顺序保持一致。每个promise结果对象包含status属性（状态），value属性（fulfilled状态时返回值）以及reason属性（rejected状态时返回的失败原因）等属性。</p>
<p>&emsp;&emsp;any()：promise对象的集合中当其中的一个 promise 成功（fulfilled）触发，就返回那个成功的promise的值（执行then分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;race()：promise对象的集合中当其中的一个 promise 成功（fulfilled）或失败（rejected）时触发，成功就返回那个成功的promise的值（执行then分支），失败就返回那个失败promise失败的原因（执行catch分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;reject()：返回一个失败状态的Promise对象，并将给定的失败信息传递给对应的处理方法。</p>
<p>&emsp;&emsp;resolve()：返回一个成功状态的Promise对象，其中value为返回结果。</p>
<p>&emsp;&emsp;Promise异步读取文件行数示例的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let filelines &#x3D;[];</span><br><span class="line">function readFile(inx) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟这些文件的总行数</span><br><span class="line">      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">      resolve(lines)</span><br><span class="line">    &#125;, 1000, inx)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行~&#39;);</span><br><span class="line">readFile(1).then(res &#x3D;&gt; &#123;</span><br><span class="line">  filelines.push(res);</span><br><span class="line">  return readFile(2);</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">  filelines.push(res);</span><br><span class="line">  return readFile(3);</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">  filelines.push(res);</span><br><span class="line">  console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);</span><br><span class="line">  console.log(filelines);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:10:52 GMT+0800 (中国标准时间) 代码开始执行~</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:10:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 82</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:10:54 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 90</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:10:55 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 64</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:10:55 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：82 90 64</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<u><strong>Promise处理异步（特别是处理一次性结果）十分方便，也支持链式的进行调用，是目前较好的异步编程方式。</strong>特别是结合Array对象相关的方法如map()、filter()等。不过Promise也有一定的缺点，一但创建便会执行，不能取消，也无法得知目前进展到哪一个阶段；如果不设置回调函数，Promise内部抛出的错误，不会反应到外部等问题。</u></p>
<p>&emsp;&emsp;例如上面的Promise处理代码可以结合Array.map()方法生成promise对象集合（数组），由Promise.all()去并行执行（流程控制相关概念见后文）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function readFile(inx)&#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟这些文件的总行数</span><br><span class="line">      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">      resolve(lines)</span><br><span class="line">    &#125;, 1000, inx)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行~&#39;);</span><br><span class="line">Promise.all([1, 2, 3].map((item) &#x3D;&gt; readFile(item))).then(list &#x3D;&gt; &#123;</span><br><span class="line">  console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);</span><br><span class="line">  console.log(list)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:11:46 GMT+0800 (中国标准时间) 代码开始执行~</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 97</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 69</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 75</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：97 69 75    </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两段代码相比，可以看到后面这段代码明显更加的简洁。更重要的是，前一种写法读取3个文件的任务需要3s时间才能完成，后一种并行执行写法只需要1s时间便可完成。</p>
<h3 id="5-async-await（ES7新增）"><a href="#5-async-await（ES7新增）" class="headerlink" title="5) async/await（ES7新增）"></a>5) async/await（<u>ES7新增</u>）</h3><p>&emsp;&emsp;async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。<br>&emsp;&emsp;async 函数是 Generator 函数的语法糖且async 函数自带执行器。async函数可能包含0个或者多个await表达式。<br>&emsp;&emsp;async函数一定会返回一个promise对象。如果一个async函数的返回值不是promise，那么它将会被隐式地包装在一个promise中。</p>
<p>&emsp;&emsp;await表达式会暂停整个async函数的执行进程并出让其控制权：<br>&emsp;&emsp;(1) 如果await后面是普通表达式， await 表达式的运算结果就是它等待的的结果。<br>&emsp;&emsp;(2) 如果await后面是promise对象，只有当其等待的promise的异步操作成功或失败之后才会恢复进程，promise的结果会被当作该await表达式的返回值，此时await会阻塞后面的代码执行。<u>所以把await放在async函数内部，因为async 函数的调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</u><br>&emsp;&emsp;(3) <u>await 命令后面的 promise 运行结果如果是 rejected，此时async/await无法处理，一般要把 await 命令放在 try…catch 代码块中。</u></p>
<p>&emsp;&emsp;async/await读取文件行数示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function readFile(inx) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟这些文件的总行数</span><br><span class="line">      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">      resolve(lines)</span><br><span class="line">    &#125;, 1000, inx)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async function getLines()&#123;</span><br><span class="line">  let line1 &#x3D; await readFile(1); &#x2F;&#x2F; 读取文件1</span><br><span class="line">  let line2 &#x3D; await readFile(2); &#x2F;&#x2F; 读取文件2</span><br><span class="line">  let line3 &#x3D; await readFile(3); &#x2F;&#x2F; 读取文件3</span><br><span class="line">  console.log(new Date() + &#39; 代码执行完成，结果为：&#39; + [line1, line2, line3])</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行~&#39;);</span><br><span class="line">getLines();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:18:13 GMT+0800 (中国标准时间) 代码开始执行~</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:18:14 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 72</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:18:15 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 82</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:18:16 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 55</span><br><span class="line">&#x2F;&#x2F; Wed May 26 2021 17:18:16 GMT+0800 (中国标准时间) 代码执行完成，结果为：72,82,55</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;async/await的优点：<br>&emsp;&emsp;它做到了真正的串行的同步写法，代码阅读相对容易。<br>&emsp;&emsp;对于条件语句和其他流程语句比较友好，可以将await直接写到判断条件里。<br>&emsp;&emsp;处理复杂流程时，在代码更加清晰简洁。</p>
<p>&emsp;&emsp;async/await的缺点：<br>&emsp;&emsp;<u>无法处理promise返回的reject对象，要借助try…catch…捕获异常等。</u><br>&emsp;&emsp;<strong>await只能串行，做不到并行（因为await一定是阻塞的）等。</strong></p>
<h2 id="2、异步操作流程控制"><a href="#2、异步操作流程控制" class="headerlink" title="2、异步操作流程控制"></a>2、异步操作流程控制</h2><p>&emsp;&emsp;如果有多个异步操作，为了代码的执行效率与可维护性，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。<br>&emsp;&emsp;流程控制一般有串行执行、并行执行等方式。<br>&emsp;&emsp;串行执行：一个异步任务执行完成后在执行下一个任务。（上面异步读取文件行数的示例中，除了Promise处理中的第2种写法，其他全是串行执行的）<br>&emsp;&emsp;并行执行：所有异步任务同时执行（并行非并发）。（例如上面Promise处理中的第2种写法）</p>
<p>&emsp;&emsp;例如读取文件异步操作回调函数的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 其他代码省略</span><br><span class="line">asyncFn(1, function () &#123;</span><br><span class="line">  asyncFn(2, function () &#123;</span><br><span class="line">    asyncFn(3, consoleResult)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码虽然也是串行执行的，但多次嵌套，不利于阅读与维护。我们编写一个流程控制函数来控制异步操作串行执行，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fileList &#x3D; [1, 2, 3];</span><br><span class="line">let fileLines &#x3D; [];</span><br><span class="line">function asyncFn(inx, cb) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s</span><br><span class="line">    let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟本次读取的文件的行数</span><br><span class="line">    console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">    cb(lines)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function consoleResult() &#123;</span><br><span class="line">  console.log(&#39;代码执行完成，文件行数依次为：&#39;);</span><br><span class="line">  console.log(fileLines)</span><br><span class="line">&#125;</span><br><span class="line">function series(item) &#123;</span><br><span class="line">  if (item) &#123;</span><br><span class="line">    asyncFn(item, function (lines) &#123;</span><br><span class="line">      fileLines.push(lines)</span><br><span class="line">      return series(fileList.shift());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return consoleResult();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);</span><br><span class="line">series(fileList.shift());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:48:41 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:48:42 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:48:43 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 70</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 70</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,70,70</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码中，series为流程控制函数。每次读取一个文件，并将文件名从待读取文件f列表ileList中删除。再递归调用读取下一个文件，直至待读取文件列表为空则所有文件读取完成。这里串行执行读取文件完成需要3s时间。（_串行流程函数控制不止这一种方式实现_）</p>
<p>&emsp;&emsp;将流程控制改为并行执行（利用循环语句）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fileList &#x3D; [1, 2, 3];</span><br><span class="line">let fileLines &#x3D; [];</span><br><span class="line">function asyncFn(inx, cb) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s</span><br><span class="line">    let lines &#x3D; Math.floor(Math.random() * 50) + 50; &#x2F;&#x2F; 用随机数[50-100）模拟本次读取的文件的行数</span><br><span class="line">    console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);</span><br><span class="line">    cb(lines)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function consoleResult() &#123;</span><br><span class="line">  console.log(new Date() + &#39;代码执行完成，文件行数依次为：&#39; + fileLines);</span><br><span class="line">&#125;</span><br><span class="line">function series(fileList) &#123;</span><br><span class="line">  fileList.forEach((item, index) &#x3D;&gt; &#123;</span><br><span class="line">    asyncFn(item, function (lines) &#123;</span><br><span class="line">      fileLines[index] &#x3D; lines</span><br><span class="line">      if (fileLines.length &#x3D;&#x3D; fileList.length) &#123;</span><br><span class="line">        consoleResult();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);</span><br><span class="line">series(fileList);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出:</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:49:52 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 94</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 57</span><br><span class="line">&#x2F;&#x2F; Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,94,57</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码中，series中使用forEach()方法时读取文件同时进行，因为不知道各次读取文件完成的先后顺序，这里不能使用fileLines.push()方法保存结果，可能会得的结果与文件读取顺序不匹配。这里将结果赋值给fileLines[index]能保证结果的顺序与读取文件的顺序一致。当获得的结果的长度与读取文件的次数相同时，所有文件读取完成。这里并行执行读取文件完成需要1s时间。</p>
<p><em>&emsp;&emsp;[注] 并行流程函数控制不止这一种方式实现</em></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
</search>
