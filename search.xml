<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML Canvas（2D时序动画）</title>
    <url>/2020/09/15/html/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>HTML5 &lt;canvas&gt; 标签用于绘制图像，但元素本身并没有绘制能力（它仅仅是图形的容器），您必须使用JavaScript脚本（相关API）来完成实际的绘图任务。</p>
<h2 id="1、坐标系"><a href="#1、坐标系" class="headerlink" title="1、坐标系"></a>1、坐标系</h2><h4 id="1-标准（初始）坐标系"><a href="#1-标准（初始）坐标系" class="headerlink" title="(1) 标准（初始）坐标系"></a>(1) 标准（初始）坐标系</h4><p><img src="/images/canvas/%E6%A0%87%E5%87%86%EF%BC%88%E5%88%9D%E5%A7%8B%EF%BC%89%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="标准（初始）坐标系"><br>&emsp;&emsp;canvas 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas 元素中的一像素。栅格的起点为左上角，坐标为 (0,0) 。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。</p>
<h4 id="2-偏移坐标原点（translate方法）"><a href="#2-偏移坐标原点（translate方法）" class="headerlink" title="(2) 偏移坐标原点（translate方法）"></a>(2) 偏移坐标原点（translate方法）</h4><p><img src="/images/canvas/%E5%81%8F%E7%A7%BB%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9.png" alt="偏移坐标原点"><br>&emsp;&emsp;translate 方法用来移动 canvas 的原点到指定的位置。接受两个参数。x 是左右的偏移量，y 是上下的偏移量。</p>
<h4 id="3-旋转坐标轴（rotate方法）"><a href="#3-旋转坐标轴（rotate方法）" class="headerlink" title="(3) 旋转坐标轴（rotate方法）"></a>(3) 旋转坐标轴（rotate方法）</h4><p><img src="/images/canvas/%E6%97%8B%E8%BD%AC%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="旋转坐标轴"><br>&emsp;&emsp;rotate方法用来旋转坐标轴，只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。</p>
<h2 id="2、绘图流程"><a href="#2、绘图流程" class="headerlink" title="2、绘图流程"></a>2、绘图流程</h2><h4 id="1-创建canvas元素（图形容器）"><a href="#1-创建canvas元素（图形容器）" class="headerlink" title="(1) 创建canvas元素（图形容器）"></a>(1) 创建canvas元素（图形容器）</h4><pre><code>  &lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;
</code></pre>
<h4 id="2-获取canvas-DOM元素"><a href="#2-获取canvas-DOM元素" class="headerlink" title="(2) 获取canvas DOM元素"></a>(2) 获取canvas DOM元素</h4><pre><code>  let canvas=document.getElementById(&quot;myCanvas&quot;)
</code></pre>
<h4 id="3-获得canvas-context-对象"><a href="#3-获得canvas-context-对象" class="headerlink" title="(3) 获得canvas context 对象"></a>(3) 获得canvas context 对象</h4><pre><code>  let ctx=canvas.getContext(&quot;2d&quot;)
</code></pre>
<h4 id="4-调用相关绘图API定义要绘制的路径与图像"><a href="#4-调用相关绘图API定义要绘制的路径与图像" class="headerlink" title="(4) 调用相关绘图API定义要绘制的路径与图像"></a>(4) 调用相关绘图API定义要绘制的路径与图像</h4><pre><code>  // 画线    
  ctx.moveTo(0, 0);
  ctx.lineTo(100, 100);
  // 画圆
  ctx.arc(95, 50, 40, 2 * Math.PI, 0);
  // ...
  // 可添加对键盘鼠标键盘事件的处理，实现交互动画
</code></pre>
<h4 id="5-绘制已定义的路径及图像"><a href="#5-绘制已定义的路径及图像" class="headerlink" title="(5) 绘制已定义的路径及图像"></a>(5) 绘制已定义的路径及图像</h4><pre><code>  ctx.stroke(); // 有时会重新映射坐标原点或者旋转画布坐标轴，需要ctx.save()与ctx.restore()配合使用来存储于恢复画布状态
</code></pre>
<h4 id="6-定时刷新canvas从而实现动画效果"><a href="#6-定时刷新canvas从而实现动画效果" class="headerlink" title="(6) 定时刷新canvas从而实现动画效果"></a>(6) 定时刷新canvas从而实现动画效果</h4><pre><code>  // requestAnimationFrame()方法（推荐）或者setInterval()/递归调用setTimeout()方法进行刷新动画
</code></pre>
<h2 id="3、常用绘图属性与API方法"><a href="#3、常用绘图属性与API方法" class="headerlink" title="3、常用绘图属性与API方法"></a>3、常用绘图属性与API方法</h2><h4 id="1-颜色、样式、阴影属性与方法"><a href="#1-颜色、样式、阴影属性与方法" class="headerlink" title="(1) 颜色、样式、阴影属性与方法"></a>(1) 颜色、样式、阴影属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillStyle</td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td>strokeStyle</td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td>shadowColor</td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td>shadowBlur</td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td>shadowOffsetX</td>
<td>设置或返回阴影与形状的水平距离</td>
</tr>
<tr>
<td>shadowOffsetY</td>
<td>设置或返回阴影与形状的垂直距离</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createLinearGradient()</td>
<td>创建线性渐变（用在画布内容上）</td>
</tr>
<tr>
<td>createPattern()</td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td>createRadialGradient()</td>
<td>创建放射状/环形的渐变（用在画布内容上）</td>
</tr>
<tr>
<td>addColorStop()</td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody></table>
<h4 id="2-线条样式属性"><a href="#2-线条样式属性" class="headerlink" title="(2) 线条样式属性"></a>(2) 线条样式属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lineCap</td>
<td>设置或返回线条的结束端点样式(值为square、round，线条会稍稍变长)</td>
</tr>
<tr>
<td>lineJoin</td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td>lineWidth</td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td>miterLimit</td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody></table>
<h4 id="3-矩形方法"><a href="#3-矩形方法" class="headerlink" title="(3) 矩形方法"></a>(3) 矩形方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>rect()</td>
<td>创建矩形</td>
</tr>
<tr>
<td>fillRect()</td>
<td>绘制‘被填充’的矩形</td>
</tr>
<tr>
<td>strokeRect()</td>
<td>绘制矩形（无填充）</td>
</tr>
<tr>
<td>clearRect()</td>
<td>在给定的矩形内清除指定的像素</td>
</tr>
</tbody></table>
<h4 id="4-路径方法"><a href="#4-路径方法" class="headerlink" title="(4) 路径方法"></a>(4) 路径方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fill()</td>
<td>填充当前绘图（路径）</td>
</tr>
<tr>
<td>stroke()</td>
<td>绘制已定义的路径</td>
</tr>
<tr>
<td>beginPath()</td>
<td>起始一条路径，或重置当前路径</td>
</tr>
<tr>
<td>moveTo()</td>
<td>把路径移动到画布中的指定点，不创建线条</td>
</tr>
<tr>
<td>closePath()</td>
<td>创建从当前点回到起始点的路径</td>
</tr>
<tr>
<td>lineTo()</td>
<td>添加一个新点，然后在画布中创建从该点到最后指定点的线条</td>
</tr>
<tr>
<td>clip()</td>
<td>原始画布剪切任意形状和尺寸的区域(裁剪路径的作用可制作遮罩)</td>
</tr>
<tr>
<td>quadraticCurveTo()</td>
<td>创建二次贝塞尔曲线</td>
</tr>
<tr>
<td>bezierCurveTo()</td>
<td>创建三次贝塞尔曲线</td>
</tr>
<tr>
<td>arc()</td>
<td>创建弧/曲线（用于创建圆形或部分圆）</td>
</tr>
<tr>
<td>arcTo()</td>
<td>创建两切线之间的弧/曲线</td>
</tr>
<tr>
<td>isPointInPath()</td>
<td>如果指定的点位于当前路径中，则返回true，否则返回false</td>
</tr>
<tr>
<td>setLineDash()</td>
<td>填充线时使用虚线模式（参数为数组，交替描述绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复）</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;注：一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）</em></p>
<h4 id="5-转换方法"><a href="#5-转换方法" class="headerlink" title="(5) 转换方法"></a>(5) 转换方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>scale()</td>
<td>缩放当前绘图至更大或更小</td>
</tr>
<tr>
<td>rotate()</td>
<td>旋转当前绘图</td>
</tr>
<tr>
<td>translate()</td>
<td>重新映射画布上的 (0,0) 位置</td>
</tr>
<tr>
<td>transform()</td>
<td>替换绘图的当前转换矩阵</td>
</tr>
<tr>
<td>setTransform()</td>
<td>将当前转换重置为单位矩阵。然后运行transform()</td>
</tr>
</tbody></table>
<h4 id="6-文本属性与方法"><a href="#6-文本属性与方法" class="headerlink" title="(6) 文本属性与方法"></a>(6) 文本属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>font</td>
<td>设置或返回文本内容的当前字体属性</td>
</tr>
<tr>
<td>textAlign</td>
<td>设置或返回文本内容的当前对齐方式</td>
</tr>
<tr>
<td>textBaseline</td>
<td>设置或返回在绘制文本时使用的当前文本基线</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fillText()</td>
<td>在画布上绘制”被填充的”文本</td>
</tr>
<tr>
<td>strokeText()</td>
<td>在画布上绘制文本（无填充）</td>
</tr>
<tr>
<td>measureText()</td>
<td>返回包含指定文本宽度的对象</td>
</tr>
</tbody></table>
<h4 id="7-像素操作属性与方法"><a href="#7-像素操作属性与方法" class="headerlink" title="(7) 像素操作属性与方法"></a>(7) 像素操作属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>返回 ImageData 对象的宽度</td>
</tr>
<tr>
<td>height</td>
<td>返回 ImageData 对象的高度</td>
</tr>
<tr>
<td>data</td>
<td>返回一个对象，其包含指定的 ImageData 对象的图像数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createImageData()</td>
<td>创建新的、空白的 ImageData 对象</td>
</tr>
<tr>
<td>getImageData()</td>
<td>返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据</td>
</tr>
<tr>
<td>putImageData()</td>
<td>把图像数据（从指定的 ImageData 对象）放回画布上</td>
</tr>
</tbody></table>
<h4 id="8-图像绘制方法"><a href="#8-图像绘制方法" class="headerlink" title="(8) 图像绘制方法"></a>(8) 图像绘制方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>drawImage()</td>
<td>向画布上绘制图像、画布或视频</td>
</tr>
</tbody></table>
<pre><code>  context.drawImage(img,[sx,sy,swidth,sheight,]x,y,[width,height]); // 语法，其中img为Image实例
</code></pre>
<h4 id="9-其他属性与方法"><a href="#9-其他属性与方法" class="headerlink" title="(9) 其他属性与方法"></a>(9) 其他属性与方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>globalAlpha</td>
<td>设置或返回绘图的当前 alpha 或透明值</td>
</tr>
<tr>
<td>globalCompositeOperation</td>
<td>设置或返回新图像如何绘制到已有的图像上</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>save()</td>
<td>保存当前环境的状态（可以调用任意多次save方法，类似数组的push）</td>
</tr>
<tr>
<td>restore()</td>
<td>返回之前保存过的路径状态和属性（调用restore方法，上一个保存的状态就从栈中弹出，类似于数组pop）</td>
</tr>
</tbody></table>
<h2 id="4、canvas小案例（时钟）"><a href="#4、canvas小案例（时钟）" class="headerlink" title="4、canvas小案例（时钟）"></a>4、canvas小案例（时钟）</h2><p>(1) 动画效果：<br><img src="/images/canvas/%E6%97%B6%E9%92%9F.gif" alt="时钟"><br>(2) 实现代码：</p>
<pre><code>  &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
      &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;title&gt;时钟&lt;/title&gt;
        &lt;style&gt;
            html,
            body &#123;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            &#125;
            body &#123;
                display: flex;
                justify-content: center;
                align-items: center;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id=&quot;clock&quot; height=&quot;250px&quot; width=&quot;250px&quot;&gt;&lt;/canvas&gt;
        &lt;script&gt;
            // 时钟
            let dom = document.getElementById(&#39;clock&#39;);
            let ctx = dom.getContext(&#39;2d&#39;);
            let width = ctx.canvas.width;
            let height = ctx.canvas.height;
            let r = width / 2;
            // 绘制时钟，定义计时器对其进行实时刷新
            draw();
            setInterval(draw, 1000);

            //绘制时钟圆环
            function drawBackground() &#123;
                ctx.save();
                ctx.translate(r, r);
                ctx.beginPath();
                ctx.lineWidth = 10;
                ctx.arc(0, 0, r - ctx.lineWidth / 2, 0, 2 * Math.PI, false);
                ctx.stroke();
            &#125;
            // 绘制时间数字
            function drawNumber() &#123;
                let hourNumbers = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2];
                hourNumbers.map(function (number, i) &#123;
                    let rad = 2 * Math.PI / 12 * i;
                    let x = Math.cos(rad) * (r - 30);
                    let y = Math.sin(rad) * (r - 30);
                    ctx.textAlign = &#39;center&#39;;
                    ctx.textBaseline = &#39;middle&#39;;
                    ctx.font = 16 + &quot;px Arial&quot;;
                    ctx.fillText(number, x, y)
                &#125;);
                ctx.stroke();
            &#125;
            // 绘制刻度
            function drawDots() &#123;
                let hourNumbers = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2];
                for (let i = 0; i &lt; 60; i++) &#123;
                    let rad = 2 * Math.PI / 60 * i;
                    let x = Math.cos(rad) * (r - 16);
                    let y = Math.sin(rad) * (r - 16) + 1;
                    ctx.textAlign = &#39;center&#39;;
                    ctx.textBaseline = &#39;middle&#39;;
                    ctx.font = 18 + &quot;px Arial&quot;;
                    if (i % 5 == 0) &#123;
                        ctx.fillStyle = &#39;black&#39;;
                    &#125; else &#123;
                        ctx.fillStyle = &#39;#d1d1d1&#39;;
                    &#125;
                    ctx.fillText(&#39; • &#39;, x, y)
                &#125;
                ctx.stroke();
            &#125;
            // 绘制时针
            function drawHour(hour, minute) &#123;
                ctx.save();
                ctx.beginPath();
                let rad = 2 * Math.PI / 12 * hour;
                let mrad = 2 * Math.PI / 12 / 60 * minute;
                ctx.rotate(rad + mrad);
                ctx.lineWidth = 6;
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -r / 2);
                ctx.lineCap = &#39;round&#39;;
                ctx.stroke();
                ctx.restore();
            &#125;
            // 绘制分针
            function drawMinute(minute, second) &#123;
                ctx.save()
                ctx.beginPath();
                let rad = 2 * Math.PI / 60 * minute;
                let mrad = 2 * Math.PI / 60 / 60 * second;
                ctx.rotate(rad + mrad);
                ctx.lineWidth = 4;
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -r / 2 - 10);
                ctx.lineCap = &#39;round&#39;;
                ctx.stroke();
                ctx.restore();
            &#125;
            // 绘制秒针
            function drawSecond(second) &#123;
                ctx.save();
                ctx.beginPath();
                let rad = 2 * Math.PI / 60 * second;
                ctx.rotate(rad);
                ctx.lineWidth = 2;
                ctx.moveTo(0, 10);
                ctx.lineTo(0, -r / 2 - 20);
                let gnt1 = ctx.createLinearGradient(0, 0, 0, -r / 2 - 20);
                gnt1.addColorStop(0, &#39;red&#39;);
                gnt1.addColorStop(1, &#39;rgb(250, 94, 94)&#39;);
                ctx.strokeStyle = gnt1;
                ctx.lineCap = &#39;round&#39;;
                ctx.stroke();
                ctx.restore();
            &#125;
            // 主函数-绘制时钟
            function draw() &#123;
                ctx.clearRect(0, 0, 300, 300);
                let now = new Date();
                let hour = now.getHours() &lt; 10 ? &#39;0&#39; + now.getHours() : now.getHours();
                let minute = now.getMinutes() &lt; 10 ? &#39;0&#39; + now.getMinutes() : now.getMinutes();
                let second = now.getSeconds() &lt; 10 ? &#39;0&#39; + now.getSeconds() : now.getSeconds();
                drawBackground();
                drawNumber();
                drawDots();
                drawHour(hour, minute);
                drawMinute(minute, second);
                drawSecond(second);
                ctx.restore();
            &#125;
        &lt;/script&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML(5)概述</title>
    <url>/2020/09/14/html/HTML-5-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>HTML称为超文本标记语言（Hyper Text Markup Language），用来描述网页文档内容的含义和结构。</p>
<h2 id="1、标记语言和编程语言"><a href="#1、标记语言和编程语言" class="headerlink" title="1、标记语言和编程语言"></a>1、标记语言和编程语言</h2><p>&emsp;&emsp;标记语言，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的文字编码。标记语言是一套标记标签，HTML 文档使用标记标签来描述网页。HTML 文档包含 HTML 标签和纯文本。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释对应的内容。</p>
<p>&emsp;&emsp;编程语言，是一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行为。即编写语言是与计算机进行交互，是计算机执行相应计算的语言。例如Python、C、Java等程序语言。</p>
<h2 id="2、HTML-lt-DOCTYPE-gt"><a href="#2、HTML-lt-DOCTYPE-gt" class="headerlink" title="2、HTML &lt;!DOCTYPE&gt;"></a>2、HTML &lt;!DOCTYPE&gt;</h2><p>&emsp;&emsp;&lt;!DOCTYPE&gt;用来申明浏览器按照那个HTML版本来解析文档。它没有结束标签，对大小写不敏感，要写在文档第一行才有效；否则相当于没有这个申明。当没有这个申明时，支持HTML5的浏览器默认是&lt;!DOCTYPE html&gt;。特别的，HTML4及以前的版本，标记语言基于SGML，在申明HTML版本时，还需要申明DTD（文档类型定义）来告诉浏览器按照那个模式来解析HTML文档。</p>
<h2 id="3、常用标签"><a href="#3、常用标签" class="headerlink" title="3、常用标签"></a>3、常用标签</h2><p>&emsp;&emsp;HTML 标签（也称HTML元素）是由尖括号包围的关键词, 标签通常是成对出现的。标签对中第一个便签是开始标签（开放标签），第二个标签是结束标签（闭合标签）。大多数HTML元素可拥有相应的描述属性，也可与其他HTML元素进行嵌套。<u>HTML标签对大小写不明感，推荐小写。</u></p>
<p>&emsp;&emsp;<u>浏览器会自动地在标题的前后添加空行。</u>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。</p>
<p>&emsp;&emsp;浏览器在显示页面时，会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。代码中的所有连续的换行（br）也被显示为一个空格。</p>
<p>&emsp;&emsp;段落（p）的行数依赖于浏览器窗口的大小。如果调节浏览器窗口的大小，将改变段落中的行数。</p>
<h4 id="1-基础标签"><a href="#1-基础标签" class="headerlink" title="(1) 基础标签"></a>(1) 基础标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;html&gt;</td>
<td>定义HTML文档结构</td>
</tr>
<tr>
<td>&lt;body&gt;</td>
<td>定义文档主体内容</td>
</tr>
<tr>
<td>&lt;h1&gt;…&lt;h6&gt;</td>
<td>定义HTML标题</td>
</tr>
<tr>
<td>&lt;p&gt;</td>
<td>定义段落</td>
</tr>
<tr>
<td>&lt;br&gt;</td>
<td>定义简单的换行（不产生一个新段落的情况下进行换行）</td>
</tr>
<tr>
<td>&lt;hr&gt;</td>
<td>定义水平线</td>
</tr>
</tbody></table>
<h4 id="2-格式化标签"><a href="#2-格式化标签" class="headerlink" title="(2) 格式化标签"></a>(2) 格式化标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;strong&gt;</td>
<td>语气更为强烈的文本（粗体，与b标签表现形式类似）</td>
</tr>
<tr>
<td>&lt;cite&gt;</td>
<td>引用</td>
</tr>
<tr>
<td>&lt;code&gt;</td>
<td>代码文本 ，不保留多余的空格和折行，需要则可与pre标签结合使用</td>
</tr>
<tr>
<td>&lt;del&gt;</td>
<td>定义删除文本（中划线）</td>
</tr>
<tr>
<td>&lt;em&gt;</td>
<td>强调文本（斜体，与i标签表现形式类似）</td>
</tr>
<tr>
<td>&lt;ins&gt;</td>
<td>插入文本（下划线）</td>
</tr>
<tr>
<td>&lt;kbd&gt;</td>
<td>键盘文本</td>
</tr>
<tr>
<td>&lt;mark&gt;</td>
<td>(HTML5新增) 有记号的文本（黄色背景）</td>
</tr>
<tr>
<td>&lt;meter&gt;</td>
<td><u>(HTML5新增) 预定义范围内的度量（进度条形式）</u></td>
</tr>
<tr>
<td>&lt;pre&gt;</td>
<td>(HTML5新增) 预格式文本（特殊符号会被转化为符号实体）</td>
</tr>
<tr>
<td>&lt;progress&gt;</td>
<td>(HTML5新增) 任何类型的任务的进度（进度条）</td>
</tr>
<tr>
<td>&lt;q&gt;</td>
<td>短引用（文本加上双引号）</td>
</tr>
<tr>
<td>&lt;blockquote&gt;</td>
<td>长的引用（文本整体进行缩进）</td>
</tr>
<tr>
<td>&lt;address&gt;</td>
<td>地址（斜体）</td>
</tr>
<tr>
<td>&lt;abbr&gt;</td>
<td>缩写</td>
</tr>
<tr>
<td>&lt;ruby&gt;</td>
<td>(HTML5新增) ruby注释</td>
</tr>
<tr>
<td>&lt;rt&gt;</td>
<td>显示中文注音或字符（嵌套在ruby元素内部）</td>
</tr>
<tr>
<td>&lt;rp&gt;</td>
<td>显示浏览器不支持ruby显示的内容（嵌套在ruby元素内部）</td>
</tr>
<tr>
<td>&lt;small&gt;</td>
<td>小号字体文本</td>
</tr>
<tr>
<td>&lt;sub&gt;</td>
<td>上标文本</td>
</tr>
<tr>
<td>&lt;sup&gt;</td>
<td>下标文本</td>
</tr>
</tbody></table>
<h4 id="3-表单标签"><a href="#3-表单标签" class="headerlink" title="(3) 表单标签"></a>(3) 表单标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;form&gt;</td>
<td>定义提供用户输入的HTML表单</td>
</tr>
<tr>
<td>&lt;input&gt;</td>
<td>定义输入控件</td>
</tr>
<tr>
<td>&lt;textarea&gt;</td>
<td>定义多行文本输入控件</td>
</tr>
<tr>
<td>&lt;button&gt;</td>
<td>定义按钮</td>
</tr>
<tr>
<td>&lt;select&gt;</td>
<td>定义下拉选择列表</td>
</tr>
<tr>
<td>&lt;optgroup&gt;</td>
<td>定义下拉列表相关选项组合</td>
</tr>
<tr>
<td>&lt;option&gt;</td>
<td>定义下拉列表中的选项</td>
</tr>
<tr>
<td>&lt;label&gt;</td>
<td>定义input元素标注</td>
</tr>
<tr>
<td>&lt;fieldset&gt;</td>
<td>定义围绕表单中元素的边框</td>
</tr>
<tr>
<td>&lt;legend&gt;</td>
<td>定义fieldset元素标题</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;input常用输入限制属性：</em><br><em>&emsp;&emsp;&emsp;accept、autocomplate、autofocus、value、checked、multiple、readonly、disabled、size、maxlength、min、max、<u>pattern(规定用于验证输入字段的模式，模式指的是正则表达式)</u>、required、size、step、placeholder、width…</em></p>
<p><em>&emsp;&emsp;&emsp;input type取值：</em><br><em>&emsp;&emsp;&emsp; text、password、file、hidden、reset、submit、radio、checkbox、button、number、date、<u>color</u>、range、month、week、time、datetime(IE、Firefox 或者 Chrome 不支持)、datetime-local、email、search、tel、url、<u>image（定义图像形式的按钮）</u>…</em></p>
<h4 id="4-图像标签"><a href="#4-图像标签" class="headerlink" title="(4) 图像标签"></a>(4) 图像标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;img&gt;</td>
<td>定义图像（alt 属性用来为图像定义一串预备的可替换的文本）</td>
</tr>
<tr>
<td><u>&lt;map&gt;</u></td>
<td>定义映射图像</td>
</tr>
<tr>
<td><u>&lt;area&gt;</u></td>
<td>定义图像地图内部区域（嵌套在map元素内部）</td>
</tr>
<tr>
<td>&lt;canvas&gt;</td>
<td>(HTML5新增) 定义图形</td>
</tr>
<tr>
<td>&lt;figure&gt;</td>
<td>(HTML5新增) 定义媒介内容的分组，以及他们的标题</td>
</tr>
<tr>
<td>&lt;figcaption&gt;</td>
<td>(HTML5新增) 定义figure元素的标题</td>
</tr>
</tbody></table>
<h4 id="5-音频视频标签"><a href="#5-音频视频标签" class="headerlink" title="(5) 音频视频标签"></a>(5) 音频视频标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;audio&gt;</td>
<td>(HTML5新增) 定义声音内容</td>
</tr>
<tr>
<td>&lt;source&gt;</td>
<td>(HTML5新增) 定义媒介源（嵌套在audio标签内部）</td>
</tr>
<tr>
<td>&lt;video&gt;</td>
<td>(HTML5新增) 定义视频</td>
</tr>
<tr>
<td><u>&lt;track&gt;</u></td>
<td>(HTML5新增) 定义媒体播放器的文本轨道（嵌套在video标签内部）</td>
</tr>
</tbody></table>
<h4 id="6-链接标签"><a href="#6-链接标签" class="headerlink" title="(6) 链接标签"></a>(6) 链接标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;a&gt;</td>
<td>定义锚</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td>定义文档与外部资源的关系</td>
</tr>
<tr>
<td>&lt;nav&gt;</td>
<td>(HTML5新增) 定义导航链接</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;a标签的常用属性：</em><br><em>&emsp;&emsp;&emsp;1) href 规定链接指向的页面的 URL或者页面某一位置</em><br><em>&emsp;&emsp;&emsp;2) download  (HTML5新增) 使用download，规定被下载的超链接目标名称</em><br><em>&emsp;&emsp;&emsp;3) media (HTML5新增) 规定被链接文档是为何种媒介/设备优化的</em><br><em>&emsp;&emsp;&emsp;4) target 规定在何处打开链接文档</em><br><em>&emsp;&emsp;&emsp;5) type  (HTML5新增) 规定被链接文档的的 MIME 类型</em></p>
<h4 id="7-列表标签"><a href="#7-列表标签" class="headerlink" title="(7) 列表标签"></a>(7) 列表标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;ul&gt;</td>
<td>定义无序列表</td>
</tr>
<tr>
<td>&lt;ol&gt;</td>
<td>定义有序列表</td>
</tr>
<tr>
<td>&lt;li&gt;</td>
<td>定义列表的项目（可嵌套其他HTML元素）</td>
</tr>
<tr>
<td>&lt;dl&gt;</td>
<td>定义列表</td>
</tr>
<tr>
<td>&lt;dt&gt;</td>
<td>定义列表中的项目</td>
</tr>
<tr>
<td>&lt;dd&gt;</td>
<td>定义列表中的项目描述</td>
</tr>
</tbody></table>
<h4 id="8-表格标签"><a href="#8-表格标签" class="headerlink" title="(8) 表格标签"></a>(8) 表格标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;table&gt;</td>
<td>定义表格</td>
</tr>
<tr>
<td>&lt;caption&gt;</td>
<td>定义表格标题</td>
</tr>
<tr>
<td>&lt;th&gt;</td>
<td>定义表格中的表头单元格</td>
</tr>
<tr>
<td>&lt;tr&gt;</td>
<td>定义表格中的行</td>
</tr>
<tr>
<td>&lt;td&gt;</td>
<td>定义表格中的单元格</td>
</tr>
<tr>
<td>&lt;thead&gt;</td>
<td>定义表格中的表头内容</td>
</tr>
<tr>
<td>&lt;tbody&gt;</td>
<td>定义表格中的主体内容</td>
</tr>
<tr>
<td>&lt;tfoot&gt;</td>
<td>定义表格中的表注内容（脚注）</td>
</tr>
<tr>
<td>&lt;col&gt;</td>
<td>定义表格中一个和多个列属性</td>
</tr>
<tr>
<td>&lt;colgroup&gt;</td>
<td>定义表格中供格式化的列组</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;表格标签的常用属性：</em><br><em>&emsp;&emsp;&emsp;1) table border（边框）、background（表格背景）、cellpadding（单元格边距）、cellspacing（单元格间距）、frame（框架-控制表格边框）</em><br><em>&emsp;&emsp;&emsp;2) th/td colspan（跨列）、rowspan（跨行）、background（单元格背景）、align（单元格对齐方式</em><br><em>&emsp;&emsp;&emsp;注: 空的单元格的边框不会显示，可使用空格字符”&amp;nbsp;” 处理没有内容的单元格显示边框；单元格内可嵌套其他HTML元素</em></p>
<h4 id="9-布局标签"><a href="#9-布局标签" class="headerlink" title="(9) 布局标签"></a>(9) 布局标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;style&gt;</td>
<td>定义文档的样式信息</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td>定义资源引用</td>
</tr>
<tr>
<td>&lt;div&gt;</td>
<td>定义文档中的节点，可用于组合其他 HTML 元素的容器（块级元素代表）</td>
</tr>
<tr>
<td>&lt;span&gt;</td>
<td>定义文档中的节点（内联元素代表）</td>
</tr>
<tr>
<td>&lt;header&gt;</td>
<td>(HTML5新增) 定义section或page的页眉</td>
</tr>
<tr>
<td>&lt;footer&gt;</td>
<td>(HTML5新增) 定义section或page的页脚</td>
</tr>
<tr>
<td>&lt;section&gt;</td>
<td>(HTML5新增) 定义section</td>
</tr>
<tr>
<td>&lt;article&gt;</td>
<td>(HTML5新增) 定义文章</td>
</tr>
<tr>
<td>&lt;aside&gt;</td>
<td>(HTML5新增) 定义页面内容之外的内容</td>
</tr>
<tr>
<td>&lt;details&gt;</td>
<td>(HTML5新增) 定义用户可查看或隐藏的额外细节</td>
</tr>
<tr>
<td>&lt;summary&gt;</td>
<td>(HTML5新增) 定义 details 元素的可见标题</td>
</tr>
</tbody></table>
<h4 id="10-元信息标签"><a href="#10-元信息标签" class="headerlink" title="(10) 元信息标签"></a>(10) 元信息标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;head&gt;</td>
<td>定义关于文档的信息</td>
</tr>
<tr>
<td>&lt;meta&gt;</td>
<td>定义HTML文档的元信息（name 和 content 描述页面的内容）</td>
</tr>
<tr>
<td>&lt;base&gt;</td>
<td>定义页面所有链接的默认地址或默认目标</td>
</tr>
</tbody></table>
<h4 id="11-编程标签"><a href="#11-编程标签" class="headerlink" title="(11) 编程标签"></a>(11) 编程标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;script&gt;</td>
<td>定义客户端脚本<u>（HTML5已不支持type属性）</u></td>
</tr>
<tr>
<td>&lt;noscript&gt;</td>
<td>针对不支持脚本的客户端的替代内容（比如提示）</td>
</tr>
<tr>
<td>&lt;embed&gt;</td>
<td>(HTML5新增) 为外部应用（非HTML定义容器，比如插入音频），最好插入的音频的方法：HTML5 audio + embed（或者引入第三方播放器）</td>
</tr>
<tr>
<td>&lt;object&gt;</td>
<td>定义嵌入的对象（支持HTML助手（插件），比如插入视频），最好插入视频的方法：HTML5 video + object + embed</td>
</tr>
<tr>
<td>&lt;param&gt;</td>
<td>定义嵌入对象的参数</td>
</tr>
</tbody></table>
<h4 id="12-框架标签"><a href="#12-框架标签" class="headerlink" title="(12) 框架标签"></a>(12) 框架标签</h4><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;frameset&gt;</td>
<td>定义框架结构（rows/columns 的值规定了每行或每列占据屏幕的面积）</td>
</tr>
<tr>
<td>&lt;frame&gt;</td>
<td>定义了放置在每个框架中的 HTML 文档（嵌套在frameset元素内部）</td>
</tr>
<tr>
<td>&lt;noframes&gt;</td>
<td>定义不支持frameset客户端的可替换文本</td>
</tr>
<tr>
<td>&lt;iframe&gt;</td>
<td>定义内联的子窗口（框架）</td>
</tr>
</tbody></table>
<h2 id="4、HTML标签属性"><a href="#4、HTML标签属性" class="headerlink" title="4、HTML标签属性"></a>4、HTML标签属性</h2><p>&emsp;&emsp;HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。属性总是以名称/值对的形式出现，属性总是在 HTML 元素的开始标签中规定。HTML标签属性对大小写不明感，推荐小写。</p>
<p>&emsp;&emsp;常用HTML标签属性：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>元素的类名（classname）</td>
</tr>
<tr>
<td>id</td>
<td>元素的唯一 id</td>
</tr>
<tr>
<td>style</td>
<td>元素的行内样式（inline style）</td>
</tr>
<tr>
<td>title</td>
<td>元素的额外信息（可在工具提示中显示）</td>
</tr>
<tr>
<td>contenteditable</td>
<td>(HTML5新增) 元素内容是否可编辑</td>
</tr>
<tr>
<td>data-*</td>
<td>(HTML5新增) 用于存储页面或程序自定义属性数据</td>
</tr>
<tr>
<td>dir</td>
<td>元素中内容的文本方向</td>
</tr>
<tr>
<td>draggable</td>
<td>(HTML5新增) 元素是否可拖动（链接和图像默认是可拖动的）</td>
</tr>
<tr>
<td>hidden</td>
<td>(HTML5新增) 元素仍未或不再相关（浏览器不显示 hidden 属性的元素）</td>
</tr>
<tr>
<td>tabindex</td>
<td>元素的 tab 键选中次序</td>
</tr>
</tbody></table>
<h2 id="5、HTML语义化"><a href="#5、HTML语义化" class="headerlink" title="5、HTML语义化"></a>5、HTML语义化</h2><p>HTML语义化的目的：用更合适的标签做更合适的事情，使文档内容结构化、代码语义化</p>
<p>优点：<br>&emsp;&emsp;(1) 提高代码可读性<br>&emsp;&emsp;(2) 利于浏览器解析与SEO搜索引擎优化<br>&emsp;&emsp;(3) 提高代码可维护性与重用性</p>
<p>提高代码语义化的方法：<br>&emsp;&emsp;(1) 减少使用没有语义的标签，例如div、span等<br>&emsp;&emsp;(2) 减少使用纯样式标签，例如b、i等<br>&emsp;&emsp;(3) 表单使用fieldset包裹；使用legend添加标题；使用label标签为input添加标注<br>&emsp;&emsp;(4) 表格使用caption添加标题，表头部分用thead、主体部分用tbody、脚注部分用tfoot包裹<br>&emsp;&emsp;(5) img元素附带alt信息，即对图片进行文本说明，当图像无法查看时会显示文本描述</p>
<h2 id="6、网站SEO搜索引擎优化"><a href="#6、网站SEO搜索引擎优化" class="headerlink" title="6、网站SEO搜索引擎优化"></a>6、网站SEO搜索引擎优化</h2><p>SEO目的：为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望搜索引擎能多多我们收录网站，并且在别人进行搜索时网站能排列在搜索结果的前面</p>
<p>实现方式：<br>&emsp;&emsp;(1) 提高网站代码的语义化<br>&emsp;&emsp;(2) 重要内容不使用JS输出<br>&emsp;&emsp;(3) 网站的标题（title）进行合理设置<br>&emsp;&emsp;(4) 对关键字、描述精心设计</p>
<pre><code>  &lt;meta name=&quot;description&quot; content=&quot;...&quot;&gt;
  &lt;meta name=&quot;keywords&quot; content=&quot;...&quot;&gt;
</code></pre>
<h2 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h2><h4 id="1-URL-统一资源定位器"><a href="#1-URL-统一资源定位器" class="headerlink" title="(1) URL-统一资源定位器"></a>(1) URL-统一资源定位器</h4><p>&emsp;&emsp;URL （Uniform Resource Locator）也被称为网址，由域名或IP地址、端口、路径等遵循一定的规则形成。</p>
<pre><code>  scheme://host.domain:port/path/filename
  // scheme - 定义因特网服务的类型。常见的类型http、https、ftp、file
  // host - 定义域主机（http 的默认主机是 www）
  // domain - 定义因特网域名，比如 w3school.com.cn
  // :port - 定义主机上的端口号（http 的默认端口号是 80，https的默认端口号443）
  // path - 定义服务器上的路径
  // filename - 定义文档/资源的名称
</code></pre>
<p>&emsp;&emsp;HTML URL 编码：<br>&emsp;&emsp;URL 会将字符转换为可通过因特网传输的格式，只能使用 ASCII 字符集来通过因特网进行发送。编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 编码不能包含空格，通常使用 + 来替换空格。</p>
<h4 id="2-文件路径"><a href="#2-文件路径" class="headerlink" title="(2) 文件路径"></a>(2) 文件路径</h4><p>&emsp;&emsp;文件路径描述了网站文件夹结构中某个文件的位置，文件路径会在链接外部文件时被用到。比如链接网页、图像、视频、样式表、JavaScript等。分为绝对路径（绝对文件路径是指向一个因特网文件的完整 URL）与相对路径（相对路径指向了相对于项目当前页面的文件）。</p>
<h4 id="3-字符实体"><a href="#3-字符实体" class="headerlink" title="(3) 字符实体"></a>(3) 字符实体</h4><p>&emsp;&emsp;在 HTML 中，某些字符是预留的，有特定的含义。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体，用&amp;entity_name（实体名称）或&amp;#entity_number（实体编号）表示。<br>&emsp;&emsp;常用的字符实体：</p>
<table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>实体名称</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td>&amp;nbsp;</td>
<td>&amp;#160;</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt;</td>
<td>&amp;#60;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt;</td>
<td>&amp;#62;</td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td>&amp;quot;</td>
<td>&amp;#34;</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp;</td>
<td>&amp;#38;</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
<td>&amp;times;</td>
<td>&amp;#215;</td>
</tr>
<tr>
<td>/</td>
<td>除号</td>
<td>&amp;divide;</td>
<td>&amp;#247;</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy;</td>
<td>&amp;#169;</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg;</td>
<td>&amp;#174;</td>
</tr>
<tr>
<td>™</td>
<td>商标</td>
<td>&amp;trade;</td>
<td>&amp;#8482;</td>
</tr>
</tbody></table>
<h4 id="4-颜色值"><a href="#4-颜色值" class="headerlink" title="(4) 颜色值"></a>(4) 颜色值</h4><p>&emsp;&emsp; 由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位（Position）与3D坐标轴</title>
    <url>/2020/09/27/css/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88Position%EF%BC%89%E4%B8%8E3D%E5%9D%90%E6%A0%87%E8%BD%B4/</url>
    <content><![CDATA[<p>用于指定一个元素在文档中的定位方式（元素在网页上的位置），对应的属性top，right，bottom 和 left属性则决定了该元素的最终定位的位置。</p>
<h2 id="1、平面空间坐标轴（2D）"><a href="#1、平面空间坐标轴（2D）" class="headerlink" title="1、平面空间坐标轴（2D）"></a>1、平面空间坐标轴（2D）</h2><p>&emsp;&emsp;在CSS平初始坐标系从屏幕左上角向右为X轴，从左上角向下为Y轴。在position定位方式中，其中top、right、bottom和left代表元素距离参考上、右、下，左方向上的距离。</p>
<p><img src="/images/css3/%E5%B9%B3%E9%9D%A2%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="平面空间坐标轴"></p>
<h2 id="2、定位类型"><a href="#2、定位类型" class="headerlink" title="2、定位类型"></a>2、定位类型</h2><p>&emsp;&emsp;position的取值：static、relative、 absolute、fixed，sticky与inherit</p>
<p>&emsp;&emsp;定位元素：是其计算后位置属性为relative、absolute，fixed或sticky的一个元素</p>
<p>&emsp;&emsp;(1) 默认定位(static)：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p>
<p>&emsp;&emsp;(2) 相对定位(relative)：相对于自己最初的位置进行定位，相对位置的坐标参考系是以自己定位前在文档流的位置(x, y)作为原点(0, 0)。<u>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</u>而且position: relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p>
<p><img src="/images/css3/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D(relative).png" alt="相对定位(relative)"></p>
<p>&emsp;&emsp;(3) 绝对定位(absolute/fixed)：绝对定位的元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位父级(祖先)元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。特别的，fixed绝对定位（固定定位）是相对于浏览器窗口（viewport）进行定位，元素的位置在屏幕滚动时不会改变。元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p>
<p><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(absolute).png" alt="绝对定位(absolute)"><br><img src="/images/css3/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D(fixed).png" alt="绝对定位(fixed)"></p>
<p>&emsp;&emsp;(4) 粘性定位(sticky)：元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。粘性定位表现为相对定位和固定定位叠加的效果。元素在跨越特定阈值前为相对定位(relative)，之后为固定定位(fixed)。</p>
<p><img src="/images/css3/%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D(sticky).png" alt="粘性定位(sticky)"></p>
<h2 id="3、三维空间坐标轴（3D）"><a href="#3、三维空间坐标轴（3D）" class="headerlink" title="3、三维空间坐标轴（3D）"></a>3、三维空间坐标轴（3D）</h2><p>&emsp;&emsp;CSS中3D初始坐标系，其XYZ轴的正方向分别是：向右、向下、向屏幕外。如下图：</p>
<p><img src="/images/css3/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4.png" alt="三维空间坐标轴"></p>
<p>&emsp;&emsp;对一个元素设置属性 transform-style为preserve-3d ，便可对其进行3D变换，有translateX()，translateY()，translateZ()平移方法以及rotateX()，rotateY()，rotateZ()等旋转方法。一般会对元素设置 perspective 属性来调整元素观测的视角。默认旋转中心为左上角（0,0）（如上图），可通过transform-origin对旋转中心进行移动。<u>当transform使用多个变换函数时，每一个变换函数不仅改变了元素，同时也会改变和元素关联的transform坐标系，当变换函数依次执行时，后一个变换函数总是基于前一个变换后的新transform坐标系执行，所有要注意变换函数的顺序。</u><br>&emsp;&emsp;(1) 对于平移，参照对应坐标轴方向进行相应的平移变换即可。<br>&emsp;&emsp;(2) 对于旋转，先要判断旋转方向，正对某一轴正，其顺时针方向就是该轴旋转的方向，或者采用左手法则判断旋转方向（即左手握住旋转轴，竖起拇指指向旋转轴正方向，其余手指卷曲方向为旋转正方向）；再根据旋转中心的位置进行相应的旋转变换。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS动画（过渡、关键帧、3次贝塞尔曲线）</title>
    <url>/2020/11/26/css/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<p>CSS 动画可以在不借助 Javascript 的情况下做出一些相对简单的动画效果，例如缩放、移动、2D/3D旋转等。CSS动画有浏览器控制，表现得很流畅。 <u>CSS动画的时序函数主要为3次贝塞尔曲线。</u></p>
<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>&emsp;&emsp;CSS动画是由浏览器按照一定的频率一帧一帧的绘制的，CSS实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新动画，不依赖于主线程，所以<u>CSS动画是很流畅的</u>。CSS过渡、关键帧相关知识在前面的文章<a href="/2020/09/24/css/CSS-3-%E6%A6%82%E8%BF%B0">《CSS(3)概述》</a>里已经讲到，这里摘抄相关知识如下：</p>
<p>&emsp;&emsp;2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你更改一个元素变形的原点(该属性必须与transform属性一同使用)</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript来完成</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线(时序函数)，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>&emsp;&emsp;您可以改变任意多的样式任意多的次数。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<pre><code>  @keyframes name
  &#123;
    0%   &#123; // 状态1 &#125;
    ...
    xx%  &#123; // 状态x &#125;
    ...
    100% &#123; // 状态n &#125;
  &#125;
  // 自定义动画的使用
  animation: name duration timing-function delay iteration-count direction;

  // timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)
  // iteration-count的取值: n(次数)、infinite
  // animation-direction的取值: normal、alternate
</code></pre>
<br/>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容应添加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>对应@keyframes定义的动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<strong>CSS动画时序函数(timing-function属性的值）：</strong><br>&emsp;&emsp;CSS动画的时序函数主要为3次贝塞尔曲线。3次贝塞尔曲线由4点个组成，CSS3贝塞尔曲线起点是 (0,0) ，终点是(1,1)，代表动画执行时间到达时动画刚好执行完成。所以CSS中的cubic-bezier()函数只需要传入其他的2个端点值（x1,y1,x2,y2）即可。</p>
<p>&emsp;&emsp;timing-function取值分别对应的贝尔塞曲线函数为：</p>
<p><img src="/images/css3/timing-function%E5%8F%96%E5%80%BC.png" alt="timing-function取值"></p>
<p><em>[注] 以上图片制作于<a href="https://cubic-bezier.com/">https://cubic-bezier.com/</a>，这是一个贝尔塞曲线在线设置与查看的网站，其中紫色的点表示（x1, y1）,蓝色的点表示（x2, y2）。</em></p>
<p>&emsp;&emsp;<strong>其中横轴（x轴）表示时间，纵轴（y轴）表示随着时间推移动画完成情况，曲线的斜率表现为为动画完成的快慢（比如移动速度等）。浏览器会根据时序函数对动画完成情况进行对应的更新（即由时序函数来确定此刻动画中各元素的状态）。</strong>根据图片，可以看到：linear随着时间推移，同一时间间隔动画的完成进度一致，即匀速的完成动画；ease-in先慢后快，ease-out先快后慢；ease-in-out则开始和结束较慢，中间动画完成的进度较快。<br>&emsp;&emsp;特别的，我们也可以使用cubic-bezier自定义时序函数，例如cubic-bezier(.92 ,-0.44, .04, 1.44)，可以看到随着时间的推移，完成情况最先是反向的且完成情况小于0，先快后慢；到最慢时然后完成情况变为正向，呈现先慢后快再慢（类似于ease-in-out），到最慢时此时动画的完成情况是大于1的（也就是多完成了一部分），此时完成情况的方向又变为反向的，先慢后快直到动画完成。</p>
<p>&emsp;&emsp;将cubic-bezier(.92 ,-0.44, .04, 1.44)时序用到transition属性中（时序函数一般要求写在过渡时间的后面）：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
    .ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
      transition: all 3s cubic-bezier(.92, -0.44, .04, 1.44);
    &#125;
    .box:hover .ball &#123;
      margin-left: calc(100% - 50px);
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;具体动画的效果：</p>
<p><img src="/images/css3/%E8%BF%90%E5%8A%A8%E7%9A%84%E5%B0%8F%E7%90%83.gif" alt="运动的小球"></p>
<p>&emsp;&emsp;如代码所示，外层class为box的div宽300px，里面放置一个直径为50px的小球，初始位置为外层div里的最左侧。设置外层div变为hover状态时，小球向右移动到外层div里的最右侧的过渡，过渡时间3s，过渡的时序函数用我们自定义贝塞尔曲线。可以看到小球先向左（反方向）由快到慢的移动，移出了外层div左侧一部分；在向右由慢到快再到慢的移动，特别是中间移动速度极快，停下来时也已移出了外层div最右侧一部分；然后在向左（反方向）由慢到快直至小球停到外层div里的最右侧。外层div失去焦点时小球的移动方式与获得焦点相反。可以看到小球移动的状态与设置时序函数的贝塞尔曲线的状态一致。</p>
<p>&emsp;&emsp;在这里再做一些dome实例的补充：</p>
<h4 id="1）旋转的筛子"><a href="#1）旋转的筛子" class="headerlink" title="1）旋转的筛子"></a>1）旋转的筛子</h4><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AD%9B%E5%AD%90.gif" alt="旋转的筛子"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .cube &#123;
      width: 100px;
      height: 100px;
      perspective: 500px;
      margin: 100px;
      transform-style: preserve-3d;
      animation: rotate 20s infinite;
      animation-timing-function: linear;
    &#125;
    .cube div &#123;
      position: absolute;
      transition: all .4s;
      width: 100px;
      height: 100px;
      opacity: 0.9;
    &#125;
    .cube div img &#123;
      width: 100%;
      height: 100%;
    &#125;
    .front &#123;
      transform: translateZ(50px);
    &#125;
    .back &#123;
      transform: translateZ(-50px);
    &#125;
    .left &#123;
      transform: rotateY(90deg) translateZ(50px);
    &#125;
    .right &#123;
      transform: rotateY(-90deg) translateZ(50px);
    &#125;
    .top &#123;
      transform: rotateX(90deg) translateZ(50px);
    &#125;
    .bottom &#123;
      transform: rotateX(-90deg) translateZ(50px);
    &#125;
    @keyframes rotate &#123;
      from &#123;
        transform: rotateX(0deg) rotateY(0deg);
      &#125;
      to &#123;
        transform: rotateX(360deg) rotateY(360deg);
      &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;cube&quot;&gt;
    &lt;div class=&quot;front&quot;&gt;&lt;img src=&quot;img/3.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;back&quot;&gt;&lt;img src=&quot;img/5.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;img src=&quot;img/2.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;img src=&quot;img/4.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;top&quot;&gt;&lt;img src=&quot;img/1.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;bottom&quot;&gt;&lt;img src=&quot;img/6.jpg&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：先在外层class为box的div上设置了观测视角。再对class为cube的div元素设置了transform-style: preserve-3d，使其可以进行3D变换。再对其内部的6个面（实现方式不止代码所示的一种，变换过程中旋转与平移先后顺序不同代码就会不同。这里用图片简单表示骰子的1-6，通过Flex或是Grid布局实现骰子6个面的布局也比较容易）进行相应的3D平移与旋转，布局成为一个立方体。再对class为cube的div元素添加了自定义的关键帧rotate旋转动画。</p>
<h4 id="2）边框滚动动画"><a href="#2）边框滚动动画" class="headerlink" title="2）边框滚动动画"></a>2）边框滚动动画</h4><p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E8%BE%B9%E6%A1%86%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB.gif" alt="边框滚动动画"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .outer-box &#123;
      width: 300px; height: 100px; box-sizing: border-box; padding: 2px;
      background: repeating-linear-gradient(45deg, #000, #000 3px, transparent, #000 8px);
      animation: line 1s infinite linear;
    &#125;
    .inner-box &#123;
      width: 100%; height: 100%;
      background-color: #fff;
      display: flex; justify-content: center; align-items: center;
    &#125;
    @keyframes line &#123;
      0% &#123; background-position: 1px -1px; &#125;
      100% &#123; background-position: 12px -12px; &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;outer-box&quot;&gt;
    &lt;div class=&quot;inner-box&quot;&gt;- (^_^) -&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：这里将外层div设置为渐变的背景图片，2px内间距。内部div宽高100%，背景为白色，此时只见外层div出现类似于虚线边框的样式。加入自定义动画line，线性向右上方移动背景图片，便出现了边框滚动的效果。</p>
<h4 id="3）元素沿着不规则路径运动"><a href="#3）元素沿着不规则路径运动" class="headerlink" title="3）元素沿着不规则路径运动"></a>3）元素沿着不规则路径运动</h4><p>&emsp;&emsp;这里我们会用到offset-path等相关属性来实现，这个属性相对较新（要注意浏览器兼容），先介绍常用的属性：<br>&emsp;&emsp;<strong>offset-path：指定元素要遵循的运动路径以及元素位置。</strong>取值为：<br>&emsp;&emsp;&emsp;&emsp;ray() ：定义的一条路径<br>&emsp;&emsp;&emsp;&emsp;url()：引用SVG图片的URL<br>&emsp;&emsp;&emsp;&emsp;形状：circle()、 ellipse()、inset()、polygon()等<br>&emsp;&emsp;&emsp;&emsp;path()：用SVG坐标语法定义的路径字符串<br>&emsp;&emsp;<strong>offset-distance：指定要放置的元素沿路径偏移的位置（px，%）。</strong><br>&emsp;&emsp;<strong>offset-rotate：元素运动的角度（deg），默认auto，表示沿当前路径的切线方向前进。</strong></p>
<p>&emsp;&emsp;先看动画效果：</p>
<p><img src="/images/css3/%E4%B8%8D%E8%A7%84%E5%88%99%E8%BF%90%E5%8A%A8.gif" alt="不规则运动"></p>
<p>&emsp;&emsp;代码实现：</p>
<pre><code>  &lt;style&gt;
    .box &#123; position: relative; &#125;
    .car &#123;
      offset-path: path(&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot;);
      animation: move 3s linear infinite;
      position: absolute; width: 50px; height: auto;
    &#125;
    @keyframes move &#123;
      100% &#123; offset-distance: 100%; &#125;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;img/car.png&quot; width=&quot;40&quot; height=&quot;43&quot; class=&quot;car&quot;&gt;
    &lt;svg width=&quot;290px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
      &lt;path d=&quot;M10 80 Q 52.5 10, 135 80 T 280 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot; /&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：这里路径使用SVG图片，设置汽车的图片offset-path偏移路径为SVG中path字符串一致。自定义动画move使汽车每3s沿SVG路径进行偏移直至100%，便出现了汽车元素沿不规则路径移动的效果。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS预解析、作用域、执行上下文、this</title>
    <url>/2020/12/05/javascript/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/</url>
    <content><![CDATA[<p>这部分是JavaScript比较基础的部分。JS代码运行前的极短时间内会进行语法分析、代码预解析以及解释执行。其中预解析最重要。分为全局预解析和局部预解析，全局预解析发生在页面加载完成时执行，而局部预解析发生在函数执行的前一刻(在极短时间内完成)。会进行变量与函数申明（变量提升）、生成执行上下文（作用域）等工作。</p>
<h2 id="1、作用域（链）"><a href="#1、作用域（链）" class="headerlink" title="1、作用域（链）"></a>1、作用域（链）</h2><p>&emsp;&emsp;JavaScript采用词法作用域，作用域在代码定义时就确定，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限，执行时并且不会改变（作用域访问的变量是编写代码的结构确定的）。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文对象构成的链表就叫做作用域链。函数的原型（prototype）属性存在[[Scopes]]属性保存着当前函数的作用域链信息。</p>
<p>&emsp;&emsp;作用域分为全局作用域、函数(局部)作用域、块级作用域（ES6引入）。<br>&emsp;&emsp;① 在代码中任何地方都能访问到的对象拥有全局作用域。全局作用域的变量是全局对象(window)的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，<u>但加上全局对象，可以提供搜索效率。</u><br><em>&emsp;&emsp;[注] 隐式的申明变量，或在最外层函数外部申明的变量，以及给window对象添加的属性都是全局变量，<strong>隐式申明的变量不存在变量提升</strong></em></p>
<pre><code>  function foo(a) &#123;
  console.log(b) // Uncaught ReferenceError: b is not defined (异常，代码停止执行，变量b没有提升)
    b = a
  &#125;
  foo(2)
  console.log(b) // 未执行

  function foo(a) &#123;
    b = a
  &#125;
  foo(2)
  console.log(b) // 2
</code></pre>
<p>&emsp;&emsp;② 在函数内部用var关键字申明的变量，函数的参数会存在于该函数的局部作用域中。<br><em>&emsp;&emsp;[注] 局部变量的优先级高于全局变量</em><br>&emsp;&emsp;③ 用let、const申明的变量会存在于块级作用域中。</p>
<h2 id="2、预解析与执行上下文"><a href="#2、预解析与执行上下文" class="headerlink" title="2、预解析与执行上下文"></a>2、预解析与执行上下文</h2><p>&emsp;&emsp;JavaScript代码在执行前的瞬间会存在预解析的阶段，会对代码进行相应的处理，对申明的变量与函数进行变量提升，以及生成对应的执行上下文，执行上下文除了保存代码执行信息外，还会将当前作用域信息也保存在执行上下文中，他们有相应的存储关系。随着代码进行的进行，执行上下文会进行相应的改变，执行上下文是用于跟踪代码的运行情况。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p>
<p>&emsp;&emsp;预解析过程创建执行上下文的步骤：<br>&emsp;&emsp;① 隐式的创建GO（全局上下文）/AO（函数上下文）对象<br>&emsp;&emsp;② 找形参和变量声明，将变量和形参名作为GO/AO的属性名，值为undefined（这个过程也常称为变量提升）<br>&emsp;&emsp;③ 将实参值和形参统一<br>&emsp;&emsp;④ 在函数体里面找函数声明，作为GO/AO的属性，值赋予函数体（这个过程也常称为函数提升）<br><em>&emsp;&emsp;[注] 在全局预解析中，由于全局中没有参数的的概念，所以省去了第2步的找参数。第2步中的找变量申明与第3步实参形参相统一一同处理。GO全局上下文对象，它优于局部预解析AO局部上下文对象的创建与执行</em></p>
<p>&emsp;&emsp;例如下面的代码：</p>
<pre><code>  1  console.log(a) // undefined
  2  console.log(b) // Uncaught ReferenceError: b is not defined
  3  var a = 5
  4  console.log(a) // 5
  5  console.log(test) // undefined
  6  console.log(fn) // function fn () &#123;&#125;
  7  console.log(fn(3)) // 11
  8  var test = function () &#123;
  9     return 10
  10 &#125;
  11 function fn(x) &#123;
  12  console.log(a) // undefined
  13  var a = b = 8
  14  var c = 6
  15  return a + x
  16 &#125;
  17 console.log(a) // 5
  18 console.log(b) // 8
  19 console.log(c) // Uncaught ReferenceError: c is not defined
  20 console.log(test()) // 10
</code></pre>
<p>&emsp;&emsp;<strong>上面的代码在执行前的瞬间，会先进行全局预解析。过程如下：（这里只列举了执行上下文中的部分信息）</strong></p>
<p>&emsp;&emsp;(1) 进行全局预解析的第1步：创建全局上下文GO对象</p>
<pre><code>  GO: &#123;
  
  &#125;
</code></pre>
<p>&emsp;&emsp;(2) 进行全局预解析的第2步：找变量声明，将变量作为GO的属性名，值为undefined</p>
<pre><code>  GO: &#123;
    a: undefined,
    test: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(3) 进行全局预解析3步：在函数体里面找函数声明，作为GO的属性，值赋予函数体</p>
<pre><code>  GO: &#123;
    a: undefined,
    test: undefined
    fn: function fn () &#123;&#125;
  &#125;
</code></pre>
<p>&emsp;&emsp;<strong>全局预解析完成，代码开始执行，执行过程如下：</strong><br>&emsp;&emsp;执行第1行，输出a为undefined<br>&emsp;&emsp;执行第2行，因为全局上下文没有申明b变量，所以程序抛出异常：Uncaught ReferenceError: b is not defined<br>&emsp;&emsp;执行第3行，将全局上下文中a赋值为5</p>
<pre><code>  GO:&#123;
    a: 5,
    test: undefined
    fn: function fn () &#123;&#125;
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第4行，输出a为5<br>&emsp;&emsp;执行第5行，输出test为undefined<br>&emsp;&emsp;执行第6行，输出fn为function fn () {}</p>
<p>&emsp;&emsp;<strong>执行第7行，调用fn并传入参数3，在fn执行前瞬间，会进行局部预编译，过程如下：</strong></p>
<p>&emsp;&emsp;(1) 进行局部预解析的第1步： 创建对应的函数上下文AO对象</p>
<pre><code>  AO: &#123;
    
  &#125;
</code></pre>
<p>&emsp;&emsp;(2) 进行局部预解析的第2步：找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined</p>
<pre><code>  AO: &#123;
    x: undefined,
    a: undefined,
    c: undefined
  &#125;
</code></pre>
<p><em>&emsp;&emsp;[注] <u>在第13行’var a = b = 8’，这里隐式的申明了全局变量b，此时应该将变量b添加到GO对象中，</u>此时的GO对象为：</em></p>
<pre><code>  GO: &#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(3) 进行局部预解析第3步：将实参与形参统一</p>
<pre><code>  AO:&#123;
    x: 3,
    a: undefined,
    c: undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;(4) 对于fn函数，进行预解析第4步：在函数体里面找函数声明，作为AO的属性，值赋予函数体<br>&emsp;&emsp;fn函数内无函数申明，AO对象不变</p>
<p>&emsp;&emsp;<strong>fn函数执行前预解析完成，11-16行的<u>函数入栈执行！</u></strong><br>&emsp;&emsp;执行第12行，输出a为undefined（先在当前执行的函数上下文AO的作用域对象中查找变量a，若AO的作用域对象中没有，通过AO中的作用域链，再去全局上下文GO中去查找）<br>&emsp;&emsp;执行第13行，将变量b赋值为8，变量a赋值为8。其中变量b存在于全局上下文GO中，这里的a为当前执行的函数上下文AO中的a，此时的GO、AO对象为：</p>
<pre><code>  GO:&#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: 8
  &#125;
  AO:&#123;
      x: 3,
      a: 8,
      c:undefined
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第14行，将AO中的c变量赋值为6，此时的AO为：</p>
<pre><code>  AO:&#123;
    x: 3,
    a: 8,
    c: 6
  &#125;
</code></pre>
<p>&emsp;&emsp;<strong>执行第15行，计算a+x的值为11，并返回函数调用的地方。所以第7行输出函数fn(3)的执行结果11。<u>函数执行完成，函数出栈，当前执行上下文AO对象被销毁。 </u></strong><br>&emsp;&emsp;执行第8行，将GO中test赋值为function () { return 10 }，此时的GO对象为：</p>
<pre><code>  GO: &#123;
    a: 5,
    test: undefined,
    fn: function fn () &#123;&#125;,
    b: 8
  &#125;
</code></pre>
<p>&emsp;&emsp;执行第17行，输出a为5<br>&emsp;&emsp;执行第18行，输出b为8<br>&emsp;&emsp;执行第19行，因为全局上下文没有申明c变量，所以程序抛出异常：Uncaught ReferenceError: c is not defined<br>&emsp;&emsp;执行第20行，<u>这里调用test()函数与上面调用fn(3)函数类似，执行前也会进行相应的局部预解析，创建对应的AO对象。然后函数入栈执行，</u>这最后函数返回执行结果为10<br>&emsp;&emsp;代码执行完成！</p>
<p><em>&emsp;&emsp;[注] 这里分析比较简单的一段代码的执行过程，这里在函数内部没有函数的申明，也没有异步处理。一般的，如果函数内部存在函数，在内部函数调用时也会进行对应的局部预处理以及入栈执行；如果代码内包含异步逻辑，会把异步逻辑放在异步队列里面进行相应的调度执行。</em><br><em>&emsp;&emsp;[注] 如果在某个作用域中使用了某变量，而该变量并未在对应的（静态）作用域中声明，而在其它作用域（父级）中声明，该变量称为<u>自由变量（即跨域了当前对应的作用域的变量叫做自由变量）。</u></em></p>
<h2 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h2><p>&emsp;&emsp;一个函数和对其周围状态（词法环境）的引用捆绑在一起，这样的组合就是闭包（closure）。闭包让你可以在一个内层函数中访问到其外层函数的作用域（即能够读取其他函数内部变量的函数）。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。<strong>函数就会形成闭包。</strong><u>闭包是由函数以及声明该函数的词法环境组合而成的。</u>该环境包含了这个闭包创建时作用域内的任何局部变量。</p>
<p>&emsp;&emsp;例如下面的代码：</p>
<pre><code>  function add(x) &#123;
    console.log(inner.__proto__)
    function inner(y) &#123;
        return x + y;
    &#125;
    return inner;
  &#125;
  console.log(add(3)(4))

  // 输出
  &#123;constructor: ƒ&#125;
  constructor: ƒ inner(y)
  arguments: null
  caller: null
  length: 1
  name: &quot;inner&quot;
  prototype: &#123;constructor: ƒ&#125;
  __proto__: ƒ ()
  [[FunctionLocation]]: scopes.html:14
  [[Scopes]]: Scopes[2]
  0: Closure (add) &#123;x: 3&#125;
  1: Global &#123;window: Window, self: Window, document: document, name: &quot;&quot;, location: Location, …&#125;
  __proto__: Object

  7
</code></pre>
<p>&emsp;&emsp;上面的代码中：add函数内部定义了inner函数，inner函数可以访问词法环境外部add函数作用域中变量，如这里的形参x。从打印的inner.prototype对象可以看出，在inner函数的作用域链的栈底为Global全局作用域，栈顶为inner函数所在的add函数的作用域，这里形成了Closure闭包。add(3)函数调用后返回的inner(y){ return x + y; }函数(x=3)与inner函数的词法环境形成了闭包，<u>inner函数中保留了对add函数内部变量x的应用，且此时x=3</u>，所以在add(3)(4)继续调用inner函数时返回结果7。</p>
<p><em>&emsp;&emsp;[注] 这里<u>是否形成闭包与内部的inner函数是否返回无关，函数便会形成闭包。</u></em></p>
<h2 id="4、this关键字"><a href="#4、this关键字" class="headerlink" title="4、this关键字"></a>4、this关键字</h2><p>&emsp;&emsp;在绝大多数情况下，<u>函数的调用方式决定了 this 的值（<strong>运行时绑定</strong>）。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同（<strong>与调用方式有关</strong>）。</u>ES5 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。ES2015 引入了箭头函数，箭头函数不提供自身的 this 绑定，此时this 的值将保持为当前闭合词法上下文的值。即函数中this的取值为当前执行上下文（global、function 或 eval）的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。</p>
<p>&emsp;&emsp;① 在全局上下文中，无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。</p>
<pre><code>  console.log(this) // Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;

  &quot;use strict&quot;;
  console.log(this) // Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;
</code></pre>
<p>&emsp;&emsp;② 在函数上下文中，this指向取决于函数被调用的方式：在非严格模式下，this的值不由调用者设置，this指向window。在严格模式下，this指向调用者，若执行前没有设置this的值，也没有作为对象的属性或方法而是直接调用，this为undefined。<br><em>&emsp;&emsp;[注] 可以通过call、apply方法修改this指向的环境。</em></p>
<pre><code>  (function () &#123;
    console.log(this) // Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;
  &#125;())

  &quot;use strict&quot;;
  (function () &#123;
    console.log(this) // undefined
  &#125;())
  
  &quot;use strict&quot;;
  function test() &#123;
    console.log(this) // Window &#123;window: Window, self: Window, document: document, name: &quot;&quot;, …&#125;
  &#125;
  test.apply(window)
</code></pre>
<p>&emsp;&emsp;③ 类上下文中，基类与派生类构造函数constructor()中this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象，所有非静态方法会被添加到this的原型中。在派生类中的构造函数没有初始的this绑定，在构造函数中调用super()才能生成一个this绑定。<u>注意的是，使用super对象时，super 调用父类的方法时，super 会绑定当前子类的 this。</u><br><em>&emsp;&emsp;[注] 静态方法不是this的属性，它们只是类自身的属性。派生类（子类）在super()前调用this会抛出异常(ReferenceError)，派生类不能在调用super前返回，除非没有构造函数或者构造函数返回了对象。</em></p>
<pre><code>  &quot;use strict&quot;;
  class A &#123;
    constructor () &#123;
      console.log(this) // A &#123;&#125;
    &#125;
  &#125;
  new A()

  &quot;use strict&quot;;
  class A &#123;
    constructor () &#123;
      console.log(this)
    &#125;
  &#125;
  class B extends A &#123;
    constructor () &#123;
      console.log(this) // Uncaught ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor
    &#125;
  &#125;
  new B()

  &quot;use strict&quot;;
  class A &#123;
    constructor () &#123;
      console.log(this) // B &#123;&#125;
    &#125;
  &#125;
  class B extends A &#123;
    constructor () &#123;
      super()
      console.log(this) // B &#123;&#125;
    &#125;
  &#125;
  new B()

  // 特别的~
  &quot;use strict&quot;;
  class A &#123;
    constructor () &#123;
      console.log(this)
    &#125;
  &#125;
  class B extends A &#123;
    constructor () &#123;
      return &#123; a: 1 &#125;
    &#125;
  &#125;
  console.log(new B()) // &#123; a: 1 &#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript概述</title>
    <url>/2020/12/03/javascript/JavaScript%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型，单线程的脚本语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态页面信息，而是实时的内容更新，交互式的地图，2D/3D 动画，滚动播放的视频等更加丰富的内容，也能实现用户在网页界面上与服务器相关交互功能</p>
<h2 id="1、语言特性"><a href="#1、语言特性" class="headerlink" title="1、语言特性"></a>1、语言特性</h2><p>&emsp;&emsp;JavaScript是一门动态的、弱类型、基于原型（prototype）的脚本语言。在JavaScript中“一切皆对象”，在这一方面，它比其他的面向对象的语言来得更为彻底。即使作为代码本身载体的函数（function），也是对象。</p>
<h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><h4 id="1-向页面添加JavaScript"><a href="#1-向页面添加JavaScript" class="headerlink" title="1) 向页面添加JavaScript"></a>1) 向页面添加JavaScript</h4><p>&emsp;&emsp;在body标签结束前插入以下script标签引入JavaScript， <u>JavaScript 是区分大小写的</u></p>
<pre><code>  // 方式1：内联JavaScript
  &lt;script&gt;
    ...在此编写JavaScript代码...
  &lt;/script&gt;

  // 方式2：外部引入JavaScript
  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><em>&emsp;&emsp;[注] 在外部引入JS时，在必要的时候（防止加载阻塞页面渲染问题或对多个有依赖关系的脚本对加载顺序有要求），我们需要在&lt;script&gt;标签上加上async或defer修饰符（属性）（这是解决脚本阻塞问题的两种方式）。<u>浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。</u>当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，async 是最理想的选择；<u>defer 属性的脚本将按照在页面中出现的顺序加载，可保证脚本的加载顺序</u></em></p>
<h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2) 变量"></a>2) 变量</h4><p>&emsp;&emsp;变量是用来存储数值的，那么有一个重要的概念需要区分。变量不是数值本身，它们仅仅是一个用于存储数值的容器，JS中使用var、let、const来定义变量</p>
<p>&emsp;&emsp;<strong>构造变量名称（唯一标识符）的通用规则是：</strong><br>&emsp;&emsp;名称可包含字母、数字、下划线和美元符号<br>&emsp;&emsp;名称必须以字母、$或_开头<br>&emsp;&emsp;名称对大小写敏感<br>&emsp;&emsp;保留关键字不能作为变量名称</p>
<pre><code>  var a;
  let b;
  onst C = 100; // 定义常量必须进行初始化，常量一般用大写英文命名
</code></pre>
<p>&emsp;&emsp;变量类型：<br>&emsp;&emsp;值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol<br>&emsp;&emsp;引用数据类型：对象(Object，JavaScript 对象是键值对的容器)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）</p>
<h4 id="3-语句与表达式"><a href="#3-语句与表达式" class="headerlink" title="3) 语句与表达式"></a>3) 语句与表达式</h4><p>&emsp;&emsp;<u>JavaScript区分表达式和语句</u><br>&emsp;&emsp;表达式是输出值的，并且可以写在任何需要一个值的地方，例如函数的参数等。一般来讲，表达式由变量、操作符和约束条件等以能求得有意义的数值（非undefined）为目的排列所得的组合<br>&emsp;&emsp;语句表示执行了一个动作，例如循环控制语句(for、while…)和分支判断语句(if)等。一个程序基本上就是一系列的语句的集合。在JavaScript中需要语句的地方，也可以写入一个表达式。但不能够在需要表达式的地方写入一个语句。我们常用分号分语句，使得可以在一行编写多条语句。<br>&emsp;&emsp;常用运算符：=、+、-、*、/、==、!=、&gt;、&lt;、&amp;&amp;、||、位运算符、……<br>&emsp;&emsp;常用语句：</p>
<pre><code>  // 赋值语句    
  let a = 5, b = 8;
  
  // if条件判断语句
  if (condition1) &#123;
    // 当条件 1 为 true 时执行的代码
  &#125;
  else if (condition2) &#123;
    // 当条件 2 为 true 时执行的代码
  &#125;
  else &#123;
    // 当条件 1 和 条件 2 都不为 true 时执行的代码
  &#125;
  
  // switch分支语句
  switch (n) &#123;
    case 1:
      // 执行代码块 1
      break; // 阻止代码向下一个case执行，有时为了逻辑需要（如累加等），switch语句中不会使用此关键字
    case 2:
      // 执行代码块 2
      break;
    default:
    // 与 case 1 和 case 2 不同时执行的代码
  &#125;
  
  // for、while、do while循环语句（break 语句用于跳出循环，continue 用于跳过循环中的一个迭代）
  for (语句 1; 语句 2; 语句 3)
  &#123;
    // 语句2为真执行的代码块
  &#125;
  while (条件) &#123;
    // 条件为真执行的代码块
  &#125;
  do &#123;
    // 代码块会在条件被测试前执行，代码块至少被执行一次
  &#125; while (条件);
</code></pre>
<h4 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4) 字符串模板"></a>4) 字符串模板</h4><p>&emsp;&emsp;模板字符串使用反引号<u>(` `)</u> 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${ expression } ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。<u>特别的，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。</u>注意，在模版字符串内使用反引号（`）时，需要在它前面加转义符（），<strong>字符串模板可以嵌套使用。</strong></p>
<pre><code>  let a = 4;
  function upgradePhone(str, a)&#123; // [注] 函数的第一个参数是数组（模板中各个原生字符串）。其余的参数为模板中的变量
    return &#39;带标签的模板字符串，&#39; + str[0] + (a + 2) + str[1];
  &#125;

  console.log(`我有一个苹果$&#123;a&#125;s，哈哈哈~`) // 我有一个苹果6s，哈哈哈~
  console.log(upgradePhone`我有一个苹果$&#123;a&#125;s，哈哈哈~`) // 带标签的模板字符串，我有一个苹果6s，哈哈哈~
</code></pre>
<h4 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5) 解构赋值"></a>5) 解构赋值</h4><p>&emsp;&emsp;解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。使得对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法<br>&emsp;&emsp;特别的：<u>赋值语句周围的圆括号()在使用对象字面量无声明解构赋值时是必须的</u>，否则左边被认为是一个块而不是对象字面量。<u>并且()表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行</u></p>
<pre><code>  let a, b, C;
  [a, b = 0] = [10, 20, 30, 40, 50]; // a:10, b:20 [注] 为了防止取出一个值为undefined，可以在表达式左边预设默认值
  [a, b, ...C] = [10, 20, 30, 40, 50]; // a:10，b:20, C: [30, 40, 50]
  (&#123; a, b = 0&#125; = &#123; a: 10, b: 20 &#125;); // a: 10, b: 20
  (&#123;a, b, ...C&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;); // a: 10, b: 20, C: &#123;c: 30, d: 40&#125;
</code></pre>
<h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h4><p>&emsp;&emsp;函数就是包裹在花括号中的代码块，使用关键字function进行定义。当调用该函数时，会执行函数内的代码，在调用函数时，可以向其传递参数。这些参数可以在函数中使用，多个参数用逗号（,）分割。<u>变量和参数必须以一致的顺序出现。</u>第一个变量就是第一个被传递的参数的给定的值，以此类推。有时，我们会希望函数将值返回调用的地方。通过使用return语句就可以实现。在使用return语句时，函数会停止执行(无论后面是否还存在语句)，并返回指定的值。</p>
<p><em>&emsp;&emsp;[注] <u>函数有作用域的概念，在函数内部定义的变量，只能在函数内部访问它（闭包情况除外），此时该变量的作用域是局部的。特别的，如果给未申明的变量赋值，该变量会被自动配置为全局变量（隐式全局变量，也为window对象的属性）。</u></em></p>
<pre><code>  function functionName(var1, var2, ...) &#123;
    // 代码
    // return value;
  &#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局（自适应、响应式、Layout）</title>
    <url>/2020/11/02/css/CSS%E5%B8%83%E5%B1%80%EF%BC%88%E8%87%AA%E9%80%82%E5%BA%94%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%81Layout%EF%BC%89/</url>
    <content><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。布局的传统解决方案，基于盒状模型，依赖 display、 position、float、margin、paddding等属性，采用绝对的单位px、相对单位em、vw、vh、rem以及百分比%等单位进行页面设计。本文将从静态布局、流式布局、自适应布局、响应式布局、弹性布局几个方面进行简单介绍。</p>
<h2 id="1、静态布局"><a href="#1、静态布局" class="headerlink" title="1、静态布局"></a>1、静态布局</h2><p>&emsp;&emsp;页面采用px单位，一般会设置min-width属性，当页面尺寸小于这个宽度时，出现滚动条进行相应显示，当页面尺寸大于这个宽度时，内容区域一般设置为居中显示。使用浮动（float）、定位（position）对元素进行相应的布局<br>&emsp;&emsp;优点：设计简单，编码简单，不用考虑兼容性问题<br>&emsp;&emsp;缺点：有兼容性问题，针对不同的屏幕显示方式单一，对个别用户很不友好。有时也会JS动态修改标签的initial-scale使得页面相应等比缩放，但效果有限</p>
<h2 id="2、流式布局"><a href="#2、流式布局" class="headerlink" title="2、流式布局"></a>2、流式布局</h2><p>&emsp;&emsp;页面宽度采用%（百分比）进行布局，高度一般使用px进行设置，或设置为auto并结合margin、paddding进行布局。宽度会随着浏览器宽度进行相应的调整，为了防止对应区域过大或过小使得内容超出区域，一般结合max-width与min-width进行设置。这种布局整体布局方式不变，即页面元素间相对位置不变，文字大小一般使用px，不随页面尺寸变化而变化。布局方式的代表如栅格系统（将网页页面按比例分成对应行列来排列页面中元素的分布）<br>&emsp;&emsp;优点：在一定范围内，能较好的应对不同的PC端页面<br>&emsp;&emsp;缺点：不适应与PC端到移动端较大的尺寸跨度，元素区域过大过小很导致显示不友好。文字大小不随页面宽度变化而变化，在不同屏幕会出现页面样式可能不协调的情况</p>
<h2 id="3、自适应布局"><a href="#3、自适应布局" class="headerlink" title="3、自适应布局"></a>3、自适应布局</h2><p>&emsp;&emsp;自适应网页设计的核心，就是CSS3引入的媒体查询模块（@media）。自动检测屏幕宽度，然后加载相应的CSS文件或样式<br>&emsp;&emsp;采用媒体查询技术，为不同屏幕分辨率定义布局，即定义多个静态布局，每个静态布局对应一个屏幕范围，可对页面元素尺寸与位置进行相应的调整，对文字尺寸等也可以特殊设置或使用百分比%、em，rem，vh、vw等相对单位</p>
<p>&emsp;&emsp;特别的，其中：<br>&emsp;&emsp;百分比 %是相对于父元素大小的百分比大小<br>&emsp;&emsp;em是最常见的相对长度单位，基准值是当前元素的字号大小<br>&emsp;&emsp;rem代表“ root”：“ root em”，它等于固定在root元素上的字体大小<br>&emsp;&emsp;vh和vw更多是PC端响应式Web设计依赖百分比规则,尺寸vh等于视口高度的1/100，尺寸vw等于视口宽度的1/100。但CSS百分比度量并非始终是解决所有问题的最佳解决方案<br>&emsp;&emsp;<u>在移动设备中，物理设备上的1px一般不等于css的1px像素，在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px、1024px等值，带来的后果就是浏览器会出现横向滚动条。</u>为了避免这种情况，在移动端页面设计时，让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，使用下面的代码使viewport的宽度等于设备的宽度，即即网页初始大小占屏幕面积的100%</p>
<pre><code>  // 网页宽度等于屏幕宽度（width=device-width），原始缩放比例为1.0（initial-scale=1）
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
</code></pre>
<p>&emsp;&emsp;优点：对PC端、移动端不同屏幕尺寸变化时，页面元素都会进行相应的调整，有较好的适应能力<br>&emsp;&emsp;缺点：为了使不同设备达到较好的，对各个不同屏幕尺寸范围会进行长时间的设计与调整，过程中也会产生大量的冗余代码</p>
<h2 id="4、响应式布局"><a href="#4、响应式布局" class="headerlink" title="4、响应式布局"></a>4、响应式布局</h2><p>&emsp;&emsp;<u>个人认为，响应式布局比适应布局更高级，是自适应布局的优化；自适应布局是响应式布局的一个子集。它们都会使用媒体查询（@media）根据不同的访问设备的宽度加载不同的样式。</u>如果要说区别的话，或许自适应式只考虑了屏幕尺寸大小，主要使用媒体查询技术来相应的适应性调整，而响应式布局可能还会考虑到移动设备的触屏操作、页面元素排版是否合理，是否需要对元素的位置重新进行调整等问题。</p>
<h2 id="5、弹性布局（Flex布局）"><a href="#5、弹性布局（Flex布局）" class="headerlink" title="5、弹性布局（Flex布局）"></a>5、弹性布局（Flex布局）</h2><p>&emsp;&emsp;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性,可以简便、完整、响应式地实现各种页面布局。具体布局方式在上一篇文章(CSS布局类型（Display、Flex、Grid）)已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/css/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-1-Flex%E5%B8%83%E5%B1%80">Display Flex 传送门</a></p>
<h2 id="6、网格布局（Grid布局）"><a href="#6、网格布局（Grid布局）" class="headerlink" title="6、网格布局（Grid布局）"></a>6、网格布局（Grid布局）</h2><p>&emsp;&emsp;Grid 布局是目前最强大的布局方案。Grid 布局与Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。Flex 布局是轴线布局，只能指定项目针对轴线(主轴、交叉轴)的位置，可以看作是一维布局。Grid 布局则是将容器划分成行与列，产生单元格，然后指定项目所在的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。具体布局方式在上一篇文章已经介绍了，这里就不在赘述。请点击查看：<a href="/2020/09/27/css/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/#emsp-emsp-2-Grid%E5%B8%83%E5%B1%80">Display Grid 传送门</a></p>
<p><em>[注] 在页面的实际设计中，为了使页面达到更合理的布局方式。我们往往会根据布局要求采用多种布局方式来达到我们的目的</em></p>
<h2 id="题外话1-格式化上下文"><a href="#题外话1-格式化上下文" class="headerlink" title="题外话1 格式化上下文"></a>题外话1 格式化上下文</h2><p>&emsp;&emsp;格式化上下文(Block Formatting Context，BFC)是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域<br>&emsp;&emsp;创建BFC的方式：<br>&emsp;&emsp;根元素（html）<br>&emsp;&emsp;浮动元素（元素的 float 不是 none）<br>&emsp;&emsp;绝对定位元素（元素的 position 为 absolute 或 fixed）<br>&emsp;&emsp;行内块元素（元素的 display 为 inline-block）<br>&emsp;&emsp;表格元素（元素的 display 为 table-cell、table-caption等，HTML表格单元格默认为该值）<br>&emsp;&emsp;overflow 值不为 visible 的块元素（一般这种方式用得最多：overflow: hidden/auto）<br>&emsp;&emsp;弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）<br>&emsp;&emsp;网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p>
<p>&emsp;&emsp;BFC布局规则：<br>&emsp;&emsp;① 内部的块级元素会在垂直方向，依次排列<br>&emsp;&emsp;② 外边距塌陷现象，属于同一个BFC的两个相邻元素的margin会发生重叠（在其中一个元素外面添加一个BFC区域来清除外边距塌陷）<br>&emsp;&emsp;③ 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此<br>&emsp;&emsp;④ BFC的区域不会与浮动元素重叠，即浮动不会影响其它BFC中元素的布局<br>&emsp;&emsp;&emsp;&emsp;应用：<u>自适应两栏布局</u><br>&emsp;&emsp;⑤ BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然<br>&emsp;&emsp;⑥ 计算BFC的高度时，浮动元素也参与计算，即浮动元素不会超出BFC区域的边界<br>&emsp;&emsp;&emsp;&emsp;应用：<u>利用BFC特性来清除浮动</u>、<u>布局文本环绕图像样式</u>（也可以通过clearfix清除浮动来实现）</p>
<h2 id="题外话2-clearfix清除浮动"><a href="#题外话2-clearfix清除浮动" class="headerlink" title="题外话2 clearfix清除浮动"></a>题外话2 clearfix清除浮动</h2><p>&emsp;&emsp;原理：clear <strong>属性定义了元素的哪边上不允许出现浮动元素。</strong> <u>如果声明为左边或右边清除(clear: both;)，会使父元素内部之前添加的伪元素的上外边框边界刚好在浮动元素的下外边距边界之下，使得父元素的高度能够超过浮动元素的高度，从而达到清除浮动的目的</u></p>
<p>&emsp;&emsp;代码：</p>
<pre><code>  .box:after &#123;
    content: &#39;&#39;;
    display: block;
    clear: both;
    *zoom: 1;
    // visibility: hidden;
    // height: 0;
    // font-size: 0;
  &#125;
</code></pre>
<h2 id="题外话3-CSS其他知识"><a href="#题外话3-CSS其他知识" class="headerlink" title="题外话3 CSS其他知识"></a>题外话3 CSS其他知识</h2><p>&emsp;&emsp;css模块化有css-in-js的概念，有BEM（block element modifier）命名规范，有less、sass预处理器等方面知识。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS(3)概述</title>
    <url>/2020/09/24/css/CSS-3-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>层叠样式表(Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>
<h2 id="1、文档流-CSS设计核心"><a href="#1、文档流-CSS设计核心" class="headerlink" title="1、文档流 - CSS设计核心"></a>1、文档流 - CSS设计核心</h2><p>&emsp;&emsp;文档流是文档中可显示对象在排列时所占用的位置。即将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素为文档流。</p>
<p>&emsp;&emsp;元素脱离文档流的原因：<br>&emsp;&emsp;(1) 浮动float<br>&emsp;&emsp;(2) 绝对定位（position: absolute/fixed）</p>
<p>&emsp;&emsp;元素脱离文档流的后果：<br>&emsp;&emsp;(1) 使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。（可结合BFC格式化上下文的特性，布局文本环绕图像的样式）<br>&emsp;&emsp;(2) 对于使用position：absolute脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它<br>&emsp;&emsp;(3) 元素脱离文本流后，父元素高度会塌陷，一般通过BFC的特性或者css clearfix属性（推荐使用伪元素清除浮动的方式）清除浮动</p>
<h2 id="2、CSS框模型"><a href="#2、CSS框模型" class="headerlink" title="2、CSS框模型"></a>2、CSS框模型</h2><p>&emsp;&emsp;框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。<br><img src="/images/css3/CSS%E6%A1%86%E6%A8%A1%E5%9E%8B.gif" alt="CSS框模型"><br>&emsp;&emsp;元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距会呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p>
<p>&emsp;&emsp;内边距、边框和外边距都是可选的，在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>&emsp;&emsp;内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。外边距可以是负值。</p>
<p>&emsp;&emsp;外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<p>&emsp;&emsp;[注] CSS框模型包含2种盒子：<br>&emsp;&emsp;(1) 标准盒模型（box-sizing：content-box），盒子的宽高只有内容的宽高<br>&emsp;&emsp;(2) IE盒模型（box-sizing：border-box），盒子的宽高=内容（content）+内边距（padding）+边框（border）的总宽高</p>
<h2 id="3、CSS基础"><a href="#3、CSS基础" class="headerlink" title="3、CSS基础"></a>3、CSS基础</h2><h4 id="1-选择器"><a href="#1-选择器" class="headerlink" title="(1) 选择器"></a>(1) 选择器</h4><table>
<thead>
<tr>
<th>选择器名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素选择器</td>
<td>通常选择某个 HTML 元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>允许以一种独立于文档元素的方式来指定样式，将类选择器的样式与元素关联，必须将元素class指定为一个对应的类名</td>
</tr>
<tr>
<td>id选择器</td>
<td>允许以一种独立于文档元素的方式来指定样式，将id选择器的样式与元素关联，必须将元素id指定为一个对应的值</td>
</tr>
<tr>
<td>属性选择器</td>
<td>可以根据元素的属性及属性值来选择元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>可以选择作为某元素后代的元素</td>
</tr>
<tr>
<td>子元素选择器</td>
<td>只能选择作为某元素子元素的元素</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>可选择紧接在另一元素后的元素，且二者有相同父元素</td>
</tr>
<tr>
<td>伪类</td>
<td>用于向某些选择器添加特殊的效果</td>
</tr>
<tr>
<td>伪元素</td>
<td>用于向某些选择器设置特殊效果</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;[注] 选择器优先级：</em><br><em>&emsp;&emsp;&emsp; 1)不同选择器优先级：!important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</em><br><em>&emsp;&emsp;&emsp; 2)不同一级别选择器优先级：同一级别中后写的会覆盖先写的样式；同一级别css引入方式不同，优先级不同：内联(行内)样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 导入样式(@import)</em></p>
<h4 id="2-样式"><a href="#2-样式" class="headerlink" title="(2) 样式"></a>(2) 样式</h4><p>&emsp;&emsp;HTML 的 style 属性，提供了一种改变所有 HTML 元素的样式的通用方法。<br>&emsp;&emsp;当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化处理。有三种方式来插入样式表：外部样式表、内部样式表、内联样式（后者优先级高于前者）。</p>
<p>&emsp;&emsp;1) 背景属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>背景设置简写属性</td>
</tr>
<tr>
<td>background-color</td>
<td>背景颜色</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图像（可设置多张图片，或者设置css3渐变效果）</td>
</tr>
<tr>
<td>background-repeat</td>
<td>背景图像是否及如何重复</td>
</tr>
<tr>
<td>background-position</td>
<td>背景图像的起始位置</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景图是否固定或者随着页面滚动</td>
</tr>
<tr>
<td>background-attachment</td>
<td>规定背景图像是否固定或者随着页面的其余部分滚动</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;2) 文本属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>颜色</td>
</tr>
<tr>
<td>direction</td>
<td>文本方向</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>text-indent</td>
<td>缩进文本</td>
</tr>
<tr>
<td>text-align</td>
<td>水平对齐</td>
</tr>
<tr>
<td>word-spacing</td>
<td>字间隔</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>字母间隔</td>
</tr>
<tr>
<td>text-transform</td>
<td>字符转换，如大小写转换</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本装饰</td>
</tr>
<tr>
<td>white-space</td>
<td>处理空白字符</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;3) 字体属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>font</td>
<td>简写属性（HTML5已不支持此属性）</td>
</tr>
<tr>
<td>font-family</td>
<td>字体系列</td>
</tr>
<tr>
<td>font-size</td>
<td>字体尺寸</td>
</tr>
<tr>
<td>font-style</td>
<td>字体风格</td>
</tr>
<tr>
<td>font-variant</td>
<td>以小型大写字体或者正常字体显示文本</td>
</tr>
<tr>
<td>font-weight</td>
<td>字体粗细</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;4) 尺寸属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>元素的宽度</td>
</tr>
<tr>
<td>height</td>
<td>元素的高度</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>max-height</td>
<td>元素的最大高度</td>
</tr>
<tr>
<td>max-width</td>
<td>元素的最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>元素的最小高度</td>
</tr>
<tr>
<td>min-width</td>
<td>元素的最小宽度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;5) 显示属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clear</td>
<td>设置一个元素的侧面是否允许其他的浮动元素</td>
</tr>
<tr>
<td>cursor</td>
<td>规定当指向某元素之上时显示的指针类型</td>
</tr>
<tr>
<td>display</td>
<td>设置是否及如何显示元素</td>
</tr>
<tr>
<td>float</td>
<td>定义元素在哪个方向浮动</td>
</tr>
<tr>
<td>position</td>
<td>把元素放置到一个静态的、相对的、绝对的、或固定的位置中</td>
</tr>
<tr>
<td>visibility</td>
<td>设置元素是否可见或不可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;6) 链接属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>创建指向另一个文档的链接</td>
</tr>
<tr>
<td>name</td>
<td>创建文档内的书签</td>
</tr>
</tbody></table>
<p><em>&emsp;&emsp;&emsp;<u>[注] 给链接设置样式时样注意合理的顺序：a:link、a:visited、a:hover、a:active</u></em></p>
<p>&emsp;&emsp;7) 列表属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>list-style</td>
<td>简写属性</td>
</tr>
<tr>
<td>list-style-image</td>
<td>列表项标志为图片</td>
</tr>
<tr>
<td>list-style-position</td>
<td>列表项标志的位置</td>
</tr>
<tr>
<td>list-style-type</td>
<td>列表项标志的类型</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;8) 表格属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>border-collapse</td>
<td>是否把表格边框合并为单一边框</td>
</tr>
<tr>
<td>border-spacing</td>
<td>分割单元格边框的距离</td>
</tr>
<tr>
<td>caption-side</td>
<td>表格标题的位置</td>
</tr>
<tr>
<td>empty-cells</td>
<td>是否显示表格中的空单元格</td>
</tr>
<tr>
<td>table-layout</td>
<td>设置显示单元、行和列的算法</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;9) 轮廓属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>outline</td>
<td>声明中设置所有的轮廓属性</td>
</tr>
<tr>
<td>outline-color</td>
<td>轮廓颜色</td>
</tr>
<tr>
<td>outline-style</td>
<td>轮廓样式</td>
</tr>
<tr>
<td>outline-width</td>
<td>轮廓宽度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;10) 框模型</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>padding</td>
<td>简写属性。作用是在一个声明中设置元素的所内边距属性</td>
</tr>
<tr>
<td>padding-bottom</td>
<td>元素的下内边距</td>
</tr>
<tr>
<td>padding-left</td>
<td>元素的左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td>元素的右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td>元素的上内边距</td>
</tr>
<tr>
<td>border</td>
<td>简写属性，用于把针对四个边的属性设置在一个声明</td>
</tr>
<tr>
<td>border-style</td>
<td>用于设置元素所有边框的样式，或者单独地为各边设置边框样式</td>
</tr>
<tr>
<td>border-width</td>
<td>用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度</td>
</tr>
<tr>
<td>border-color</td>
<td>设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色</td>
</tr>
<tr>
<td>margin</td>
<td>简写属性。在一个声明中设置所有外边距属性</td>
</tr>
<tr>
<td>margin-bottom</td>
<td>元素的下外边距</td>
</tr>
<tr>
<td>margin-left</td>
<td>元素的左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td>元素的右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td>元素的上外边距</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;11) 定位</p>
<p>&emsp;&emsp;CSS中三种定位机制：普通流、浮动与绝对定位。</p>
<p>&emsp;&emsp;① 在普通流中：<br>&emsp;&emsp;块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。<br>&emsp;&emsp;行内框在一行中水平排列。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度，由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。</p>
<p>&emsp;&emsp;② 浮动与清除浮动：<br>&emsp;&emsp;浮动（float）的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。不论何种元素，浮动会生成一个块级框。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。文本会环绕在浮动元素周围但文本过少可能会导致父元素高度塌陷，一般清除父元素的浮动来实现文本环绕图像的样式。<br>&emsp;&emsp;清除浮动（clear）属性定义了元素的哪一侧不允许出现浮动元素，设置了 clear 属性的元素会增加上外边距，即在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，<u>如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下，从而达到清除浮动的目的。</u><br>&emsp;&emsp;利用BFC（块级格式化上下文）的特性（BFC区域不会与float box重叠），也可以达到清除浮动的目的。</p>
<p>&emsp;&emsp;③ 绝对定位：<br>&emsp;&emsp;设置为绝对定位（position: absolute/fixed）的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素绝对定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>display</td>
<td>改变元素生成框的类型</td>
</tr>
<tr>
<td>position</td>
<td>定位元素到静态的、相对的、绝对的、或固定的位置</td>
</tr>
<tr>
<td>top</td>
<td>定位元素的上外边距边界与其包含块上边界之间的偏移</td>
</tr>
<tr>
<td>right</td>
<td>定位元素右外边距边界与其包含块右边界之间的偏移</td>
</tr>
<tr>
<td>bottom</td>
<td>定义了定位元素下外边距边界与其包含块下边界之间的偏移</td>
</tr>
<tr>
<td>left</td>
<td>定义了定位元素左外边距边界与其包含块左边界之间的偏移</td>
</tr>
<tr>
<td>overflow</td>
<td>设置当元素的内容溢出其区域时发生的事情</td>
</tr>
<tr>
<td>clip</td>
<td>设置元素的形状。元素被剪入这个形状之中，然后显示出来</td>
</tr>
<tr>
<td>vertical-align</td>
<td>置元素的垂直对齐方式</td>
</tr>
<tr>
<td>z-index</td>
<td>设置元素的堆叠顺序</td>
</tr>
</tbody></table>
<h2 id="4、CSS进阶"><a href="#4、CSS进阶" class="headerlink" title="4、CSS进阶"></a>4、CSS进阶</h2><p>&emsp;&emsp;(1) 水平对齐<br>&emsp;&emsp;margin 属性：可通过将左和右外边距设置为 “auto”，来对齐块元素。把左和右外边距设置为 auto，根据相应规则，会均等地分配可用的外边距实现水平居中。<br>&emsp;&emsp;position属性：通过绝对定位使元素会被从正常流中删除，并且能够交叠元素进行水平居中布局。<br>&emsp;&emsp;float属性：通过浮动进行定位使元素水平居中布局。</p>
<p>&emsp;&emsp;(2) 图片滤镜（<u>注意浏览器兼容!!!</u>  -webkit-, -ms- 或 -moz- ）<br>&emsp;&emsp;filter 属性定义了元素(通常是img)的可视效果。常用函数：blur(px)、brightness(%)、contrast(%)、grayscale(%)、opacity(%)。</p>
<h2 id="5、CSS3新能力"><a href="#5、CSS3新能力" class="headerlink" title="5、CSS3新能力"></a>5、<u>CSS3新能力</u></h2><p>&emsp;&emsp;CSS3的新特征有很多，例如选择器的添加、圆角效果、图形化边界、块阴影与文字阴影、使用RGBA实现透明效果、渐变效果、使用@font-face实现定制字体、多背景图、文字或图像的效果与变形处理（旋转、缩放、倾斜、移动）、多栏布局、媒体查询(@media)等。</p>
<p>&emsp;&emsp;1) 选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=”https”]</td>
<td>选择每一个src属性的值以”https”开头的元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=”.pdf”]</td>
<td>选择每一个src属性的值以”.pdf”结尾的元素</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=”abc”]</td>
<td>选择每一个src属性的值包含子字符串”abc”的元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的倒数第二个子元素</td>
</tr>
<tr>
<td>nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的倒数第二个p元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
</tr>
<tr>
<td><u>:target</u></td>
<td>#news:target</td>
<td>选择当前激活的#news元素（包含该锚名称的点击的URL）</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;2) 边框(圆角)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>border-image</td>
<td>设置所有边框图像的速记属性</td>
</tr>
<tr>
<td>box-shadow</td>
<td>附加一个或多个下拉框的阴影（可设置内/外阴影效果）</td>
</tr>
<tr>
<td>border-radius</td>
<td>用于设置所有四个边框圆角半径属性</td>
</tr>
<tr>
<td>border-top-left-radius</td>
<td>定义了左上角的弧度</td>
</tr>
<tr>
<td>border-top-right-radius</td>
<td>定义了右上角的弧度</td>
</tr>
<tr>
<td>border-bottom-right-radius</td>
<td>定义了右下角的弧度</td>
</tr>
<tr>
<td>border-bottom-left-radius</td>
<td>定义了左下角的弧度</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;3) 背景</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background-clip</td>
<td>规定背景的绘制区域</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;4) 渐变</p>
<p>&emsp;&emsp;CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。（相关属性background-image）<br>&emsp;&emsp;CSS3 定义了两种类型的渐变（gradients）：</p>
<p>&emsp;&emsp;① 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</p>
<pre><code>  background-image: linear-gradient(direction, color-stop1, color-stop2, ...);
  background-image: linear-gradient(angle, color-stop1, color-stop2)
</code></pre>
<p>&emsp;&emsp;② 径向渐变（Radial Gradients）- 由它们的中心定义</p>
<pre><code>  background-image: radial-gradient(shape size at position, start-color, ..., last-color)
</code></pre>
<p>&emsp;&emsp;<u>利用repeating-linear-gradient函数可以实现线形重复渐变效果定义：</u></p>
<pre><code>  repeating-linear-gradient([ &lt;angle&gt; | to &lt;side-or-corner&gt; ,] ? &lt;color-stop&gt; [, &lt;color-stop&gt;]+)
</code></pre>
<p>&emsp;&emsp;5) 文本效果（文本字体可使用css3 @font-face属性自定义）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情</td>
</tr>
<tr>
<td>text-shadow</td>
<td>向文本添加阴影</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;<em>[注1] 单行文本超出隐藏</em></p>
<pre><code>  .box &#123; // 有一定宽度的包含元素
    white-space: nowrap; // 如何处理包含元素内的空白：文本不会换行，文本会在在同一行上继续，直到遇到&lt;br&gt;标签为止
    text-overflow: ellipsis; // 文本溢出包含元素发生事情：显示省略符号来代表被修剪的文本
    overflow: hidden; // 内容溢出包含元素发生的事情：内容修剪且不可见
  &#125;
</code></pre>
<p>&emsp;&emsp;<em>[注2]  多行文本超出隐藏（适用于WebKit浏览器及移动端，不同浏览器要添加对应修饰符）</em></p>
<p>&emsp;&emsp;<em>原理：利用了css弹性盒子模型flex-box，可以理解为flex弹性盒子旧的规则，有兼容性问题。在不同的浏览器中申明：display: -moz-box / -webkit-box / box。有box-orient（子元素的排列方向，有horizontal、vertical等取值）, box-direction（子元素的排列顺序，取值有normal、reverse、inherit）, box-align（垂直方向上的空间利用，即对齐方式，有start、end、center等取值）, box-pack（水平方向上的空间利用，即对齐方式，有start、end、center等取值）, box-lines（子元素是可以换行显示，取值有single、multiple）属性来设置子元素的排列方式。再结合-webkit-line-clamp属性（块元素显示的文本的行数，不规范属性，未在css规范草案中）等属性来实现多行显示省略号</em></p>
<pre><code>  .box &#123; 
    display: -webkit-box; // 布局方式：flex-box弹性盒子
    -webkit-box-orient: vertical; // 盒子内子元素排列方向：子元素纵向排列
    -webkit-line-clamp: 3; // css不规范属性-webkit-line-clamp：块元素显示的文本的行数为3 （有兼容问题）
    text-overflow: ellipsis; // 文本溢出包含元素发生事情：显示省略符号来代表被修剪的文本
    overflow: hidden; // 内容溢出包含元素发生的事情：内容修剪且不可见
  &#125;
</code></pre>
<p>&emsp;&emsp;<em>[注3] 多行文本超出隐藏（跨浏览器兼容方案）</em></p>
<p>&emsp;&emsp;<em>父元素使用相对高度，高度是文本行高的相应倍数来显示相应行数的文本，使用对位来放置 ‘…’ 的位置来达到超出隐藏的要求</em></p>
<p>&emsp;&emsp;6) 2D/3D转换（移动、缩放、转动、拉长或拉伸）（<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你更改一个元素变形的原点(该属性必须与transform属性一同使用)</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;7) 过渡 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript就能完成简单动画</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称</td>
</tr>
<tr>
<td>ransition-duration</td>
<td>定义过渡效果花费的时间，默认是 0</td>
</tr>
<tr>
<td><u>transition-timing-function</u></td>
<td>规定过渡效果的时间曲线(时序函数)，默认是 “ease”</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始，默认是 0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;8) 动画 （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<p>&emsp;&emsp;动画是使元素从一种样式逐渐变化为另一种样式的效果，您可以改变任意多的样式任意多的次数。可以实现相对复杂的动画。<br>&emsp;&emsp;使用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%（推荐使用百分比），0% 是动画的开始，100% 是动画的完成。<br>&emsp;&emsp;当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会被使用，也不会有任何效果。使用animation属对选择器设置对应动画，必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p>
<pre><code>  @keyframes name
  &#123;
    0%   &#123; // 状态1 &#125;
    ...
    xx%  &#123; // 状态x &#125;
    ...
    100% &#123; // 状态n &#125;
  &#125;
  // 自定义动画的使用
  animation: name duration timing-function delay iteration-count direction;

  // timing-function的取值: linear、ease、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)
  // iteration-count的取值: n(次数)、infinite
  // animation-direction的取值: normal、alternate
</code></pre>
<br/>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@keyframes</td>
<td>规定动画（兼容加对应浏览器前缀）</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定 @keyframes 动画的名称</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或毫秒，默认为0</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线函数，默认是 “ease”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始，默认是 0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数，默认是 1</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向地播放，默认是 “normal”</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;10) 多列布局  （<u>注意浏览器兼容!!!</u> -webkit-, -ms- 或 -moz- ）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column-count</td>
<td>指定元素应该被分割的列数</td>
</tr>
<tr>
<td>column-gap</td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td>column-rule</td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td>column-rule-color</td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td>column-rule-style</td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td>column-rule-width</td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td>column-span</td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td>column-width</td>
<td>指定列的宽度</td>
</tr>
<tr>
<td>columns</td>
<td>column-width 与 column-count 的简写属性</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;11) 媒体查询(@media)</p>
<p>&emsp;&emsp;媒体查询非常实用，可以根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如根据屏幕分辨率和浏览器视窗宽度）来设置更合理的样式等</p>
<pre><code>  &lt;link rel=&quot;stylesheet&quot; src=&quot;styleA.css&quot; media=&quot;screen&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; src=&quot;styleB.css&quot; media=&quot;print&quot; /&gt;
</code></pre>
<p>&emsp;&emsp;每条媒体查询语句都由一个可选的媒体类型和任意数量的媒体特性表达式构成。可以使用多种逻辑操作符合并多条媒体查询语句。媒体查询语句不区分大小写。<br>&emsp;&emsp;当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。</p>
<p><em>&emsp;&emsp;[注] <u>即使媒体查询返回false，带有媒体查询附加到其&lt;link&gt;标记的样式表仍将下载</u>，但只有媒体查询为true的对应样式文件才被使用</em></p>
<p>&emsp;&emsp;<u>逻辑操作符 not, and, 和 only 可用于联合构造复杂的媒体查询，可用逗号(,)分隔多个媒体查询，将它们组合为一个规则。</u></p>
<pre><code>  // 用户设备的宽度介于 300px 到 500px 的设备
  @media (min-width: 300px) and (max-width: 500px) &#123; ... &#125;
  // 用户设备的最小高度为680px或为纵向模式的屏幕设备
  @media (min-height: 680px), screen and (orientation: portrait) &#123; ... &#125;
</code></pre>
<h2 id="6、其他CSS属性"><a href="#6、其他CSS属性" class="headerlink" title="6、其他CSS属性"></a>6、其他CSS属性</h2><p>&emsp;&emsp;(1) <u>mask</u>（通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域）<br>&emsp;&emsp;(2) <u>clip-path</u>（使用裁剪方式创建元素的可显示区域，结合transform、transition能作出惊艳的动画效果）<br>&emsp;&emsp;(3) <u>offset</u> （CSS快速定义元素沿相关路径运动）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局类型（Display、Flex、Grid）</title>
    <url>/2020/09/27/css/CSS%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B%EF%BC%88Display%E3%80%81Flex%E3%80%81Grid%EF%BC%89/</url>
    <content><![CDATA[<p>display属性规定元素应该生成的框的类型。display 属性可以设置元素的内部和外部等显示类型 display type。元素的外部显示类型 outer display type 将决定该元素在流式布局中的表现（块级或内联元素）；元素的内部显示类型 inner display type 可以控制其子元素的布局（如 flow layout，grid 或 flex）。</p>
<p>display 属性使用关键字取值来指定，关键字取值被分为六类：</p>
<pre><code>  &lt;display-outside&gt; = block | inline | run-in
  &lt;display-inside&gt; = flow | flow-root | table | flex | grid | ruby
  &lt;display-listitem&gt; = list-item
  &lt;display-internal&gt; = table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container
  &lt;display-box&gt; = contents | none
  &lt;display-legacy&gt; = inline-block | inline-list-item | inline-table | inline-flex | inline-grid
</code></pre>
<h2 id="1、display-outside类型"><a href="#1、display-outside类型" class="headerlink" title="1、display-outside类型"></a>1、display-outside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的外部显示类型，实际上就是其在流式布局中的角色（即在流式布局中的表现）。<br>&emsp;&emsp;block：此元素将显示为块级元素，此元素前后会带有换行符<br>&emsp;&emsp;inline：默认值，此元素会被显示为内联元素，元素前后没有换行符<br>&emsp;&emsp;run-in：此元素会根据上下文作为块级元素或内联元素显示</p>
<p><em>&emsp;&emsp;[注]如果 run-in box 包含 block box，那么这个 run-in box 也成为 block box；如果紧跟在 run-in box 之后的兄弟节点是 block box，那么这个 run-in box 就会做为此 block box 里的 inline box（run-in box 不能进入已经一个已经以 run-in box 开头的块内，也不能进入本身就是 display:run-in的块内）；否则，run-in box 都将成为 block box</em></p>
<h2 id="2、display-inside类型"><a href="#2、display-inside类型" class="headerlink" title="2、display-inside类型"></a>2、display-inside类型</h2><p>&emsp;&emsp;这些关键字指定了元素的内部显示类型，它们定义了该元素内部内容的布局方式。<br>&emsp;&emsp;flow：元素使用流布局（块和内联布局）布局其内容<br><em>&emsp;&emsp;[注] 如果其外部显示类型为inline或run-in，并且它参与了块或内联格式设置上下文，则它将生成一个内联框。否则，它将生成一个块容器框</em><br>&emsp;&emsp;flow-root：该元素生成一个块元素框，该框将建立一个新的块格式化上下文，定义格式化根所在的位置<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 &lt;table&gt; ），表格前后带有换行符<br>&emsp;&emsp;flex：元素的行为类似于block元素，并根据flex box模型布置其内容<br>&emsp;&emsp;grid: 元素的行为类似于块元素，并根据网格模型布置其内容<br>&emsp;&emsp;ruby: 元素的行为类似于内联元素，并根据ruby格式化模型布置其内容。它的行为类似于相应的HTML &lt;ruby&gt;元素</p>
<h4 id="emsp-emsp-1-Flex布局"><a href="#emsp-emsp-1-Flex布局" class="headerlink" title="&emsp;&emsp;1) Flex布局"></a>&emsp;&emsp;1) Flex布局</h4><p>&emsp;&emsp;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”，Flex 容器有主轴与交叉轴两个方向。<br><img src="/images/css3/Flex%E5%AE%B9%E5%99%A8.png" alt="Flex容器"></p>
<p>&emsp;&emsp;<strong>(1) Flex容器的属性：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</strong></p>
<p>&emsp;&emsp;① flex-direction属性决定主轴的方向（即项目的排列方向）</p>
<pre><code>  flex-direction: row | row-reverse | column | column-reverse;
</code></pre>
<p><img src="/images/css3/flex-direction%E5%B1%9E%E6%80%A7.png" alt="flex-direction属性"></p>
<p>&emsp;&emsp;row（默认值）：主轴为水平方向，起点在左端<br>&emsp;&emsp;row-reverse：主轴为水平方向，起点在右端<br>&emsp;&emsp;column：主轴为垂直方向，起点在上沿<br>&emsp;&emsp;column-reverse：主轴为垂直方向，起点在下沿</p>
<p>&emsp;&emsp;② flex-warp属性决定项目排列超过容器宽度时是否换行</p>
<pre><code>    flex-wrap: nowrap | wrap | wrap-reverse;
</code></pre>
<p><img src="/images/css3/flex-warp%E5%B1%9E%E6%80%A7.png" alt="flex-warp属性"></p>
<p>&emsp;&emsp;nowrap(默认)：不换行<br>&emsp;&emsp;wrap：换行，首行在上方<br>&emsp;&emsp;wrap-reserve：换行，首行在下方</p>
<p>&emsp;&emsp;③ flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>
<pre><code>    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;
</code></pre>
<p>&emsp;&emsp;④ justify-content属性定义了项目在主轴上的对齐方式</p>
<pre><code>    justify-content: flex-start | flex-end | center | space-between | space-around;
</code></pre>
<p><img src="/images/css3/justify-content%E5%B1%9E%E6%80%A7.png" alt="justify-content属性"></p>
<p>&emsp;&emsp;flex-start（默认值）：左对齐<br>&emsp;&emsp;flex-end：右对齐<br>&emsp;&emsp;center： 居中<br>&emsp;&emsp;space-between：两端对齐，项目之间的间隔都相等<br>&emsp;&emsp;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</p>
<p>&emsp;&emsp;⑤ align-items属性定义项目在交叉轴上如何对齐</p>
<pre><code>    align-items: flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p><img src="/images/css3/align-items%E5%B1%9E%E6%80%A7.png" alt="align-items属性"></p>
<p>&emsp;&emsp;flex-start：交叉轴的起点对齐<br>&emsp;&emsp;flex-end：交叉轴的终点对齐<br>&emsp;&emsp;center：交叉轴的中点对齐<br>&emsp;&emsp;baseline: 项目的第一行文字的基线对齐<br>&emsp;&emsp;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</p>
<p>&emsp;&emsp;⑥ align-content属性定义了多根轴线的对齐方式（如果项目只有一根轴线，该属性不起作用）</p>
<pre><code>    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
</code></pre>
<p>&emsp;&emsp;flex-start：与交叉轴的起点对齐<br>&emsp;&emsp;flex-end：与交叉轴的终点对齐<br>&emsp;&emsp;center：与交叉轴的中点对齐<br>&emsp;&emsp;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>&emsp;&emsp;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍<br>&emsp;&emsp;stretch（默认值）：轴线占满整个交叉轴</p>
<p>&emsp;&emsp;<strong>(2)Flex项目的属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self</strong></p>
<p>&emsp;&emsp;① order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<pre><code>  order: &lt;integer&gt;;
</code></pre>
<p>&emsp;&emsp;② flex-grow属性定义项目的放大比例（整体布局存在剩余空间），默认为0，即如果存在剩余空间，也不放大</p>
<pre><code>  flex-grow: &lt;number&gt;; /* default 0 */
</code></pre>
<p>&emsp;&emsp;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>&emsp;&emsp;③ flex-shrink属性定义了项目的缩小比例（整体布局空间不足），默认为1，即如果空间不足，该项目将缩小</p>
<pre><code>  flex-shrink: &lt;number&gt;; /* default 1 */
</code></pre>
<p>&emsp;&emsp;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>&emsp;&emsp;④ flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小</p>
<pre><code>  flex-basis: &lt;length&gt; | auto; /* default auto */
</code></pre>
<p>&emsp;&emsp;可设与width或height属性明确的值（比如200px，则项目将占据固定空间）。</p>
<p>&emsp;&emsp;⑤ flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选</p>
<pre><code>  flex: none | [ &lt;flex-grow&gt; || &lt;flex-shrink&gt;? || &lt;flex-basis&gt;? ]
</code></pre>
<p>&emsp;&emsp;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>&emsp;&emsp;⑥ align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>
<pre><code>  align-self: auto | flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p>&emsp;&emsp;该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h4 id="emsp-emsp-2-Grid布局"><a href="#emsp-emsp-2-Grid布局" class="headerlink" title="&emsp;&emsp;2) Grid布局"></a>&emsp;&emsp;2) Grid布局</h4><p>&emsp;&emsp;将网页划分成一个个网格，可以任意组合不同的网格。Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可看作是二维布局。Grid 布局远比 Flex 布局强大。同样的，grid布局中也有容器与项目的概念。<br>&emsp;&emsp;grid布局将容器分为行和列，行和列的交叉区域称为单元格<strong>（区域）</strong>。正常情况下，n行和m列会产生n x m个单元格（可能有跨行与跨列等布局状态）。<br>&emsp;&emsp;容器中划分网格的线，称为”网格线”。水平网格线划分出行，垂直网格线划分出列。正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线。<br><img src="/images/css3/Grid%E5%AE%B9%E5%99%A8.png" alt="Grid容器"></p>
<p>&emsp;&emsp;<strong>(1) Grid容器的属性：</strong><br>&emsp;&emsp;grid-template-columns、grid-template-rows（容器划分行和列）<br>&emsp;&emsp;grid-row-gap、grid-columns-gap、grid-gap（行与行、列于列的间距）<br>&emsp;&emsp;grid-template-areas（网格布局给区域命名）<br>&emsp;&emsp;grid-auto-flow（容器中放置项目顺序设置，如先行后列，是否紧密填满）<br>&emsp;&emsp;justify-items、align-items、place-items（单元格内元素水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-content、align-content、place-content（容器中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;grid-auto-columns、grid-auto-rows（超出容器项目的行、列设置）<br>&emsp;&emsp;grid-template、grid（简写属性）</p>
<p>&emsp;&emsp;① grid-template-columns、grid-template-rows属性<br>&emsp;&emsp;容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。下面以列宽设置为例，行高设置同理。</p>
<pre><code>  .container &#123;
    display: grid;
    grid-template-rows: [R1]100px [R2]100px [R3]100px[R4]; // 设置网格线名称（网格线有多个名称，默认为1、2、3...)）
    // 1、px设置行宽
    grid-template-columns: [C1]100px [C2]100px [C3]100px[C4]; // 设置网格线名称
   // 2、百分比设置行宽
    grid-template-columns: 33.33% 33.33% 33.33%;
    // 3、repeat()重复行宽设置，也可重复某一模式
    grid-template-columns: repeat(3, 33.33%);
    // 4、auto-fill关键字自动填充列
    grid-template-columns: repeat(auto-fill, 100px);
    // 5、fr关键字按比例划分列宽
    grid-template-columns: 150px 1fr 2fr;
    // 6、minmax()函数设置某一列宽范围
    grid-template-columns: 1fr 1fr minmax(100px, 1fr);
    // 7、auto关键字列宽自适应
    grid-template-columns: 100px auto 100px;
  &#125;
</code></pre>
<p><img src="/images/css3/grid-template%E5%B1%9E%E6%80%A7.png" alt="grid-template属性"></p>
<p>&emsp;&emsp;② grid-row-gap、grid-columns-gap、grid-gap属性<br>&emsp;&emsp;grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。grid-gap为行列间距两属性的简写属性。</p>
<pre><code>  .container &#123;
    grid-row-gap: 20px;
    grid-column-gap: 20px;
 &#125;
</code></pre>
<p><img src="/images/css3/grid-gap%E5%B1%9E%E6%80%A7.png" alt="grid-gap属性"></p>
<p>&emsp;&emsp;③ grid-template-areas属性<br>&emsp;&emsp;网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。<br><em>&emsp;&emsp;[注] 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</em></p>
<pre><code>  grid-template-areas: &#39;A B C&#39; &#39;D . F&#39; &#39;G H I&#39;;
</code></pre>
<p><img src="/images/css3/grid-template-areas%E5%B1%9E%E6%80%A7.png" alt="grid-template-areas属性"></p>
<p>&emsp;&emsp;④ grid-auto-flow属性<br>&emsp;&emsp;划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。</p>
<p><img src="/images/css3/grid-auto-flow%E5%B1%9E%E6%80%A7.png" alt="grid-auto-flow属性"></p>
<p>&emsp;&emsp;⑤ justify-items 、align-items、place-items 属性（设置单元格内容的位置）<br>&emsp;&emsp;justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。place-items属性是align-items属性和justify-items属性的合并简写形式。</p>
<pre><code>  .container &#123; 
    justify-items: start | end | center | stretch;
    align-items: start | end | center | stretch;
  &#125;
</code></pre>
<p>&emsp;&emsp;start：对齐单元格的起始边缘<br>&emsp;&emsp;end：对齐单元格的结束边缘<br>&emsp;&emsp;center：单元格内部居中<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p>&emsp;&emsp;⑥ justify-content 、align-content、place-content属性（设置整个内容区域在容器里面的的位置）<br>&emsp;&emsp;justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。place-content属性是align-content属性和justify-content属性的合并简写形式。</p>
<pre><code>  .container &#123;
    justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
    align-content: start | end | center | stretch | space-around | space-between | space-evenly;
  &#125;
</code></pre>
<p>&emsp;&emsp;start - 对齐容器的起始边框<br>&emsp;&emsp;end - 对齐容器的结束边框<br>&emsp;&emsp;center - 容器内部居中<br>&emsp;&emsp;stretch - 项目大小没有指定时，拉伸占据整个网格容器<br>&emsp;&emsp;space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍<br>&emsp;&emsp;space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔<br>&emsp;&emsp;space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p>
<p>&emsp;&emsp;⑦ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;当项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。grid-auto-columns属性和grid-auto-rows属性用来设置浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>&emsp;&emsp;⑧ grid-auto-columns 、 grid-auto-rows 属性（设置浏览器自动创建的多余网格的列宽和行高）<br>&emsp;&emsp;grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。<br>&emsp;&emsp;grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<p>&emsp;&emsp;<strong>(2) Grid项目的属性：</strong><br>&emsp;&emsp;grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column、grid-row（设置项目位置简写属性）<br>&emsp;&emsp;grid-area（指定项目放置的区域）<br>&emsp;&emsp;justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）</p>
<p>&emsp;&emsp;① grid-columns-start、grid-columns-end、grid-row-start、grid-row-end（设置项目位置）<br>&emsp;&emsp;grid-column-start属性：左边框所在的垂直网格线<br>&emsp;&emsp;grid-column-end属性：右边框所在的垂直网格线<br>&emsp;&emsp;grid-row-start属性：上边框所在的水平网格线<br>&emsp;&emsp;grid-row-end属性：下边框所在的水平网格线</p>
<pre><code>  .item_1&#123;
    grid-column-start: 2;
    grid-row-start: 2;
    grid-column-end: 3;
    grid-row-end: 3;
  &#125;
</code></pre>
<p><img src="/images/css3/Grid%E9%A1%B9%E7%9B%AE%E4%BD%8D%E7%BD%AE.png" alt="Grid项目位置"></p>
<p><em>&emsp;&emsp;[注] 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 如: grid-column-start:  span 2; 必要的时候，可使用z-index设置项目重叠顺序</em></p>
<p>&emsp;&emsp;② grid-column、grid-row属性<br>&emsp;&emsp;grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的简写形式，属性值取值用用’/‘分割</p>
<p>&emsp;&emsp;③ grid-area属性<br>&emsp;&emsp;grid-area属性指定项目放在哪一个区域</p>
<pre><code>  .item-1 &#123;
    grid-area: &#39;I&#39;; // I是grid-template-areas属性指定的区域
  &#125;
</code></pre>
<p><img src="/images/css3/grid-area%E5%B1%9E%E6%80%A7.png" alt="grid-area属性"></p>
<p><em>&emsp;&emsp;[注] grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的简写形式来指定项目位置。形如：grid-area: row-start / column-start / row-end / column-end; 属性值间取值用’/‘分割，上图的设置相当于：grid-area:  2 / 2 / 3 / 3;</em></p>
<p>&emsp;&emsp;④ justify-self、align-self、place-self（设置单元格中内容水平、垂直方向上的对齐方式）<br>&emsp;&emsp;justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目<br>&emsp;&emsp;align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目</p>
<pre><code>  .item &#123;
    justify-self: start | end | center | stretch;
    align-self: start | end | center | stretch;
  &#125;
</code></pre>
<p>&emsp;&emsp;start：对齐单元格的起始边缘。<br>&emsp;&emsp;end：对齐单元格的结束边缘。<br>&emsp;&emsp;center：单元格内部居中。<br>&emsp;&emsp;stretch：拉伸，占满单元格的整个宽度（默认值）</p>
<p><em>&emsp;&emsp;[注] g place-self属性是align-self属性和justify-self属性的简写形式。当省略第二个值时，place会默认这两个属性值相等</em></p>
<h2 id="3、display-listitem类型"><a href="#3、display-listitem类型" class="headerlink" title="3、display-listitem类型"></a>3、<del>display-listitem类型</del></h2><p>&emsp;&emsp;将这个元素的外部显示类型变为 block 盒子，并将内部显示类型变为多个 list-item inline盒子。（即为元素内容生成一个块型盒，随后再生成一个列表型的行内盒）<br>&emsp;&emsp;list-item：使元素的行为类似于列表项。可以与list-style-type和list-style-position一起使用，也可以与任何display-outside关键字和flow或flow-root display-inside关键字组合</p>
<h2 id="4、display-internal类型"><a href="#4、display-internal类型" class="headerlink" title="4、display-internal类型"></a>4、<del>display-internal类型</del></h2><p>&emsp;&emsp;有些布局模型（如 table 和 ruby）有着复杂的内部结构，因此它们的子元素可能扮演着不同的角色。这一类关键字就是用来定义这些“内部”显示类型，并且只有在这些特定的布局模型中才有意义。<br>&emsp;&emsp;table：此元素会作为块级表格来显示（类似 table），表格前后带有换行符<br>&emsp;&emsp;table-row-group：这些元素的行为类似于tbody HTML元素<br>&emsp;&emsp;table-header-group：这些元素的行为类似于thead HTML元素<br>&emsp;&emsp;table-footer-group：这些元素的行为类似于tfoot HTML元素<br>&emsp;&emsp;table-row：这些元素的行为类似于tr HTML元素<br>&emsp;&emsp;table-cell：这些元素的行为类似于td HTML元素<br>&emsp;&emsp;table-column-group：这些元素的行为类似于colgroup HTML元素<br>&emsp;&emsp;table-column：这些元素的行为类似于col HTML元素<br>&emsp;&emsp;table-caption：这些元素的行为类似于caption HTML元素<br>&emsp;&emsp;ruby-base：这些元素的行为类似于rb HTML元素<br>&emsp;&emsp;ruby-text：这些元素的行为类似于rt HTML元素<br>&emsp;&emsp;ruby-base-container：这些元素的行为类似于rbc生成为匿名框的HTML元素<br>&emsp;&emsp;ruby-text-container：这些元素的行为类似于rtc HTML元素</p>
<h2 id="5、display-inside类型"><a href="#5、display-inside类型" class="headerlink" title="5、display-inside类型"></a>5、<del>display-inside类型</del></h2><p>&emsp;&emsp;这些值决定元素是否使用盒模型。<br>&emsp;&emsp;contents：这些元素本身不会产生特定的框。它们被伪框和子框替换<br>&emsp;&emsp;none：此元素不会被显示</p>
<h2 id="6、display-legacy类型"><a href="#6、display-legacy类型" class="headerlink" title="6、display-legacy类型"></a>6、<del>display-legacy类型</del></h2><p>&emsp;&emsp;CSS 2 对于 display 属性使用单关键字语法，对于相同布局模式的 block 级和 inline 级变体需要使用单独的关键字。<br>&emsp;&emsp;inline-block：行内块元素，等同于inline flow-root<br>&emsp;&emsp;inline-table：此元素会作为内联表格来显示（类似 table），表格前后没有换行符，等同于inline table<br>&emsp;&emsp;<strong>inline-flex：元素的行为类似于内联元素，并根据flexbox模型布置其内容，等同于inline flex</strong><br>&emsp;&emsp;<strong>inline-grid：元素的行为类似于内联元素，并根据网格模型布置其内容，等同于inline grid</strong></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS动画（时序函数、缓动函数、canvas粒子动画）</title>
    <url>/2021/01/02/javascript/JS%E5%8A%A8%E7%94%BB%EF%BC%88%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0%E3%80%81%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E3%80%81canvas%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%EF%BC%89/</url>
    <content><![CDATA[<p>CSS动画很强大，特别是CSS3动画。可以进行通过transform的2D/3D变换，以及改变高宽，方位，角度，透明度等，再结合transition过渡属性或者@keyframes规则，能做到几乎完美。但CSS动画也有一些局限，比如不能设置浏览器相关的属性，如scrollTop等。且对于canvas等动画（以及粒子动画），还是要利用计时器（setTimeout、setInterval）或者浏览器重绘回调函数（requestAnimationFrame），通过JavaScript动态更新元素状态来实现。此外，canvas小游戏的逻辑实现也必须使用JavaScript去处理用户鼠标键盘等交互事件，才能完成对应的动画以及功能。JavaScript动画还可以实现沿着其他<strong>自定义时序函数</strong>的进行移动与变化。</p>
<h2 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h2><h4 id="1）setTimeout（setInterval）与requestAnimationFrame对比"><a href="#1）setTimeout（setInterval）与requestAnimationFrame对比" class="headerlink" title="1）setTimeout（setInterval）与requestAnimationFrame对比"></a>1）setTimeout（setInterval）与requestAnimationFrame对比</h4><p>&emsp;&emsp;(1)setTimeout/setInterval：</p>
<p>&emsp;&emsp;① 计时器的回调的执行时是在内存中对元素属性进行相应的改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上（一般为16.7ms刷新一次）。setTimeout的执行步调和屏幕的刷新步调不一致。就会导致中间某些帧的更新被跳过，照成动画卡顿。比如计时器设置10ms更新一次（帧），而屏幕刷新时间间隔为16.7ms，此时就会出现丢帧现象(即有的内存中元素状态的更新（帧）没来得及被浏览器渲染就被覆盖了)。其实只要计时器设置的更新时间小于16.7ms，就会导致丢帧。<br>&emsp;&emsp;② setTimeout/setInterval 放在异步队列里执行，主线程同步任务会阻塞异步队列的任务，设置的间隔时间不一定是回调执行的时间间隔。同样会造成动画卡顿（停顿）的现象。</p>
<p><em>&emsp;&emsp;[注] 前面已讲过 <a href="/2020/12/25/javascript/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">定时器相关概念</a>，可点击查看~</em></p>
<p>&emsp;&emsp;③ 使用setTimeout等实现的动画，当页面被隐藏或最小化时，setTimeout仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画浪费 CPU 资源和电池寿命。</p>
<p>&emsp;&emsp;(2) requestAnimationFrame（标准动画时序，浏览器在下次重绘之前调用指定的回调函数来更新动画）：</p>
<p>&emsp;&emsp;① 与setTimeout等相比，requestAnimationFrame最大的优势是由浏览器来决定回调函数的执行时机，即紧跟浏览器的刷新步调，不会出现丢帧现象。</p>
<p>&emsp;&emsp;② 当页面处于未激活的状态下，该页面的屏幕绘制任务也会被浏览器暂停，跟着浏览器步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画才会恢复继续执行，有效节省了 CPU 资源与电池寿命。<br>&emsp;&emsp;③ 在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame 有节流的作用，可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。</p>
<p><em>&emsp;&emsp;[注] 通过对比，requestAnimationFrame 要比 setTimeout/setInterval 性能好。<u>特别的，requestAnimationFrame回调函数会被传入DOMHighResTimeStamp参数（一个double类型，用于存储毫秒级的时间值），DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳。</u></em></p>
<h4 id="2）JS动画中的时序函数"><a href="#2）JS动画中的时序函数" class="headerlink" title="2）JS动画中的时序函数"></a>2）JS动画中的时序函数</h4><p>&emsp;&emsp;<u>时序函数就是动画完成情况与时间的关系（一般时序函数的图像也是从（0,0）变化到（1,1），代表动画执行时间到达时动画刚好执行完成）。</u>在JS动画中我们可以更灵活的自定义这种关系，即定义更加多样的时序函数，例如n次幂等满足经过（0,0）变化到（1,1）的曲线都可以作为时序函数。</p>
<p>&emsp;&emsp;为了代码的结构以及代码的可复用，这里编写一个<u>通用的动画函数</u>，放在单独的animate.js文件中：（其中时序函数timing也作为参数传入）</p>
<pre><code>  // animate.js
  function animate(&#123; duration, timing, draw &#125;) &#123;
    let startTime = performance.now(); // 获得一个一个精确到毫秒的DOMHighResTimeStamp来标识动画开始时间
    requestAnimationFrame(function animate(executionTime) &#123; // executionTime为requestAnimationFrame的本次回调函数触发执行时间
      let time = (executionTime - startTime) / duration; // 计算当当前动画已经执行时间与动画延迟总时间的比值，
      // 其值为时序函数的x轴的值（为0代表动画开始执行，1代码动画执行结束）
      if (time &gt; 1) time = 1;
      let progress = timing(time) // 计算当前时间节点动画完成进度，其值为时序函数y轴的值
      draw(progress); // 根据当前动画完成进度更新动画
      if (time &lt; 1) &#123; // 动画未完成，继续更新
        requestAnimationFrame(animate); // 这里animate为function animate(executionTime)&#123;...&#125;函数
      &#125;
    &#125;);
  &#125;
</code></pre>
<p>&emsp;&emsp;其中duration，timing，draw分别代码动画执行时间（ms）,时序函数，元素状态更新函数。首先调用performance.now()获取动画开始执行的精确时间，然后再根据当前动画执行的时间根据时序函数计算出当前动画应完成的状态，然后调用draw方法更新元素状态。动画若未完成，继续执行。</p>
<p>&emsp;&emsp;还是用 <a href="/2020/11/26/css/CSS%E5%8A%A8%E7%94%BB%EF%BC%88%E8%BF%87%E6%B8%A1%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E3%80%813%E6%AC%A1%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%89/#CSS%E5%8A%A8%E7%94%BB">《CSS动画》</a> 中小球移动的示例，这里我们采用一个 y=Math.pow(2, 10 * (x - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * x) 的时序函数来定义动画，时序函数的图像为：</p>
<p><img src="/images/javascript/Js%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0.png" alt="Js自定义时序函数"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
  
    #ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/animate.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    document.getElementById(&quot;ball&quot;).onclick = function () &#123;
      animate(&#123;
        duration: 3000,
        timing: function (time) &#123;
          return Math.pow(2, 10 * (time - 1)) * Math.cos(20 * Math.PI * 1.5 / 3 * time)
        &#125;,
        draw: function (progress) &#123;
          document.getElementById(&quot;ball&quot;).style.marginLeft = 250 * progress + &#39;px&#39;;
        &#125;
      &#125;);
    &#125;;
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;动画效果：</p>
<p><img src="/images/javascript/Js%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB.gif" alt="Js时序动画"></p>
<p>&emsp;&emsp;先引入我们animate.js文件，给小球添加onclick点击事件，事件回调函数里为小球创建动画：动画时长3s，时序函数为我们自定义较为复杂的函数（这个时序函数不是CSS里的3次贝塞尔曲线函数，这个动画仅使用CSS无法完成），然后再是小球状态更新的方法，根据动画的完成状态向右移动小球直至移动250px，即到达外层div最右侧时动画完成。</p>
<h4 id="3-JS动画中的缓动函数"><a href="#3-JS动画中的缓动函数" class="headerlink" title="3) JS动画中的缓动函数"></a>3) JS动画中的缓动函数</h4><p>&emsp;&emsp;与时序函数类似，在JS动画中，我们可以也用缓动公式来控制每帧动画中个元素的状态，来实现各种动画效果。<u>缓动函数是根据元素状态的初始值、变化量、当前时间与动画总持续时间按照一定的变化规则来控制元素的状态，比时序函数更加灵活，在实际使用应用中也更加常用。</u>著名的缓动公式算法是Tween.js缓动算法。部分代码如下：</p>
<pre><code>  /*
  * Tween.js
  * t: current time（当前时间）；
  * b: beginning value（初始值）；
  * c: change in value（总变化量）；
  * d: duration（持续时间）。
  */
  var Tween = &#123;
      Linear: function(t, b, c, d) &#123; 
          return c * t / d + b; 
      &#125;,
      Sine: &#123;
          easeIn: function(t, b, c, d) &#123;
              return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
          &#125;,
          easeOut: function(t, b, c, d) &#123;
              return c * Math.sin(t/d * (Math.PI/2)) + b;
          &#125;,
          easeInOut: function(t, b, c, d) &#123;
              return -c / 2 * (Math.cos(Math.PI * t/d) - 1) + b;
          &#125;
      &#125;
    // .....(其他代码省略）
  &#125;
  Math.tween = Tween;
  
  // 测试Tweem.js算法
  // 1、测试匀速运动
  console.log(&#39;1、匀速算法，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);
  console.log(Math.tween.Linear(5,0,100,10)); // 50
  // 2、测试正弦曲线
  console.log(&#39;2、测试正弦曲线，当前动画执行时间为第5s中，元素从0px的位置移动到100px的位置，动画持续10s。当前元素所在位置(px)为：&#39;);
  console.log(Math.tween.Sine.easeIn(5,0,100,10)); // 29.289321881345245
</code></pre>
<p>&emsp;&emsp;算法中的4个参数分别他，t，b，c，d分别表示动画执行到当前帧的时间，元素的初始状态，动画过程中元素状态的变化量以及动画持续时间。如添加的测试1代码所示：有一个小球从0px的位置要移动到100px的位置，初始状态的坐标为0px，坐标的总变化量为100px(100px - 0px = 100px)，假设动画持续时间为10s，传入动画当前帧的时间5s，调用Tween.js的线性渐变算法就能得到当前小球应该处于50px的位置；调用正弦曲线算法能得到当前小球处于约29px的位置。从而以此来控制流畅的动画。</p>
<p>&emsp;&emsp;在Tween.js中，常用的经典动画场景都已实现，除了Linear，其余每种场景都有easeIn、easeOut和easeInOut方法，具体动画场景如下：<br>&emsp;&emsp;Linear：线性匀速运动效果；<br>&emsp;&emsp;Quadratic：二次方的缓动（t^2）；<br>&emsp;&emsp;Cubic：三次方的缓动（t^3）；<br>&emsp;&emsp;Quartic：四次方的缓动（t^4）；<br>&emsp;&emsp;Quintic：五次方的缓动（t^5）；<br>&emsp;&emsp;Sinusoidal：正弦曲线的缓动（sin(t)）；<br>&emsp;&emsp;Exponential：指数曲线的缓动（2^t）；<br>&emsp;&emsp;Circular：圆形曲线的缓动（sqrt(1-t^2)）；<br>&emsp;&emsp;Elastic：指数衰减的正弦曲线缓动；<br>&emsp;&emsp;Back：超过范围的三次方缓动（(s+1)<em>t^3 – s</em>t^2）；<br>&emsp;&emsp;Bounce：指数衰减的反弹缓动。</p>
<p>&emsp;&emsp;还是小球移动的例子，这里简单应用一下Tween.js的方法，代码如下：</p>
<pre><code>  &lt;style&gt;
    .box &#123;
      width: 300px;
      border: 1px solid #666;
      cursor: pointer;
    &#125;
    #ball &#123;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: chocolate;
      margin-left: 0;
    &#125;
  &lt;/style&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;ball&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt; // 引入Tween.js文件
  &lt;script&gt;
    let duration = 3000;
    let startTime = performance.now(); // 动画持续时间
    let currentMarginLeft = 0;
    requestAnimationFrame(function update(executionTime) &#123;
      currentMarginLeft = Math.tween.Linear(executionTime, 0, 250, duration);  // 匀速线性变化
      // currentMarginLeft = Math.tween.Elastic.easeInOut(executionTime, 0, 250, duration); // 衰减的正弦曲线变化
      // currentMarginLeft = Math.tween.Bounce.easeOut(executionTime, 0, 250, duration); // 指数衰减反弹变化
      document.getElementById(&quot;ball&quot;).style.marginLeft = currentMarginLeft + &#39;px&#39;;
      if (executionTime &lt;= duration) &#123;
        requestAnimationFrame(update)
      &#125;
    &#125;);
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;分别采用匀速、衰减正弦曲线以及指数衰减反弹对小球的margin-left属性进行相应变化，动画效果依次为：<br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB1.gif" alt="Tween时序动画1"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB2.gif" alt="Tween时序动画2"><br><img src="/images/javascript/Tween%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB3.gif" alt="Tween时序动画3"></p>
<h4 id="4-canvas粒子动画"><a href="#4-canvas粒子动画" class="headerlink" title="4) canvas粒子动画"></a>4) canvas粒子动画</h4><p>&emsp;&emsp;canvas元素以及基础的动画，已在另一篇文章<a href="/2020/09/15/HTML%20Canvas%EF%BC%882D%E6%97%B6%E5%BA%8F%E5%8A%A8%E7%94%BB%EF%BC%89">《HTML Canvas（2D时序动画）》</a>讲到，canvas画布的上下文ctx对象有对应的API用，可以对相关元素进行旋转、缩放、位移、形变，也可以用martrix方式做更高级的变化。<u>canvas图像处理也可以用于图像压缩，图像裁剪，图像合成、图像滤镜、图像取色器、抠图等功能。</u>不过这里主要补充canvas粒子动画的实现：</p>
<p>&emsp;&emsp;canvas中的粒子，其实是对一个像素的抽象。它具有自己坐标，自己的色值，可以通过改变自身的属性使其按照一定的规律运动起来便可形成相应的粒子动画。<br>&emsp;&emsp;一般我们将粒子用一个对象抽象出来，形如：let particle = { x: 0, y: 0, rgba: ‘(0, 0, 0, 1)’ }，这个过程称为粒子对象化，实际制作粒子动画的过程是对这些粒子对象的属性（如位置，颜色等）进行相应的变化。<br>&emsp;&emsp;为了动画更加自然，我们一般不会采用匀速的变化，而是加入相应的时序函数来控制粒子运动效果，使粒子变化或快或慢，更加自然。<br>&emsp;&emsp;一般为了性能，我们不会把图像所有像素点都抽象出来，因为requestAnimationFrame，正常的情况下一般刷新频率在60HZ，能展现非常流畅的动画。但现在如果要处理庞大的粒子对象数据，浏览器处理压力太大，就会造成了降频现象，导致动画出现卡帧（卡顿）现象。一般我们选择性的来抽象粒子对象：抽象像素点r色值为155以上并且坐标为偶数的像素点；或隔一定距离(像素)用一个粒子来抽象一个像素块（连续多个像素组成）。这样抽象的粒子数量不会影响图像效果的展示，动画的处理过程来也比较流畅。</p>
<p>&emsp;&emsp;<strong>为了更好抽象粒子对象以及其色值信息，补充一个canvas图像滤镜处理的示例来引入<u>canvas像素图像信息</u>的概念：</strong></p>
<p>&emsp;&emsp;先介绍要用到的canvas的3个API：<br>&emsp;&emsp;① <strong>getImageData()</strong>：获得一个ImageData对象</p>
<pre><code>  ctx.getImageData(sx, sy, sw, sh); // 返回ImageData对象
</code></pre>
<p>&emsp;&emsp;ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：width、height、data，分别代表图片宽度(单位px)、高度(单位px)、像素数据（Uint8ClampedArray类型）。</p>
<p>&emsp;&emsp;其中data属性返回像素信息是一个 类型Uint8ClampedArray的一维数组。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份R的色值保存在数组的索引0位置。像素从左到右被处理，然后往下。Uint8ClampedArray  包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1，具体如下：</p>
<p><img src="/images/javascript/ImageData.png" alt="ImageData"></p>
<p>&emsp;&emsp;如图所示，ImgaeData的data属性保存了图片每个像素的RAGA色值信息。第一个像素点的色值RGBA分别保存在Uint8ClampedArray数组索引0到3的位置，第二个像素点的色值保存在数组索引4-7的位置，先行后列，以此类推…。能很容易得到第i行第j列像素点的色值R保存在ImageData.data数组索引 [(j - 1) * width + (i - 1) ] * 4的位置。若像素点色值R在数组的索引为index，则每个像素的位置(i, j)与index的关系为：index=[(j - 1) * width + (i - 1) ] * 4，色值G的索引为index+1，色值B的索引为index+2，透明度A的索引为index+3。 </p>
<p>&emsp;&emsp;② <strong>createImageData()</strong>：Canvas 2D API 创建一个新的、空白的、指定大小的 ImageData 对象。 所有的像素在新对象中都是透明的</p>
<pre><code>  ctx.createImageData(width, height); // 返回ImageData对象
  ctx.createImageData(imagedata); // 返回ImageData对象
</code></pre>
<p>&emsp;&emsp;③ <strong>putImageData()</strong>：Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法</p>
<pre><code>  ctx.putImageData(imagedata, dx, dy);
  ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
</code></pre>
<p>&emsp;&emsp;canvas图像滤镜处理效果：</p>
<p><img src="/images/javascript/canvas%E5%9B%BE%E5%83%8F%E6%BB%A4%E9%95%9C%E5%A4%84%E7%90%86.png" alt="canvas图像滤镜处理"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
  &lt;script&gt;
    const TYPE = &#39;grayscale&#39;; // grayscale - 灰度(默认)、sepia - 复古、inert - 反向
    let canvas = document.getElementById(&#39;canvas&#39;);
    let ctx = canvas.getContext(&#39;2d&#39;);
    const img = document.createElement(&#39;img&#39;);
    img.src = &#39;/img/filter.jpg&#39;;
    img.addEventListener(&#39;load&#39;, () =&gt; &#123;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0); // 将原图渲染到canvas画布上
      let originImage = ctx.getImageData(0, 0, canvas.width, canvas.height); // 获取图片像素信息
      let outputImage = filter(originImage, TYPE); // 按照滤镜风格处理像素信息
      ctx.putImageData(outputImage, 0, 0); // 将处理后的像素信息覆盖到canvas画布上
    &#125;)
    function filter(originImage, type) &#123; // 图像处理函数
      let index, r, g, b;
      let originImageData = originImage.data;
      let width = originImage.width;
      let height = originImage.height;
      let outputImage = ctx.createImageData(width, height);
      let outputImageData = outputImage.data;
      for (let x = 1; x &lt;= width; x++) &#123;
        for (let y = 1; y &lt;= height; y++) &#123;
          index = [(y - 1) * width + (x - 1)] * 4;
          r = originImageData[index];
          g = originImageData[index + 1];
          b = originImageData[index + 2];
          if (type == &#39;sepia&#39;) &#123; // 复古滤镜风格下对色值的处理
            outputImageData[index] = (r * 0.393) + (g * 0.769) + (b * 0.189);
            outputImageData[index + 1] = (r * 0.349) + (g * 0.686) + (b * 0.168);
            outputImageData[index + 2] = (r * 0.272) + (g * 0.534) + (b * 0.131);
          &#125; else if (type == &#39;inert&#39;) &#123; // 反向滤镜风格下对色值的处理
            outputImageData[index] = 255 - r;
            outputImageData[index + 1] = 255 - g;
            outputImageData[index + 2] = 255 - b;
          &#125; else &#123; // 灰度滤镜风格下对图像的处理
            outputImageData[index] = outputImageData[index + 1] = outputImageData[index + 2] = (r + g + b) / 3;
          &#125;
          outputImageData[index + 3] = 255;
        &#125;
      &#125;
      return outputImage;
    &#125;
  &lt;/script&gt;
</code></pre>
<p>&emsp;&emsp;简单说明：思路就是先讲图片渲染到canvas画布上，再调用getImageData()方法获得canvas元素上的像素信息。根据滤镜风格分别对像素信息进行相应的处理，最后调用putImageData()方法将imageData对象渲染(覆盖)到canvas画布上即可。示例中我们已经获取到了画布上图像的像素信息，也以利用获取到的图片像素信息，监听鼠标指针相对于画布的水平垂直方向偏移的距离（px）获得当前鼠标指针指向的像素点(i, j)的位置，可以做<u>图像取色器</u>等功能。</p>
<p>&emsp;&emsp;正式介绍<u>粒子动画</u>，先看效果：</p>
<p><img src="/images/javascript/Js%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB.gif" alt="Js粒子动画"></p>
<p>&emsp;&emsp;代码如下：</p>
<pre><code>  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;canvas粒子动画&lt;/title&gt;
    &lt;style&gt;
      body &#123; background: midnightblue; margin: 0; padding: 0; &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;!-- 使用Tween.js缓动函数控制动画 --&gt;
    &lt;script src=&quot;js/Tween.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let cw = document.documentElement.clientWidth;
      let ch = document.documentElement.clientHeight;
      let maxDelay = 0; // 保存粒子动画开始最长延时时间，用于动画完成介绍requestAnimationFrame动画回调
      let canvas = document.getElementById(&#39;canvas&#39;);
      let ctx = canvas.getContext(&#39;2d&#39;);
      const img = document.createElement(&#39;img&#39;);
      img.src = &#39;/img/canvas-img.jpg&#39;;
      img.addEventListener(&#39;load&#39;, () =&gt; &#123;
        canvas.width = cw;
        canvas.height = ch;
        console.log(cw, ch)
        let sx = (cw / 2) - (img.width / 2); // 把图片画在canvas(屏幕)中间
        ctx.drawImage(img, sx, 0, img.width, img.height);
        let originImage = ctx.getImageData(0, 0, cw, ch);
        let particles = dataToObject(originImage.data, originImage.width, originImage.height);
        draw(particles);
      &#125;)
  
      function dataToObject(imageData, width, height) &#123; // 粒子对象化函数
        let inx;
        let particle = &#123;&#125;;
        let particles = [];
        let threshold = 50; // 设置色值阈值，颜色较浅的像素不进行粒子对象化操作
        let delay = 0;
        for (let x = 1; x &lt;= width; x += 2) &#123;
          for (let y = 1; y &lt;= height; y += 2) &#123;
            inx = [(y - 1) * width + (x - 1)] * 4;
            if ((imageData[inx] + imageData[inx + 1] + imageData[inx + 2]) / 3 &gt; threshold) &#123;
              delay = Math.random() * 3000;
              maxDelay &lt; delay &amp;&amp; (maxDelay = delay)
              particle = &#123;
                x0: 100,
                y0: ch,
                x1: x - 1,
                y1: y - 1,
                delay: delay,
                rgba: `rgba($&#123;imageData[inx]&#125;, $&#123;imageData[inx + 1]&#125;, $&#123;imageData[inx + 2]&#125;, $&#123;imageData[inx + 3]&#125;)`
              &#125;;
              particles.push(particle);
            &#125;
          &#125;
        &#125;
        return particles;
      &#125;
      
      function draw(particles) &#123; //画图
        let duration = 5000; // 动画持续时间
        let particle, cur_x, cur_y, cur_time;
        let startTime = performance.now(); // 动画开始时间
        let AnimationFrameId = requestAnimationFrame(function update(executionTime) &#123; // 每帧更新画布
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0, len = particles.length; i &lt; len; i++) &#123;
            particle = particles[i]
            if (executionTime &gt; particle.delay + duration) &#123;
              ctx.fillStyle = particle.rgba;
              ctx.fillRect(particle.x1, particle.y1, 1, 1)
            &#125; else if (executionTime &gt; particle.delay) &#123;
              ctx.fillStyle = particle.rgba;
              cur_time = executionTime - particle.delay;
              cur_x = Math.tween.Elastic.easeInOut(cur_time, particle.x0, particle.x1 - particle.x0, duration);
              cur_y = Math.tween.Bounce.easeOut(cur_time, particle.y0, particle.y1 - particle.y0, duration);
              ctx.fillRect(cur_x, cur_y, 1, 1)
            &#125;
          &#125;
          if (executionTime &gt; maxDelay + duration) &#123;
            cancelAnimationFrame(AnimationFrameId);
          &#125;else&#123;
            AnimationFrameId = requestAnimationFrame(update)
          &#125;
        &#125;);
      &#125;
    &lt;/script&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
<p>&emsp;&emsp;实现思路：使用drawImage()方法将图片对象先放在画布上，然后调用getImageData()获取图片的像素信息。<u>根据将像素信息，生成对象来表示每个像素点的信息，对象属性包括初始位置，结束位置（像素点在canvas画布中原本的位置），颜色等信息。</u>这里为了然动画效果更加自然协调，加入了动画开始延迟时间delay属性。然后根据Tween.js缓动函数对粒子从初始位置移动到对应的结束位置的状态进行控制，调用requestAnimationFrame()方法设置回调来对粒子对象的状态进行刷新，便形成了动画。<br><em>&emsp;&emsp;[注] 有时我们会加入阈值（如代码中设置的阈值threshold为50）、增加对象化像素点的间距（如代码中循环粒子对象化操作时循环步长为2）来减少生成的对象数量，从而减少浏览器每一帧的处理压力，使动画更加流畅自然。</em></p>
<p>&emsp;&emsp;代码中的dataToObject()函数完成的功能就是用对象去标识图像的像素信息，每个对象表示一个像素点，即我们所说的‘粒子’。<u>实际上，粒子动画并不是总要使用getImageData()去抽象图片的信息，然后生成粒子对象。有时我们会直接构造出粒子类，按照我们的需求生成粒子对象，然后根据一定的规则使粒子运动起来即可。粒子动画本质是canvas动画，还可以与鼠标等输入设备交互，作出像放烟花、炫彩小球、小球自由落体、球体运动碰撞等有趣的动画。</u></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS原型（prototype）链与继承（Class）</title>
    <url>/2020/12/23/javascript/JS%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Class%EF%BC%89/</url>
    <content><![CDATA[<p>在JavaScript中，每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。几乎所有 JavaScript 中的对象都是位于原型链顶端的Object对象的实例。</p>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>&emsp;&emsp;对象：对象是一个包含相关数据和方法的集合，通常由一些变量和函数组成，我们称之为对象里面的属性和方法。对象成员的值可以是任意的，例如Number，String，Function，null， undefined等。</p>
<p><em>&emsp;&emsp;[注1] 可以使用点表示法或者括号([ ])表示法访问对象的成员，对象做了字符串(key)到值(value)的映射，而数组做的是数字(索引)到值的映射。其中，括号表示法一个特别的地方是不仅可以动态的去设置对象成员的值，还可以动态的设置成员的名字(key)。</em><br><em>&emsp;&emsp;[注2] 可以用一个对象来做另一个对象成员的值，这样，实际上创建了一个子命名空间，可以链式的使用点表示法或括号表示法去访问其中的成员变量。</em></p>
<p>&emsp;&emsp;<u>面向对象的JavaScript</u>（OOJS）：面向对象编程（OOP）的基本思想为，在程序里，我们通过使用对象去构建现实世界的模型，把原本很难（或不可）能被使用的功能，简单化并提供出来，以供访问。对象可以包含相关的数据和代码，去描述模型以及模型具有的行为和功能。对象包（命名空间）存储（封装）着对象的数据与方法，使数据的组织和访问变得更容易了；对象也常用作数据存储体，用于在网络上运输数据，十分便捷。</p>
<p>&emsp;&emsp;<u>构造函数对象</u>：JavaScript 用一种称为构建函数的特殊函数(function)来定义对象和它们的特征。一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。关键字 new 跟着一个含参构造函数，便能创建一个想要的对象（对象的原型指向构建函数）。其中，这个构建函数是 JavaScript 版本的类（<u>ES6已提供class关键字的语法糖定义构建函数</u>）。</p>
<p><em>&emsp;&emsp;[注] 其他创建对象的方式：</em><br><em>&emsp;&emsp;① 字面量定义对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;② Object()构造函数，即使用new Object()创建对象（对象的原型指向Object对象）</em><br><em>&emsp;&emsp;③ Object.create()方法，允许您基于现有对象创建新的对象。（对象的原型指向创建时指定的对象）</em></p>
<h2 id="1、原型（链）"><a href="#1、原型（链）" class="headerlink" title="1、原型（链）"></a>1、原型（链）</h2><p>&emsp;&emsp;JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层，以此类推。这种关系常被称为原型链，它解释了为何一个对象会拥有定义在其他(被继承)对象中的属性和方法。比如有些属性和方法定义在Object的构造器函数的prototype属性上，而非定义在当前对象实例本身。</p>
<p><em>&emsp;&emsp;<strong>[注1] 与传统OOP的区别：在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到例中。<u>在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是 __proto__ 属性，是从构造函数的 prototype 属性派生的），</u>可通过其上溯原型链，在构造器中找到对应的属性和方法。</strong></em><br><em>&emsp;&emsp;[注2] 对象原型（可以通过Object.getPrototypeOf(obj)或者浏览器提供的__proto__属性获得）与构造函数的prototype属性是有区别的：前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Bool())和Bool.prototype指向着同一个对象(Bool构造函数)。<u>特别的，没有官方的方法用于直接访问一个对象的原型——原型链中的“连接”被定义在一个内部属性中，</u>在 JavaScript 语言标准中用 [[prototype]] 表示，大多数现代浏览器还是提供了一个名为 __proto__ 属性，其包含了对象的原型。</em></p>
<p>&emsp;&emsp;(1) prototype属性：继承成员被定义的地方<br>&emsp;&emsp;继承的属性和方法是定义在 prototype 属性之上的（可以称之为子命名空间），prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。<br><em>&emsp;&emsp;[注] Object.create()可以指定一个对象作为原型对象来创建一个实例对象。</em></p>
<p>&emsp;&emsp;(2) constructor属性：指向了用于构造此实例对象的构造函数<br>&emsp;&emsp;每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。<br>&emsp;&emsp;在某些情况下，没有原始构造器的引用，想要构造实例可以通过已有实例的constructor属性指向的构造函数来完成。即可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），只需在前面添加 new 关键字（let person2 = new person1.constructor()），便能将此函数作为构造器使用，从而调用这个构造器创建另一个对象实例。</p>
<p><em>&emsp;&emsp;[注] 构建函数前new关键字做了什么？</em><br><em>&emsp;&emsp;① 创建一个新对象</em><br><em>&emsp;&emsp;② 将新对象的__proto__属性指向了构建函数对象prototype对象</em><br><em>&emsp;&emsp;③ 将构建函数的this修正为指向新对象，执行构造函数中的代码，即为这个新对象添加对应属性</em><br><em>&emsp;&emsp;④ 返回新对象</em></p>
<pre><code>  var obj = &#123;&#125;;
  obj.__proto__ = Base.prototype;
  Base.call(obj);
</code></pre>
<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><h4 id="JavaScript基于原型链继承（prototypal-inheritance）"><a href="#JavaScript基于原型链继承（prototypal-inheritance）" class="headerlink" title="JavaScript基于原型链继承（prototypal inheritance）"></a>JavaScript基于原型链继承（prototypal inheritance）</h4><p>&emsp;&emsp;如何实现继承：（这里以Teacher构造函数继承于Person构造函数的例子来说明）<br>&emsp;&emsp;(1) 定义构造器（构造函数），这里定义构造函数Person。</p>
<pre><code>  function Person(name, age, gender, interests) &#123;
    this.name =name;
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  &#125;;
  Person.prototype.greeting = function() &#123;
    console.log(`hello, I am $&#123;name&#125;!`)
  &#125;;
</code></pre>
<p>&emsp;&emsp;(2) 创建继承于Person构造函数的Teacher构造函数，并为Teacher 构造函数添加特有的subject（所授学科科目）属性。</p>
<pre><code>  function Teacher(name, age, gender, interests, subject) &#123;
    // 创建一个新的对象实例时同时指派其继承的属性（修正this指向Teacher()函数）
    Person.call(this, name, age, gender, interests);
    this.subject = subject;
    
    // 利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，从而继承其属性与方法
    Teacher.prototype = Object.create(Person.prototype);
    
    // 修正Teacher构造器指向，使之与Teacher关联(修正前指向Person)
    Teacher.prototype.constructor = Teacher;
  &#125;
</code></pre>
<p><em>&emsp;&emsp;[注] 每一个函数对象（Function）都有一个 prototype 属性，并且只有函数对象有 prototype 属性，因为 prototype 本身就是定义在Function对象下的属性。其中Person()函数是Person.prototype的构造函数，即Person===Person.prototype.constructor。任何您想要被继承的方法都应该定义在构造函数的 prototype 对象里，并且永远使用父类的 prototype 来创造子类的 prototype，这样才不会打乱类继承结构。</em></p>
<p>&emsp;&emsp;(3) Teacher构造函数添加新的greeting成员函数</p>
<pre><code>  Teacher.prototype.greeting = function()&#123;
    console.log(`hello, I am a teather, I teath $&#123;this.subject&#125;`)
  &#125;
</code></pre>
<p>&emsp;&emsp;(4) 生成对应的teacher实例</p>
<pre><code>  let t = new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath englis
</code></pre>
<p>&emsp;&emsp;所有代码：</p>
<pre><code>  function Person(name, age, gender, interests) &#123;    
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  &#125;;
  Person.prototype.greeting = function () &#123;
    console.log(`hello, I am $&#123;name&#125;!`);
  &#125;;
  function Teacher(name, age, gender, interests, subject) &#123;
    // 创建一个新的对象实例时同时指派其继承的所有属性（修正this指向Teacher()函数）
    Person.call(this, name, age, gender, interests);
    this.subject = subject;
    // Teacher.prototype现在会继承Person.prototype的所有属性和方法
    Teacher.prototype = Object.create(Person.prototype);
    // 修正Teacher()的prototype的constructor属性指向(修正前指向Person，不正确)
    Teacher.prototype.constructor = Teacher;
  &#125;
  Teacher.prototype.greeting = function()&#123;
    console.log(`hello, I am a teather, I teath $&#123;this.subject&#125;`)
  &#125;
  let t = new Teacher(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath englis
</code></pre>
<h4 id="ES6-类（class）"><a href="#ES6-类（class）" class="headerlink" title="ES6 类（class）"></a>ES6 类（class）</h4><p>&emsp;&emsp;(1) 类的定义方式<br>&emsp;&emsp;ES6 提供了更接近传统语言的写法，引入了class关键字（仅是一个‘语法糖’），可以定义类。可以使编码时逻辑更加清晰明了。在JavaScript中，类是一种“特殊的函数”。类本身就指向构造函数。</p>
<p><em>&emsp;&emsp;[注] 类都在严格模式下执行。类的内部所有定义的方法，都是不可枚举的（这点与 ES5 定义在 prototype 上的方法表现不一致）。定义类的实例必须使用new关键字（不能像 ES5 中的构造函数可直接调用）。</em></p>
<p>&emsp;&emsp;定义类有两种方式：<br>&emsp;&emsp;类声明：class A {}，<strong>类声明不会提升，需要先声明，再访问</strong><br>&emsp;&emsp;类表达式: let B = class [B2] {}，类表达式的命名是可选的（比如这里命名为B2），名称称为局部名称，可使用类的name属性访问对应名称</p>
<p><em>&emsp;&emsp;<strong>[注] 类中的this：</strong></em><br>&emsp;&emsp;① 在构造函数constructor()中基类与派生类this表现形式不同：在基类（类的构造函数constructor中），this是一个常规对象（指向实例），所有非静态方法会被添加到this的原型中。在派生类（子类）中的构造函数没有初始的this绑定（undefined），在构造函数中调用super()才能生成一个this绑定（返回一个指向当前派生类的this）。<br>&emsp;&emsp;② 静态方法不是this的属性，它们只是类自身的属性，不会被子类继承。派生类在super()前调用this会抛出异常，派生类不能在调用super()前返回，除非没有构造函数或者构造函数返回了对象。<br>&emsp;&emsp;③ 使用super对象时，super 调用父类的方法时，super 会绑定子类的 this。</p>
<p>&emsp;&emsp;(2) constructor()构造函数<br>&emsp;&emsp;初始化一个由class创建的对象。一个类中只能有唯一的constructor()方法，若代码未显式的定义，会默认添加该方法。在使用new关键字创建实例时，会执行该方法，其中的this指向创建的实例。默认会返回this实例，不过也可以显式的返回一个对象。</p>
<p>&emsp;&emsp;(3) super关键字<br>&emsp;&emsp;分为两种情况：<br>&emsp;&emsp;当做 super() 函数使用：这个函数会调用父类的构造函数，返回一个指向当前派生类的this，相当于A.prototype.constructor.call(this, props)<br>&emsp;&emsp;当做 super 对象使用：在普通方法中，super 指向父类的原型对象；在静态方法中，super 指向父类</p>
<p><em>&emsp;&emsp;[注] 静态方法，static修饰，可以被子类继承，但不会添加到类的实例上，方法名称可与其他方法重名。静态方法可以通过super调用。</em></p>
<p>&emsp;&emsp;(4) 取值函数（getter）和存值函数（setter）<br>&emsp;&emsp;在类中内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为（ES5可以提供getter、setter函数）。</p>
<p>&emsp;&emsp;(5) new.target属性<br>&emsp;&emsp;new命令的一个属性，只能在构造函数中使用。在类中使用时，返回当前类；在子类中使用时，返回当前子类。<u>用途：可以限制类只能通过new命令调用；或者编写只能继承而不能实例化的基类。</u></p>
<p>&emsp;&emsp;通过ES6 Class关键字实现上面Teacher类与Person类的继承关系：</p>
<pre><code>  class Person&#123;    
    constructor(name, age, gender, interests)&#123;
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.interests = interests;
    &#125;
    greeting()&#123;
      console.log(&quot;hello, I am &quot; + this.name + &quot;!&quot;);
    &#125;
  &#125;
  class Teather extends Person&#123;
    constructor(name, age, gender, interests, subject)&#123;
      super(name, age, gender, interests);
      this.subject = subject;
    &#125;
    greeting()&#123;
      console.log(&quot;hello, I am a teather, I teath &quot; + this.subject + &quot;!&quot;);
    &#125;
  &#125;
  let t = new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting() // hello, I am a teather, I teath english!
</code></pre>
<p>&emsp;&emsp;通过Babel.js将上面的ES6转换为ES5代码如下：</p>
<pre><code>  &quot;use strict&quot;;

  function _typeof(obj) &#123;
    &quot;@babel/helpers - typeof&quot;;
    if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) &#123; _typeof = function _typeof(obj) &#123; return typeof obj; &#125;; &#125;
    else &#123;
      _typeof = function _typeof(obj) &#123;
        return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;
      &#125;;
    &#125;
    return _typeof(obj);
  &#125;
  
  function _inherits(subClass, superClass) &#123;
    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123;
      throw new TypeError(&quot;Super expression must either be null or a function&quot;);
    &#125;
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125; &#125;);
    if (superClass) _setPrototypeOf(subClass, superClass);
  &#125;
  
  function _setPrototypeOf(o, p) &#123;
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123;
      o.__proto__ = p; return o;
    &#125;;
    return _setPrototypeOf(o, p);
  &#125;
  
  function _createSuper(Derived) &#123;
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() &#123;
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) &#123;
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      &#125; else &#123;
        result = Super.apply(this, arguments);
      &#125;
      return _possibleConstructorReturn(this, result);
    &#125;;
  &#125;
  
  function _possibleConstructorReturn(self, call) &#123;
    if (call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)) &#123;
      return call;
    &#125;
    return _assertThisInitialized(self);
  &#125;
  
  function _assertThisInitialized(self) &#123;
    if (self === void 0) &#123;
      throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
    &#125;
    return self;
  &#125;
  
  function _isNativeReflectConstruct() &#123;
    if (typeof Reflect === &quot;undefined&quot; || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === &quot;function&quot;) return true;
    try &#123;
      Date.prototype.toString.call(Reflect.construct(Date, [], function () &#123; &#125;));
      return true;
    &#125; catch (e) &#123;
      return false;
    &#125;
  &#125;
  
  function _getPrototypeOf(o) &#123;
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123;
      return o.__proto__ || Object.getPrototypeOf(o);
    &#125;;
    return _getPrototypeOf(o);
  &#125;
  
  function _instanceof(left, right) &#123;
    if (right != null &amp;&amp; typeof Symbol !== &quot;undefined&quot; &amp;&amp; right[Symbol.hasInstance]) &#123;
      return !!right[Symbol.hasInstance](left);
    &#125; else &#123;
      return left instanceof right;
    &#125;
  &#125;
  
  function _classCallCheck(instance, Constructor) &#123;
    if (!_instanceof(instance, Constructor)) &#123;
      throw new TypeError(&quot;Cannot call a class as a function&quot;);
    &#125;
  &#125;
  
  function _defineProperties(target, props) &#123;
    for (var i = 0; i &lt; props.length; i++) &#123;
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if (&quot;value&quot; in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    &#125;
  &#125;
  
  function _createClass(Constructor, protoProps, staticProps) &#123;
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  &#125;
  
  var Person = /*#__PURE__*/function () &#123;
    function Person(name, age, gender, interests) &#123;
      _classCallCheck(this, Person);
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.interests = interests;
    &#125;
    _createClass(Person, [&#123;
      key: &quot;greeting&quot;,
      value: function greeting() &#123;
        console.log(&quot;hello, I am &quot;.concat(this.name, &quot;!&quot;));
      &#125;
    &#125;]);
    return Person;
  &#125;();
  
  var Teather = /*#__PURE__*/function (_Person) &#123;
    _inherits(Teather, _Person);
    var _super = _createSuper(Teather);
    function Teather(name, age, gender, interests, subject) &#123;
      var _this;
      _classCallCheck(this, Teather);
      _this = _super.call(this, name, age, gender, interests);
      _this.subject = subject;
      return _this;
    &#125;
    _createClass(Teather, [&#123;
      key: &quot;greeting&quot;,
      value: function greeting() &#123;
        console.log(&quot;hello, I am a teather, I teath &quot;.concat(this.subject));
      &#125;
    &#125;]);
    return Teather;
  &#125;(Person);
  
  var t = new Teather(&#39;wang&#39;, 28, &#39;m&#39;, [&#39;sing&#39;, &#39;running&#39;], &#39;english&#39;);
  t.greeting(); // hello, I am a teather, I teath english!
</code></pre>
<p>&emsp;&emsp;ES6转换后的ES5代码与原来的ES5代码实现原理一致。我们来简单分析一下转换后的代码：<br>&emsp;&emsp;① 可以看到，定义Person和Teacher时，使用了立即执行函数，代码会立即执行，执行后返回Person构造函数以及继承于Person的Teacher构造函数。<br>&emsp;&emsp;② 在定义Person变量的立即执行函数中，定义了Person函数，函数中设置了相关属性。然后调用_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法给Person函数的原型prototype上添加上方法，(还可以给Person函数添加静态属性，这里示例代码未添加）。即_createClass()实现了Person函数方法与属性的添加，最后将Person函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;③ 在定义Teacher变量的立即执行函数中，将定义好的Person构造函数函数作为了参数，先调用_inherits()方法，将定义的Teacher函数（预编译会进行函数提升）与传入的Person构造函数作为参数，其中使用Object.create()方法以Person构造函数的原型prototype作为原型，设置了Teacher函数的原型，同时Teacher函数的原型也继承了Person构造函数原型链上的属性和方法，然后调用_setPrototypeOf()方法修正Teacher函数原型对象__proto__的指向，也就是_inherits()方法实现了继承关系。然后再调用了_createSuper(Teather)方法定义了_super变量，其值是一个函数，里面追溯了Teacher构造函数的原型链，定义了调用父构造函数Person时，使用了apply（this, arguments）方法绑定了子构造函数Teacher的this，实现了Teacher函数属性的设置（<u>返回的_super方法这里只是定义，还未执行，要在Teacher构造函数执行到_super.call()的时候才会执行</u>）。最后同理，调用了_createClass()方法，里面调用了_defineProperties()方法，其中使用了Object.defineProperty()方法在Teacher函数的原型prototype上重写了greeting()方法，将Teacher函数作为构造函数返回（<u>此时构造函数内部代码未执行</u>）。<br>&emsp;&emsp;④ 调用new Teacher()创建t实例，执行Teacher构造函数，调用_classCallCheck()防止构造函数被直接调用（即ES6中的类是不能被直接调用的）。然后再调用上面说到的定义了的_super()方法实现了实例属性的设置（在执行_super()函数时，会执行里面定义的父构造函数Person的方法来实现属性的继承与设置），再设置了Teacher构造函数实例特有的subject属性，此时获得的_this实例的原型指向Teacher构造函数，Teacherr构造函数又继承于Person构造函数。此时_this实例已经继承了原型链上的属性与方法，包括Teahcer构造函数重写的greeting()方法。返回_this。<br>&emsp;&emsp;⑤ 执行t.greeting()方法，可以看到方法被成功执行且为执行的重写后的方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS常用API（字符串、数组、对象、正则、日期）</title>
    <url>/2021/01/16/javascript/JS%E5%B8%B8%E7%94%A8API%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E6%AD%A3%E5%88%99%E3%80%81%E6%97%A5%E6%9C%9F%EF%BC%89/</url>
    <content><![CDATA[<p>JS中常用的API有字符串、数组、对象、正则与日期对象等。</p>
<h2 id="1、字符串（String）"><a href="#1、字符串（String）" class="headerlink" title="1、字符串（String）"></a>1、字符串（String）</h2><p>&emsp;&emsp;字符串，是由零个或多个字符组成的有限序列。在JavaScript中，字符串实例有字符串对象和基本字符串值的区别  ( 对于 Boolean 和Numbers 也同理)。字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。<u>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询</u></p>
<pre><code>  const str1 = &#39;abc&#39;; // 基本字符串实例
  const str2 = new String(&#39;abc&#39;); // 字符串对象实例
  console.log(str1);
  console.log(str2);
</code></pre>
<p>打印结果如下（特殊的，可以看到基本字符串实例与字符串对象实例区别很大；其他对象如<u>数组</u>、<u>对象</u>等字面量定义与构造函数实例化<u>区别并不大</u>）：</p>
<p><img src="/images/javascript/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89.png" alt="字符串（String）"></p>
<p>&emsp;&emsp;字符串String对象的属性：String.prototype（显式原型，允许您向对象添加属性和方法）<br>&emsp;&emsp;字符串String对象的方法：String.fromCharCode() （通过一串 Unicode 创建字符串）、String.raw()（通过模板字符串创建字符串）等<br>&emsp;&emsp;字符串实例对象的属性：String.prototype.constructor（构造函数，创建改对象的函数的引用）、String.prototype.length（字符串长度）、N（用于访问第N个位置的字符，其中N是小于 length 和 0之间的正整数，‘只读’性质，不可编辑。eg: str1[1]结果为‘b’）</p>
<p>&emsp;&emsp;字符串实例对象常用方法（<strong>String.prototype上的方法</strong>）：<br>&emsp;&emsp;charAt()：返回在指定位置的字符<br>&emsp;&emsp;concat()：连接两个或更多字符串，并返回新的字符串<br>&emsp;&emsp;includes()：查找字符串中是否包含指定的子字符串<br>&emsp;&emsp;startsWith()：查看字符串是否以指定的子字符串开头<br>&emsp;&emsp;endsWith()：查看字符串是否以指定的子字符串结尾<br>&emsp;&emsp;indexOf()：返回某个指定的字符串值在字符串中首次出现的位置<br>&emsp;&emsp;lastIndexOf()：从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置<br>&emsp;&emsp;<u>match()</u>：查找找到一个或多个正则表达式的匹配<br>&emsp;&emsp;<u>search()</u>：查找与正则表达式相匹配的值<br>&emsp;&emsp;padStart()：在当前字符串头部填充指定的字符串，直到达到指定的长度。返回一个新的字符串<br>&emsp;&emsp;padEnd()：在当前字符串尾部填充指定的字符串，直到达到指定的长度。返回一个新的字符串<br>&emsp;&emsp;repeat()：复制字符串指定次数，并将它们连接在一起返回<br>&emsp;&emsp;replace()：在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串<br>&emsp;&emsp;slice()：提取字符串的片断，并在新的字符串中返回被提取的部分<br>&emsp;&emsp;split()：把字符串分割为字符串数组<br>&emsp;&emsp;substring()：提取字符串中两个指定的索引号之间的字符<br>&emsp;&emsp;toLocaleLowerCase()、toLocaleUpperCase()：将字符串中的字符转成小写或大写<br>&emsp;&emsp;trim()、trimStart()/trimLeft()、trimEnd()/trimRight()：去掉字符串开始或结尾的空格<br>&emsp;&emsp;toString()：返回一个字符串。屏蔽了原型链上的 Object.prototype.toString() 方法</p>
<p><em>&emsp;&emsp;[注] 这里列举的方法都是访问方法，不会改变对象自身的值</em></p>
<p>&emsp;&emsp;字符串常用方法示例代码：</p>
<pre><code>  const str1 = &#39;aAbBcCc&#39;
  const str2 = new String(&#39;  123  456&#39;)
  
  // chatAt() 返回特定位置的字符
  console.log(str1.charAt(0)); // a
  
  // concat() 连接两个字符串文本，并返回一个新的字符串
  console.log(str1.concat(str2)); // aAbBcCc  123  456
  
  // includes() 判断一个字符串里是否包含其他字符串
  console.log(str1.includes(&#39;c&#39;)); // true
  
  // startsWith() 判断字符串的起始位置是否匹配其他字符串中的字符
  console.log(str1.startsWith(&#39;a&#39;)); // true
  
  // endsWith() 判断一个字符串里是否包含其他字符串
  console.log(str1.endsWith(&#39;a&#39;)); // false
  
  // indexOf() 从字符串对象中返回首个被发现的给定值的索引值，如果没有找到则返回-1
  console.log(str1.indexOf(&#39;a&#39;)) // 0
  
  // lastIndexOf() 从字符串对象中返回最后一个被发现的给定值的索引值，如果没有找到则返回-1
  console.log(str1.lastIndexOf(&#39;C&#39;)) // 5
  
  // match() 使用正则表达式与字符串相比较，返回匹配成功的结果数组
  console.log(str1.match(/a/gi)) // [&quot;a&quot;, &#39;B&#39;]
  
  // search() 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标
  console.log(str1.search(/b/g)) // 2
  
  // padStart() 在当前字符串头部填充指定的字符串，直到达到指定的长度。返回一个新的字符串
  console.log(str1.padStart(10, &#39;X&#39;)) // XXXaAbBcCc
  
  // padEnd() 在当前字符串尾部填充指定的字符串，直到达到指定的长度。返回一个新的字符串
  console.log(str1.padEnd(10, &#39;X&#39;)) // aAbBcCcXXX
  
  // repeat() 返回指定重复次数的由元素组成的字符串对象
  console.log(str1.repeat(2)) // aAbBcCcaAbBcCc
  
  // replace() 被用来在字符或正则表达式与字符串直接比较，然后用新的子串来替换被匹配的子串
  console.log(str1.replace(/a/g, &#39;X&#39;)) // XAbBcCc
  console.log(str1.replace(/a/gi, &#39;X&#39;)) // XXbBcCc
  
  // slice() 摘取一个字符串区域，返回一个新的字符串
  console.log(str1.slice(2,4)) // bB
  
  // split() 通过分离字符串成字串，将字符串对象分割成字符串数组
  console.log(str1.split(&#39;&#39;)) // [&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;c&quot;]
  
  // substring() 返回在字符串中指定两个下标之间的字符
  console.log(str1.substring(2,4)) // bB
  
  // toLocaleLowerCase()、toLocaleUpperCase() 将字符串中的字符转成小写或大写
  console.log(str1.toLocaleLowerCase()) // aabbccc
  console.log(str1.toLocaleUpperCase()) // AABBCCC
  
  // trim()、trimStart()/trimLeft()、trimEnd()/trimRight() 去掉字符串开始或结尾的空格
  console.log(str2.trim()) // 123  456
  
  // toString() 返回用字符串表示的特定对象
  console.log([1,2,3,4,5].toString()) // &quot;1,2,3,4,5&quot;
</code></pre>
<h2 id="2、数组（Array）"><a href="#2、数组（Array）" class="headerlink" title="2、数组（Array）"></a>2、数组（Array）</h2><p>&emsp;&emsp;数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。<br><em>&emsp;&emsp;[注] 只能用整数作为数组元素的索引，而不能用字符串。后者称为关联数组（Map）。使用非整数并通过方括号或点号来访问或设置数组元素时，所操作的并不是数组列表中的元素，而是数组对象的属性集合上的变量（例如length）。<u>数组对象的属性和数组元素列表是分开存储的，并且数组的遍历和修改操作也不能作用于这些命名属性。</u>数组的索引是从0开始的，第一个元素的索引为0，最后一个元素的索引等于该数组的长度减1。<u>如果指定的索引是一个无效值，JavaScript 数组并不会报错，而是会返回 undefined</u></em></p>
<pre><code>  const arr = [1, 2, 3, 4, 5, 6]
  console.log(arr[2]) // 3
  console.log(arr[-1]) // undefined
  console.log(arr[10]) // undefined
</code></pre>
<p>&emsp;&emsp;数组Array对象的属性：Array.length (Array构造函数的 length 属性，其值为1)、Array.prototype (通过数组的原型对象可以为所有数组对象添加属性)<br>&emsp;&emsp;数组Array对象的方法：Array.from() (从类数组对象或者可迭代对象中创建一个新的数组实例)、Array.isArray() (用来判断某个变量是否是一个数组对象)、Array.of() (根据一组参数来创建新的数组实例，支持任意的参数数量和类型)<br>&emsp;&emsp;数组实例对象的属性：Array.prototype.constructor（构造函数，创建改对象的函数的引用）、Array.prototype.length（数组长度）</p>
<p>&emsp;&emsp;数组实例对象的方法（Array.prototype上的方法）：</p>
<p>&emsp;&emsp;1) 修改器方法（这些方法调用<strong>会</strong>改变对象自身的值）<br>&emsp;&emsp;copyWithin()：在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值<br>&emsp;&emsp;fill()：将数组中指定区间的所有元素的值，都替换成某个固定的值<br>&emsp;&emsp;pop()：删除数组的最后一个元素，并返回这个元素<br>&emsp;&emsp;push()：在数组的末尾增加一个或多个元素，并返回数组的新长度<br>&emsp;&emsp;reverse()：颠倒数组中元素的排列顺序<br>&emsp;&emsp;shift()：删除数组的第一个元素，并返回这个元素<br>&emsp;&emsp;sort()：对数组元素进行排序，并返回当前数组<br>&emsp;&emsp;splice()：在任意的位置给数组添加或删除任意个元素<br>&emsp;&emsp;unshift()：在数组的开头增加一个或多个元素，并返回数组的新长度</p>
<p>&emsp;&emsp;2) 访问方法（这些方法调用<strong>不会</strong>改变对象自身的值）<br>&emsp;&emsp;concat()：返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组<br>&emsp;&emsp;includes()：判断当前数组是否包含某指定的值，返回ture/false<br>&emsp;&emsp;join()：连接所有数组元素组成一个字符串<br>&emsp;&emsp;slice()：抽取当前数组中的一段元素组合成一个新数组<br>&emsp;&emsp;toString()：返回一个由所有数组元素组合而成的字符串。屏蔽了原型链上的 Object.prototype.toString() 方法<br>&emsp;&emsp;indexOf()：返回数组中第一个与指定值相等的元素的索引，如果找不到返回-1<br>&emsp;&emsp;lastIndexOf()：返回数组中最后一个与指定值相等的元素的索引，如果找不到返回-1</p>
<p>&emsp;&emsp;3) 迭代方法（<u>一般都需要指定回调函数，在回调函数中length会被缓存，尽量不要在遍历过程中对原数组进行任何修改，会对遍历操作带来未预期的影响</u>）<br>&emsp;&emsp;forEach()：为数组中的每个元素执行一次回调函数<br>&emsp;&emsp;entries()：返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对<br>&emsp;&emsp;every()：如果数组中的每个元素都满足测试函数，返回true，否则返回false<br>&emsp;&emsp;some()：如果数组中至少有一个元素满足测试函数，返回 true，否则返回 false<br>&emsp;&emsp;filter()：将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回<br>&emsp;&emsp;find()：找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined<br>&emsp;&emsp;findIndex()：找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1<br>&emsp;&emsp;keys()：返回一个数组迭代器对象，该迭代器会包含所有数组元素的键<br>&emsp;&emsp;<u>map()</u>：返回一个由回调函数的返回值组成的新数组<br>&emsp;&emsp;<u>reduce()</u>：从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值<br>&emsp;&emsp;reduceRight()：从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值<br>&emsp;&emsp;values()：返回一个数组迭代器对象，该迭代器会包含所有数组元素的值</p>
<p>&emsp;&emsp;数组常用方法示例：</p>
<pre><code>  // 1、修改器方法 - 会改变原数组    
  console.log(&#39;生成长度为5的空数组实例&#39;)
  let array = new Array(5)
  console.log(array) // [empty × 5]
  console.log(&#39;初始化数组所有元素为0&#39;)
  array.fill(0)
  console.log(array) // [0, 0, 0, 0, 0]
  console.log(&#39;在数组末尾添加元素2，6和1&#39;)
  array.push(2, 6, 1)
  console.log(array) // [0, 0, 0, 0, 0, 2, 6, 1]
  console.log(&#39;删除数组最后一个元素并输出该元素与删除后的数组&#39;)
  console.log(array.pop()) // 1
  console.log(array) // [0, 0, 0, 0, 0, 2, 6]
  console.log(&#39;在数组开头添加元素6，3和7&#39;)
  array.unshift(6, 3, 7)
  console.log(array) // [6, 3, 7, 0, 0, 0, 0, 0, 2, 6]
  console.log(&#39;删除数组第一个元素并输出该元素与删除后的数组&#39;)
  console.log(array.shift()) // 6
  console.log(array) // [3, 7, 0, 0, 0, 0, 0, 2, 6]
  console.log(&#39;数组元素反序&#39;)
  array.reverse()
  console.log(array) [6, 2, 0, 0, 0, 0, 0, 7, 3]
  console.log(&#39;数组排序，默认从小到大&#39;)
  array.sort()
  console.log(array) // [0, 0, 0, 0, 0, 2, 3, 6, 7]
  
  // 2、访问方法 - 不会改变原数组
  console.log(&#39;连接数组[1,2]与[3,4]&#39;)
  console.log(array.concat([1, 2], [3, 4])) // [0, 0, 0, 0, 0, 2, 3, 6, 7, 1, 2, 3, 4]
  console.log(&#39;截取数组下标从3到数组末尾所有元素&#39;)
  console.log(array.slice(3, array.length)) // [0, 0, 2, 3, 6, 7]]
  console.log(array) // [0, 0, 0, 0, 0, 2, 3, 6, 7]
  
  // 3、迭代方法 - 返回预期数组结果，不会影响原数组
  console.log(&#39;过滤掉数组小于等于0的项&#39;)
  console.log(array.filter(item =&gt; item &gt; 0)) // [2, 3, 6, 7]
  console.log(&#39;数组各项求和&#39;)
  console.log(array.reduce((sum, item) =&gt; sum+=item)) // 18
  console.log(array) // [0, 0, 0, 0, 0, 2, 3, 6, 7]
</code></pre>
<p><em>&emsp;&emsp;[注] JavaScritp的数据类型有：数值类型、字符串类型、布尔类型、null、undefined、对象；将他们可以大致分成两种：基本数据类型、引用数据类型</em><br><em>&emsp;&emsp;① 基本数据类型：数值、字符串、布尔、null、undefined （值类型）</em><br><em>&emsp;&emsp;② 复杂(复合)数据类型：对象 (引用类型)</em></p>
<p><em>&emsp;&emsp;基础数据类型保存在栈内存中；引用类型数据保存在堆内存中，对应的引用地址是存储在栈内存中的，这个引用地址指向引用类型数据在堆内存储的存储单元。调用基础数据类型时直接调用了对应的值，而操作对象等引用类型数据时，实际上是通过调用其引用地址来操作的<strong>（如果是基础数据类型，拷贝会拷贝其对应的值；如果是引用数据类型，只会拷贝这个引用地址，引用地址指向共用一个堆内存，并不是一个新的对象，数据会同步变化）</strong></em></p>
<h2 id="3、对象（Object）"><a href="#3、对象（Object）" class="headerlink" title="3、对象（Object）"></a>3、对象（Object）</h2><p>&emsp;&emsp;在JavaScript中，几乎所有的对象都是Object类型的实例，它们都会从Object.prototype继承属性和方法。Object 构造函数为给定值创建一个对象包装器。给定值是 null 或 undefined，将会创建并返回一个空对象；给定值是一个基本类型的值，则会构造其包装类型的对象；给定值是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址</p>
<p>&emsp;&emsp;对象Object构造函数属性：<u>Object.length（值为1）</u>、Object.prototype（可以为所有 Object 类型的对象添加属性）</p>
<p>&emsp;&emsp;对象Object构造函数方法：<br>&emsp;&emsp;Object.assign()：通过复制一个或多个对象来创建一个新的对象<br>&emsp;&emsp;Object.create()：使用指定的原型对象和属性创建一个新对象<br>&emsp;&emsp;Object.defineProperty()/Object.defineProperties()：给对象添加一个/多个属性并指定该属性的配置<br>&emsp;&emsp;Object.entries()：返回给定对象自身可枚举属性的 [key, value] 数组<br>&emsp;&emsp;Object.freeze()：冻结对象：其他代码不能删除或更改任何属性<br>&emsp;&emsp;Object.isFrozen()：判断对象是否已经冻结<br>&emsp;&emsp;Object.seal()：防止其他代码删除对象的属性<br>&emsp;&emsp;Object.isSealed()：判断对象是否已经密封<br>&emsp;&emsp;Object.is()：比较两个值是否相同。所有 NaN 值都相等（与==和===有区别）<br>&emsp;&emsp;Object.getPrototypeOf()：返回指定对象的原型对象<br>&emsp;&emsp;Object.setPrototypeOf()：设置对象的原型（即内部 [[Prototype]] 属性）<br>&emsp;&emsp;Object.keys()：返回一个包含所有给定对象自身可枚举属性名称的数组<br>&emsp;&emsp;Object.values()：返回给定对象自身可枚举值的数组</p>
<p>&emsp;&emsp;对象实例的属性：Object.prototype.constructor (对象的构造函数)、Object.prototype.<strong>proto</strong> (指向当对象被实例化的时候，用作原型的对象)</p>
<p>&emsp;&emsp;对象实例的方法 (Object.prototype上的方法)：<br>&emsp;&emsp;hasOwnProperty()：返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的<br>&emsp;&emsp;isPrototypeOf()：返回一个布尔值，表示指定的对象是否在本对象的原型链中<br>&emsp;&emsp;toSource()：返回字符串表示此对象的源代码形式，可以使用此字符串生成一个新的相同的对象<br>&emsp;&emsp;toString()：返回对象的字符串表示<br>&emsp;&emsp;valueOf()：返回指定对象的原始值<br>&emsp;&emsp;watch()/unwatch()：添加/移除对象某个属性的监听</p>
<p>&emsp;&emsp;对象(Object)以及实例方法示例：</p>
<pre><code>  const origin = &#123;
    name: &#39;original Object&#39;
  &#125;
  // 通过Object.create知道origin为原型创建obj对象
  const obj = Object.create(origin)
  console.log(&#39;输出obj实例对象的原型&#39;)
  console.log(obj.__proto__) // &#123;name: &quot;original Object&quot;&#125;
  console.log(&#39;输出obj实例对象&#39;)
  console.log(obj) // &#123;&#125;
  console.log(&#39;输出obj实例对象的name&#39;)
  console.log(obj.name) // original Object (obj实例没有name属性，打印出的name属性是原型链上origin对象的name属性)
  console.log(&#39;设置并输出obj的name属性值为obj&#39;)
  obj.name = &#39;obj&#39;
  console.log(obj.name) // obj
  console.log(&#39;使用Object.defineProperty设置obj属性age为18,添加修饰符设置为其可枚举，但不可修改与删除&#39;)
  Object.defineProperty(obj, &#39;age&#39;, &#123;
    value: 18,
    writable: false, // 对象属性值是否能被修改（默认false）
    enumerable: true, // 对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举（默认false）
    configurable: false //设置属性是否能被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改（默认false）
  &#125;)
  console.log(obj.age) // 18
  console.log(&#39;输出obj中可枚举的属性列表&#39;)
  console.log(Object.keys(obj)) // [&quot;name&quot;, &quot;age&quot;]
  delete obj.age
  obj.age = 20
  console.log(&#39;obj的age属性删除与修改无效&#39;)
  console.log(Object.keys(obj), obj.age)  // [&quot;name&quot;, &quot;age&quot;] 18
  console.log(&#39;使用Object.defineProperty设置obj属性num,添加get、set方法，[注]存取修饰符get和set不能与value或writable等数据修饰符同时使用&#39;)
  Object.defineProperty(obj, &#39;num&#39;, &#123;
    get: function () &#123;
      console.log(&#39;---获取了num的值为&#39; + value)
      return value
    &#125;,
    set: function (x) &#123;
      value = x
      console.log(&#39;---设置了num的值为&#39; + value)
    &#125;
  &#125;)
  console.log(&#39;设置与访问obj对象num值为100&#39;)
  obj.num = 100 // ---设置了num的值为100 (set函数打印)
  console.log(obj.num) // ---获取了num的值为100 (get函数打印)  100
  console.log(&#39;设置与访问obj对象num值为200&#39;)
  obj.num = 200 // ---设置了num的值为200 (set函数打印)
  console.log(obj.num) // ---获取了num的值为200 (get函数打印)  200
  console.log(&#39;obj添加的num属性默认不可枚举&#39;)
  console.log(Object.keys(obj)) //  [&quot;name&quot;, &quot;age&quot;]
  
  console.log(&#39;使用实例方法hasOwnProperty()判断obj对象是否有num属性&#39;)
  console.log(obj.hasOwnProperty(&#39;num&#39;)) // true
</code></pre>
<h2 id="4、正则（RegExp）"><a href="#4、正则（RegExp）" class="headerlink" title="4、正则（RegExp）"></a>4、正则（RegExp）</h2><p>&emsp;&emsp;正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。</p>
<p>&emsp;&emsp;创建正则实例对象的两种方法：<br>&emsp;&emsp;正则表达式字面量：由斜杠(/)包围而不是引号包围<br>&emsp;&emsp;RegExp对象的构造函数：构造函数传入字符串参数，由引号而不是斜杠包围 （可以动态参数正则表达式实例，[注] 需要使用常规的字符转义规则）</p>
<p>&emsp;&emsp;正则实例对象方法 (RegExp.prototype上的方法)：<br>&emsp;&emsp;compile()：编译正则表达式<br>&emsp;&emsp;<u>exec()</u>：在字符串中执行匹配项的搜索<br>&emsp;&emsp;<u>test()</u>：该正则在字符串里是否有匹配<br>&emsp;&emsp;toString()：返回表示指定对象的字符串，屏蔽了Object.prototype.toString()方法</p>
<p>正则实例对象方法示例：</p>
<pre><code>  const str = &#39;apple orange banana&#39;
  console.log(&#39;检测str字符串是否匹配到字符串Orange&#39;)
  const reg = /Orange/
  console.log(reg.test(str)) // false
  console.log(&#39;检测str字符串是否匹配到字符串OrAnge，忽略字母大小写&#39;)
  const reg1 = /OrAnge/i
  console.log(reg1.test(str)) // true
  console.log(&#39;检测str字符串是否以字符串orange开头&#39;)
  const reg2 = /^orange/
  console.log(reg2.test(str)) // false
  console.log(&#39;检测str字符串是否以字符串apple开头&#39;)
  const reg3 = /^apple/
  console.log(reg3.test(str)) // true
  console.log(&#39;检测str字符串是否以字符串banana结尾&#39;)
  const reg4 = /banana$/
  console.log(reg4.test(str)) // true

  const str1 = &#39;abaccabaa&#39;
  console.log(&#39;检索str1字符串中是否有aa、ab或ac的字符串&#39;)
  const reg5 = /a[abc]/g
  let result
  while ((result = reg5.exec(str1)) != null) &#123;
    console.log(`在字符串$&#123;str1&#125;检索到$&#123;result[0]&#125;，下次匹配从位置$&#123;reg5.lastIndex&#125;开始`)
  &#125;

  // 循环输出
  在字符串abaccabaa检索到ab，下次匹配从位置2开始
  在字符串abaccabaa检索到ac，下次匹配从位置4开始
  在字符串abaccabaa检索到ab，下次匹配从位置7开始
  在字符串abaccabaa检索到aa，下次匹配从位置9开始

  console.log(reg5.lastIndex) // 0

  console.log(&#39;使用字符串match方法检索字符串&#39;)
  console.log(str1.match(reg5)) // [&quot;ab&quot;, &quot;ac&quot;, &quot;ab&quot;, &quot;aa&quot;]
</code></pre>
<p><em>&emsp;&emsp;[注] 当正则表达式使用 ‘g’ 标志时，可以多次执行exec()、test()方法来查找同一个字符串中的成功匹配。查找将从正则表达式的 lastIndex(下一次匹配开始的位置)属性指定的位置开始。如果匹配成功, lastIndex会被更新，即使再次查找的字符串不是原查找字符串时，lastIndex 也不会被重置，它依旧会从记录的 lastIndex 开始；如果匹配失败，exec()方法返回 null，lastIndex会重置为0 。</em></p>
<p>&emsp;&emsp;正则表达式中的特殊字符与含义：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个表达式 0 次或多次。等价于 {0,}</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面一个表达式 1 次或者多次。等价于 {1,}</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}</td>
</tr>
<tr>
<td>.</td>
<td>(小数点) 默认匹配除换行符之外的任何单个字符，如果 s (“dotAll”) 标志位被设为 true，它也会匹配换行符</td>
</tr>
<tr>
<td>(x)</td>
<td>匹配 ‘x’ 并且记住匹配项，其中括号被称为捕获括号</td>
</tr>
<tr>
<td>(?:x)</td>
<td>匹配 ‘x’ 但是不记住匹配项，这种括号叫作非捕获括号</td>
</tr>
<tr>
<td>x(?=y)</td>
<td>匹配’x’仅仅当’x’后面跟着’y’（先行断言）</td>
</tr>
<tr>
<td>(?&lt;=y)x</td>
<td>匹配’x’仅当’x’前面是’y’（后行断言）</td>
</tr>
<tr>
<td>x(?!y)</td>
<td>仅当’x’后面不跟着’y’时匹配’x’（正向否定查找）</td>
</tr>
<tr>
<td>(?&lt;!y)x</td>
<td>仅当’x’后面不是’y’时匹配’x’（反向否定查找）</td>
</tr>
<tr>
<td>x|y</td>
<td>匹配’x’或者’y’</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配了前面一个字符刚好出现了 n 次 (n 是一个正整数)</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配了前面一个字符至少出现了 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0，这个值被忽略 (m也是一个正整数)</td>
</tr>
<tr>
<td>[xyz]</td>
<td>一个字符集合，匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>一个反向字符集，匹配任何没有包含在方括号中的字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个词的边界，不要和[\b]混淆，后者匹配一个退格</td>
</tr>
<tr>
<td>\B</td>
<td>匹配一个非单词边界</td>
</tr>
<tr>
<td>\cX</td>
<td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符，例如，反斜杠cM匹配字符串中的 control-M</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td>\0</td>
<td>匹配 NULL字符  <em>[注]不要在这后面跟其它小数，\0&lt;digits&gt; 是一个八进制转义序列</em></td>
</tr>
<tr>
<td>\s</td>
<td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配一个非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个非单字字符。等价于 [^A-Za-z0-9_]</td>
</tr>
</tbody></table>
<h2 id="5、日期（Date）"><a href="#5、日期（Date）" class="headerlink" title="5、日期（Date）"></a>5、日期（Date）</h2><p>&emsp;&emsp;Date 对象则基于 Unix Time Stamp，即自1970年1月1日（UTC）起经过的毫秒数。<br>&emsp;&emsp;创建一个新Date实例对象的唯一方法是通过new 操作符，若不使用new关键字，将Date()当做常规函数调用，会返回一个表示时间的字符串。</p>
<p>&emsp;&emsp;Date()构造函数有4种基本形式：<br>&emsp;&emsp;① 没有参数，新创建的Date对象表示当前的日期和时间<br>&emsp;&emsp;② Unix时间戳：整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数<br>&emsp;&emsp;③ 时间戳字符串：表示日期的字符串值（字符串应该能被 Date.parse() 方法正确识别）<br>&emsp;&emsp;④ 提供日期与时间的各个成员：至少提供了年份与月份时，没有提供的成员将使用最小可能值（如日期为1，其他为0）</p>
<p>&emsp;&emsp;日期Date对象的属性：Date.prototype (允许为 Date 对象添加属性)、<u>Date.length (值是7,因为该构造函数可接受的参数个数)</u></p>
<p>&emsp;&emsp;日期Date对象的方法：<br>&emsp;&emsp;Date.now()：返回自 1970-1-1 00:00:00  UTC（世界标准时间）至今所经过的毫秒数<br><em>&emsp;&emsp;[注] <u>与performance.now()方法不同，performance.now()返回一个精确到毫秒的 DOMHighResTimeStamp，并不是高精度的，常与requestAnimationFrame一起使用来判断当前动画已执行了多少时间。requestAnimationFrame()的回调函数会被传入DOMHighResTimeStamp参数，表示当前被排序的回调函数被触发的时间</u></em><br>&emsp;&emsp;Date.parse()：解析表示日期的字符串，并返回从1970-1-1 00:00:00所经过的毫秒数（不同浏览器有差异）<br>&emsp;&emsp;Date.UTC()：接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数</p>
<p>&emsp;&emsp;日期实例对象的属性：Date.prototype.constructor （返回创建了实例的构造函数，默认是 Date 构造函数）</p>
<p>&emsp;&emsp;日期实例对象的方法 (Date.prototype上的方法)：<br>&emsp;&emsp;getDay()：返回指定日期对象的星期中的第几天（0-6）<br>&emsp;&emsp;getFullYear()/setFullYear()：返回指定日期对象的年份/指定日期对象设置完整年份（四位数年份时返回四位数字）<br>&emsp;&emsp;getMonth()/setMonth()：返回指定日期对象的月份/指定日期对象设置月份（0-11）<br>&emsp;&emsp;getDate()/setDate()：返回指定日期对象的月份中的第几天/指定的日期对象设置月份中的第几天（1-31）<br>&emsp;&emsp;getHours()/setHours()：返回指定日期对象的小时/指定日期对象设置小时数（0-23）<br>&emsp;&emsp;getMinutes()/setMinutes()：返回指定日期对象的分钟/指定日期对象设置分钟数（0-59）<br>&emsp;&emsp;getSeconds()/setSeconds()：返回指定日期对象的秒数/指定日期对象设置秒数（0-59）<br>&emsp;&emsp;getMilliseconds()/setMilliseconds()：返回指定日期对象的毫秒/指定日期对象设置毫秒数（0-999）<br>&emsp;&emsp;getTime()/setTime()：<u>返回从1970-1-1 00:00:00 UTC到该日期经过的毫秒数</u>/通过指定从 1970-1-1 00:00:00 UTC 开始经过的毫秒数来设置日期对象的时间(1970-1-1 00:00:00 UTC之前的时间返回负值)<br>&emsp;&emsp;toDateString()：以易读的形式返回该日期对象日期部分的字符串</p>
<p>&emsp;&emsp;日期实例方法示例：</p>
<pre><code>  const timeStamp = new Date()
  const year = timeStamp.getFullYear()
  const month = timeStamp.getMonth() + 1
  const day = timeStamp.getDate()
  const hh = timeStamp.getHours()
  const mm = timeStamp.getMinutes()
  const ss = timeStamp.getSeconds()
  console.log(&#39;当前时间为: &#39; + year + &#39;年&#39; + month + &#39;月&#39; + day + &#39;日 &#39; + hh + &#39;时&#39; + mm + &#39;分&#39; + ss + &#39;秒&#39;)
  // 当前时间为: 2021年5月28日 0时26分31秒
  
  console.log(&#39;以易读的形式返回该日期对象日期部分&#39;)
  console.log(timeStamp.toDateString()) // Fri May 28 2021
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步操作以及流程控制（串行、并行）</title>
    <url>/2020/12/25/javascript/JS%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%89/</url>
    <content><![CDATA[<p>Javascript语言的执行环境是”单线程”（single thread），单个脚本只能在一个线程上运行（主线程）。原因在于浏览器内核中JavaScript引擎中负责解释和执行JavaScript代码的主线程是唯一的，同一时间只能执行一件任务。在浏览器内核中，GUI 渲染线程与 JavaScript 引擎线程是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。所以如果JavaScript执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步。”同步模式”指一个任务等待前一个任务执行结束再执行，程序的执行顺序与任务的排列顺序（即与程序的编码顺序）是一致的、同步的；”异步模式”是每一个任务有一个或多个回调函数，一个任务不用等待前一个任务执行完成就便开始执行，当前任务执行完成后，不是立即执行后一个任务，而是查询回调函数队列里，是否有前面的已任务的回调函数，会立即执行回调函数，回调函数执行完后再执行后一个任务。程序的执行顺序与任务的排列顺序是不一致的，同步的；而是异步的。（<u>此外，JS运行时还有宏任务、微任务、事件循环的概念。</u>）</p>
<h2 id="说在前面-进程（Process）与线程（Thread）"><a href="#说在前面-进程（Process）与线程（Thread）" class="headerlink" title="说在前面 - 进程（Process）与线程（Thread）"></a>说在前面 - 进程（Process）与线程（Thread）</h2><p>&emsp;&emsp;目前的操作系统都是多任务系统，操作系统接管了所有硬件资源并持有对硬件控制的最高权限。在操作系统中执行的程序，都以进程的方式运行在更低的权限中。所有的硬件资源，由操作系统根据进程的优先级以及进程的运行状况进行统一的调配，<u>即操作系统是以进程为单位去分配空间和执行的。</u></p>
<p><em>&emsp;&emsp;[注] 区分程序与进程：程序是一组指令集合，它本身没有任何运行的含义，它只是一个静态的实体，存储于磁盘之内的存储器中；当一个程序被操作系统执行时，会被载入内存并在逻辑上产生一个独立的实例，这就是进程。进程和程序并不是一 一对应的；一个程序有可能没有与之对应的进程(因为它并未执行)，也有可能有多个进程与之对应(程序运行在几个不同的数据集上)。<u>一个程序在运行时，至少有一个进程,一个进程至少有一个线程。</u></em></p>
<p>&emsp;&emsp;线程是操作系统进行任务调度的最小单元。<strong>线程存活于进程之中；同一个进程中的线程，共享一个虚拟内存空间以及其中的资源；</strong>线程之间各自持有自己的线程 ID、当前指令的指针（PC）、寄存器集合以及栈。</p>
<p>&emsp;&emsp;<strong>就浏览器来说，浏览器在运行时是多进程的：</strong><br>&emsp;&emsp;Browser进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等<br>&emsp;&emsp;PU 进程：用于3D 绘制等<br>&emsp;&emsp;第三方插件进程：每种类型的插件对应一个进程，仅当使用该浏览器插件时才创建<br>&emsp;&emsp;浏览器渲染进程（浏览器内核）：每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</p>
<p>&emsp;&emsp;<strong>每个渲染进程（浏览器内核）又分为多个线程：</strong><br>&emsp;&emsp;GUI渲染线程：负责渲染浏览器界面，当界面需要重绘或由于某种操作引发回流时，该线程就会执行<br>&emsp;&emsp;JavaScript引擎线程：也称为JavaScript内核，负责处理Javascript脚本程序、解析与运行Javascript代码等，例如 V8 引擎<br>&emsp;&emsp;事件触发线程：用来控制浏览器的事件循环，当事件被触发时，该线程才会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理<br>&emsp;&emsp;定时触发器线程：setInterval与setTimeout所在线程（<u>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</u>）<br>&emsp;&emsp;异步http请求线程：在XMLHttpRequest连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行</p>
<p><em>&emsp;&emsp;[注] <u>GUI 渲染线程与 JavaScript 引擎线程是互斥的。</u></em></p>
<h2 id="1、JS异步操作的几种方式"><a href="#1、JS异步操作的几种方式" class="headerlink" title="1、JS异步操作的几种方式"></a>1、JS异步操作的几种方式</h2><p>&emsp;&emsp;JavaScript中的任务分为同步任务和异步任务。<br>&emsp;&emsp;同步任务是那些没有被引擎挂起、<u>在主线程上排队执行的任务。</u>只有前一个任务执行完毕，才能执行后一个任务。<br>&emsp;&emsp;异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列（根据异步任务的类型，引擎实际上存在多个任务队列）的任务。只有引擎认为某个异步任务可以被执行了，该任务才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运。即异步任务不具有堵塞效应。</p>
<p>&emsp;&emsp;主线程会排队去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行。等到执行完，下一个异步任务再进入主线程开始执行。一旦同步与异步任务队列清空，程序就结束执行。</p>
<p>&emsp;&emsp;同步任务执行完成，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<u>事件循环（Event Loop）</u>。</p>
<p>&emsp;&emsp;异步操作的几种模式：回调函数、事件监听、发布/订阅模式、Generator 函数、Promise、async/await。</p>
<hr>
<h4 id="定时器相关概念"><a href="#定时器相关概念" class="headerlink" title="定时器相关概念"></a>定时器相关概念</h4><p>&emsp;&emsp;JavaScript 提供定时执行代码的功能，叫做定时器，主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。<u>定时器的运行机制是，将指定的代码移出本轮事件循环（即使设置延迟执行为0ms)，等到下一轮事件循环，再检查是否到了指定时间。如果到了，再将对应代码放入主线程进行执行；如果没到，就继续等待。</u></p>
<p>&emsp;&emsp;<u>setTimeout()</u>：用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，可以将该编号作为参数调用clearTimeout()方法来取消这个定时器。setTimeout()可以接收多个参数，第一个参数为回调函数或字符串代码，会在定时时间到达时执行，第二个参数为延迟执行的时间（单位ms），后面的参数列表会作为第一个参数回调函数的参数传入。<u>特别的，回调函数是如果是某一对象的方法，内部this指向是是全局环境的而不是定义所在的那个对象。</u></p>
<pre><code>  let id = setTimeout(function | code, delay, [a, b, c...]);
</code></pre>
<p>&emsp;&emsp;示例代码：</p>
<pre><code>  console.log(&#39;定时任务开始执行，&#39; + new Date())
  let id =  setTimeout((a,b,c) =&gt; &#123;
    console.log(&#39;定时任务执行完成，&#39;+ new Date() +&#39;，回调函数已开始执行&#39;);
    console.log(&#39;回调函数计算结果为：&#39;+ (a+b+c));
  &#125;,1000, 1,2,3)

  输出：
  定时任务开始执行，Wed May 26 2021 16:40:09 GMT+0800 (中国标准时间)
  定时任务执行完成，Wed May 26 2021 16:40:10 GMT+0800 (中国标准时间)，回调函数已开始执行
  回调函数计算结果为：6
</code></pre>
<p>&emsp;&emsp;<u>setInterval()</u>：setInterval()函数的用法与setTimeout()完全一致，区别仅仅在于setInterval()指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。特别的，指定的是<u>“开始执行”</u>之间的间隔，并不考虑每次任务执行本身所消耗的时间。实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 1000ms 执行一次，每次执行需要 500ms，那么第一次执行结束后等待500毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要1500毫秒，那么它结束后，下一次任务执行才会立即开始。</p>
<pre><code>  let count = 0; // 计时器，控制任务执行5次    
  console.log(new Date() + &#39;，延迟2s后开始执行定时任务~&#39;);
  let id = setInterval(() =&gt; &#123;
    let delay = Math.floor(Math.random() * 5 + 1) * 1000;
    console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务开始执行，需要&#39; + delay + &#39;ms才能完成&#39;)
    sleep(delay);
    console.log(new Date() + &#39;，第&#39; + (count + 1) + &#39;次任务执行完成&#39;)
    count++;
    if (count == 5) &#123;
      clearInterval(id)
      console.log(&#39;任务已执行5次，结束定时器任务~&#39;);
    &#125;
  &#125;, 2000)
  function sleep(ms) &#123; // 通过循环阻塞代码执行来模拟同步操作
    var start = Date.now();
    while ((Date.now() - start) &lt; ms) &#123; &#125;
  &#125;
  
  输出：
  Thu Nov 26 2020 13:13:39 GMT+0800 (中国标准时间)，延迟2s后开始执行定时任务~
  Thu Nov 26 2020 13:13:41 GMT+0800 (中国标准时间)，第1次任务开始执行，需要1000ms才能完成
  Thu Nov 26 2020 13:13:42 GMT+0800 (中国标准时间)，第1次任务执行完成
  Thu Nov 26 2020 13:13:43 GMT+0800 (中国标准时间)，第2次任务开始执行，需要4000ms才能完成
  Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第2次任务执行完成
  Thu Nov 26 2020 13:13:47 GMT+0800 (中国标准时间)，第3次任务开始执行，需要3000ms才能完成
  Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第3次任务执行完成
  Thu Nov 26 2020 13:13:50 GMT+0800 (中国标准时间)，第4次任务开始执行，需要3000ms才能完成
  Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第4次任务执行完成
  Thu Nov 26 2020 13:13:53 GMT+0800 (中国标准时间)，第5次任务开始执行，需要4000ms才能完成
  Thu Nov 26 2020 13:13:57 GMT+0800 (中国标准时间)，第5次任务执行完成
  任务已执行5次，结束定时器任务~
</code></pre>
<p>&emsp;&emsp;可以看到，第一次任务开始在13:13:41，需要执行1s，在13:13:42第一次任务就执行完成。由于设置的执行时间间隔是2s，等待1s后13:13:43才开始执行第二次任务。第二次任务需要执行4s，在13:13:47秒时第二次任务才执行完成；虽然设置的时间间隔为2s，但第二次任务执行时间大于设置的2s，第三次任务在第二次任务执行完后才开始执行。后面的任务执行情况同理。</p>
<p>&emsp;&emsp;注意，setTimeout()定时任务也会被阻塞：</p>
<pre><code>  console.log(new Date() + &#39;，延迟1s后开始执行定时任务~&#39;);
  setTimeout(() =&gt; &#123;
    console.log(new Date() + &#39;，延迟任务执行完成~&#39;)
  &#125;, 1000)
  sleep(2000);
  function sleep(ms) &#123; // 通过循环阻塞代码执行来模拟同步操作
    var start = Date.now();
    console.log(&#39;当前sleep任务要执行&#39; + ms + &#39;ms&#39;)
    while ((Date.now() - start) &lt; ms) &#123; &#125;
  &#125;
  
  输出：
  Thu Nov 26 2020 13:34:00 GMT+0800 (中国标准时间)，延迟1s后开始执行定时任务~
  当前sleep任务要执行2000ms
  Thu Nov 26 2020 13:34:02 GMT+0800 (中国标准时间)，延迟任务执行完成~
</code></pre>
<p>&emsp;&emsp;可以看到在13:34:00时，setTimeout()的回调函数本应该延迟1s执行，但sleep操作要执行2s。导致setTimeout()回调函数在13:34:02时才被执行。</p>
<p>&emsp;&emsp;<strong>setTimeout()与setInterval()可能会被同步任务阻塞，和定时器的运行机制有关。setTimeout和setInterval指定的回调函数，<u>必须等到本轮事件循环的所有同步任务都执行完成（上面代码中sleep()函数循环来模拟同步任务），才会被添加到主线程开始执行，而且此时的回调函数执行是同步的，只有回调函数执行完成，才会进行下一轮事件循环。</u>由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。<u>即使使用嵌套的setTimeout()来实现每两次任务执行之间有固定的间隔，也是有被阻塞的风险。</u></strong></p>
<hr>
<h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1) 回调函数"></a>1) 回调函数</h4><p>&emsp;&emsp;回调函数实现异步操作是指在开始执行的异步函数指定为参数的函数（回调函数不会立即被执行），当异步函数包含的异步操作执行完成时，再调用执行该回调函数。<u>回调函数是异步编程的最基本的方法。</u></p>
<p>&emsp;&emsp;将处理函数当做参数，在相关任务执行完成再调用执行，形如：</p>
<pre><code>  function f1&#123;
    // 相关代码
  &#125;
  function f2(cb)&#123;
    setTimeout(() =&gt; &#123;
      cb()
    &#125;, 2000)
  &#125;

  f2(f1);
</code></pre>
<p>&emsp;&emsp;下面模拟一个读取文件列表（3个文件）获取对应文件的总行数的示例，这里采用回调函数的方式进行依次读取（还有其他或更好的方式实现，这里只是为了用来说明回调函数）。</p>
<pre><code>  let fileLines = [];    
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      fileLines.push(lines)
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb();
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(&#39;代码执行完成，文件行数依次为：&#39;);
    console.log(fileLines)
  &#125;

  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  // 假设文件列表有3个文件，这里调用3次文件读取函数asyncFn()
  asyncFn(1, function () &#123;
    asyncFn(2, function () &#123;
      asyncFn(3, consoleResult)
    &#125;)
  &#125;)
  
  Mon Nov 30 2020 16:23:40 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 16:23:41 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 95
  Mon Nov 30 2020 16:23:42 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 88
  Mon Nov 30 2020 16:23:43 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 51
  代码执行完成，文件行数依次为：
  95,88,51
</code></pre>
<p>&emsp;&emsp;这里asyncFn()负责读取文件获取文件行数，里面使用了计时器来模拟异步操作，用随机数模拟获取的文件行数。假设文件列表只有3个文件，这里asyncFn()调用了3次，每次分别传入了一个函数，这个函数就是我们说的回调函数，在成功读取文件获得行数后立即被执行。第1个读取文件时，将读取第2个文件的任务放在了回调函数里，在第1个文件读取完成后，执行回调函数，开始了第2个文件的读取；同理，把读取第3个文件的任务放在了读取第2个文件的回调函数里，在第2个文件读取完成后，执行回调函数，第3个文件的读取开始执行。特别的，读取第3个文件的回调函数里放入了我们输出结果的函数consoleResult()，所以当第3个文件读取完成时，回调函数立即被执行，回调函数输出了依次读取到的文件行数信息。</p>
<p>&emsp;&emsp;<u>回调函数的比较好理解，就是在异步任务完成后，再继续执行后续的任务，比较容易理解与实现。但回调函数的代码是高度耦合的，执行取决于代码的结构（代码顺序），特别是多个异步任务作为回调函数嵌套执行的时候（例如上面的代码，这种现象也成‘回调地狱’），相关代码比较分散，不利于阅读和维护。</u></p>
<h4 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2) 事件监听"></a>2) 事件监听</h4><p>&emsp;&emsp;采用事件驱动的形式，任务被执行不取决于代码结构，取决于相关联的事件是否发生。</p>
<p>&emsp;&emsp;形如：</p>
<pre><code>  eventSource.on(&#39;done&#39;,fn); // eventSource对象监听done事件，并添加fn后续处理函数
  eventSource.tigger(&#39;done&#39;); // eventSource触发done事件
</code></pre>
<p>&emsp;&emsp;还是上面的示例，这里采用jQuery的自定义事件。输出结果也完全一致：</p>
<pre><code>  let times = 0;
  let fileLines = [];
  $(document).on(&#39;done&#39;, doneFn) // 给document绑定done事件，若document的done事件发生，执行doneFn()处理函数
  function doneFn(event, lines)&#123;
    console.log(new Date() + &#39; 第&#39; + times + &#39;次读取文件完成，文件总行数为 &#39; + lines);
    fileLines.push(lines)
  &#125;
  function asyncFn() &#123;
    let id = setInterval(() =&gt; &#123;
      times++;
      if (times &lt;= 3) &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
        $(document).trigger(&#39;done&#39;, lines) // 触发document done事件发生，驱动doneFn()处理函数执行
      &#125; else &#123;
        clearInterval(id)
        console.log(&#39;代码执行完成，文件行数依次为：&#39;);
        console.log(fileLines)
      &#125;
    &#125;, 1000)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  asyncFn()

  Wed May 26 2021 17:01:10 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Wed May 26 2021 17:01:11 GMT+0800 (中国标准时间) 第1次读取文件完成，文件总行数为 61
  Wed May 26 2021 17:01:12 GMT+0800 (中国标准时间) 第2次读取文件完成，文件总行数为 91
  Wed May 26 2021 17:01:13 GMT+0800 (中国标准时间) 第3次读取文件完成，文件总行数为 73
  代码执行完成，文件行数依次为：61 91 73
</code></pre>
<p>&emsp;&emsp;这里使用setInterval()来模拟3次读取文件任务，在第3次文件读取完成后清空计时器并输出结果。可以看到，在每次文件读取完成后，使用$(document).trigger(‘done’, lines)触发‘done’事件，通过事件监听器$(document).on(‘done’, doneFn)关联的doneFn()处理函数被执行。<u>其中，这里的document称为为事件源，‘done’称为为事件，‘on’称为事件监听器，doneFn()函数称为处理方法。</u></p>
<p>&emsp;&emsp;<u>事件驱动比较容易理解，就是在任务完成后继续触发后续任务的执行。可以绑定多个事件，每个事件可以指定多个回调函数，与回调函数相比，大大降低了代码的耦合度（但代码还是耦合的，绑定在同一个事件源上），有利于实现模块化。但事情驱动代码也较为分散，不利于阅读与维护。</u></p>
<h4 id="3-发布-订阅模式"><a href="#3-发布-订阅模式" class="headerlink" title="3) 发布/订阅模式"></a>3) 发布/订阅模式</h4><p>&emsp;&emsp;如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”一个信号，其他任务可以向信号中心“订阅”这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”，又称“观察者模式”。</p>
<p>&emsp;&emsp;发布/订阅模式的性质与“事件监听”类似，但功能上优于事件监听的方式。因为可以通过查看“信号中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h4 id="4-Generator-函数（ES6新增）"><a href="#4-Generator-函数（ES6新增）" class="headerlink" title="4) Generator 函数（ES6新增）"></a>4) Generator 函数（<u>ES6新增</u>）</h4><p>&emsp;&emsp;Generator 函数是一直特殊的函数，最大特点就是可以交出函数的执行权（即暂停执行）。可以把理解成，Generator 函数是一个状态机，封装了多个内部状态。Generator 函数内部使用yield表达式定义内部状态，为了与普通函数区别，一般在function关键字与函数名直接添加‘*’来标识（非必须，在函数内部使用yield的关键字这个函数就是 Generator 函数）。<u>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的迭代对象。必须调用next方法依次对状态进行迭代（恢复代码执行），内部指针就从函数头部或上一次停下来的地方开始执行（暂停执行的地方），直到遇到下一个yield关键字定义的状态时又会停止执行。每次调用next()会返回本次迭代的结果对象，其中的value属性表示当前的内部状态（结果），done属性标识整个迭代对象的迭代是否完成。</u></p>
<p>&emsp;&emsp;举个简单例子：</p>
<pre><code>  function* gen() &#123;
    console.log(new Date() + &#39; status 1&#39;);
    yield &#39;status 1&#39;;
    console.log(new Date() + &#39; status 2&#39;);
    yield &#39;status 2&#39;;
    console.log(new Date() + &#39; status 3&#39;);
    yield &#39;status 3&#39;;
    console.log(new Date() + &#39; status 4&#39;);
    yield &#39;status 4&#39;;
    console.log(new Date() + &#39; status 5&#39;);
  &#125;
  let g = gen();
  let id = setInterval(() =&gt; &#123; // 用计时器进行迭代来模拟异步操作
    if(g.next().done)&#123;
      clearInterval(id);
      console.log(&#39;状态迭代完成~&#39;);
    &#125;
  &#125;, 1000)

  输出
  Mon Nov 30 2020 21:24:24 GMT+0800 (中国标准时间) status 1
  Mon Nov 30 2020 21:24:25 GMT+0800 (中国标准时间) status 2
  Mon Nov 30 2020 21:24:26 GMT+0800 (中国标准时间) status 3
  Mon Nov 30 2020 21:24:27 GMT+0800 (中国标准时间) status 4
  Mon Nov 30 2020 21:24:28 GMT+0800 (中国标准时间) status 5
  状态迭代完成~
</code></pre>
<p>&emsp;&emsp;用Generator函数来模拟上面异步读取文件行数示例的代码：（_[注] 这种实现方式并不是最优的，结合Promise来确定每次异步操作已执行完成再进行下一次迭代操作比这里简单使用计时器模拟更为合理；使用Thunk函数或者co函数库来实现状态自动迭代的流程管理更加优雅_）：</p>
<pre><code>  let fileLines = [];
  function readFile(inx) &#123;
    let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
    fileLines.push(lines)
    console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
  &#125;
  function* asyncFn() &#123;
    yield readFile(1);
    yield readFile(2);
    readFile(3);
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  let g = asyncFn();
  let id = setInterval(() =&gt; &#123; // 模拟异步
    if(g.next().done)&#123;
      clearInterval(id)
      console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
      console.log(fileLines)
    &#125;
  &#125;, 1000)

  Wed May 26 2021 17:04:39 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:04:40 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 69
  Wed May 26 2021 17:04:41 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 57
  Wed May 26 2021 17:04:42 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 86
  Wed May 26 2021 17:04:42 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：69 57 86
</code></pre>
<p>&emsp;&emsp;<u>Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即各个状态间的管理不方便）。不过使用thunk函数或者co函数库能够解决这个问题。</u></p>
<h4 id="5-Promise（ES6新增）"><a href="#5-Promise（ES6新增）" class="headerlink" title="5) Promise（ES6新增）"></a>5) Promise（<u>ES6新增</u>）</h4><p>&emsp;&emsp;promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。一个 promise 必然处于以下几种状态之一：pending（初始状态）、fulfilled（操作成功完成）、rejected（操作失败）。</p>
<p>&emsp;&emsp;<u>处理待定状态（pending）的 Promise 对象要么会通过一个值被成功执行（fulfilled），要么会通过一个原因或错误被拒绝（rejected）。当这些情况之一发生时，promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用。Promise.prototype.then 和  Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。</u></p>
<p>&emsp;&emsp;一般我们使用Promise()构造函数来创建一个 promise 对象，以此对还没有添加 promise 支持的函数进行相应的封装使用。<u>在适当的时候，调用resolve()方法将新的promise 对象的pending状态改变为fulfilled状态，或者调用reject()将pending状态改变为rejected状态。</u>若不使用这两个静态方法，新的 promise 对象的状态仍为pending初始化状态。</p>
<p>&emsp;&emsp;<strong>Promise有一些静态方法：</strong></p>
<p>&emsp;&emsp;all()：所有promise对象都完成且都成功（fulfilled）时触发（执行then()分支），会把所有promise返回值的数组作为成功回调的返回值，顺序跟promise的顺序保持一致，任意一个promise失败（rejected）则立即触发该失败（执行catch分支），第一个触发失败的promise对象的错误信息将作为它的失败错误信息，<u>此时，其他的pending状态的promise还是会执行直至完成（promise开始执行后不能被取消）。Promise.all方法常被用于处理多个promise对象的状态集合。</u></p>
<p>&emsp;&emsp;allSettled() ：所有promise对象都完成(fulfilled/rejected)时触发（执行then()分支），返回一个promise结果对象的数组，顺序与promise的顺序保持一致。每个promise结果对象包含status属性（状态），value属性（fulfilled状态时返回值）以及reason属性（rejected状态时返回的失败原因）等属性。</p>
<p>&emsp;&emsp;any()：promise对象的集合中当其中的一个 promise 成功（fulfilled）触发，就返回那个成功的promise的值（执行then分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;race()：promise对象的集合中当其中的一个 promise 成功（fulfilled）或失败（rejected）时触发，成功就返回那个成功的promise的值（执行then分支），失败就返回那个失败promise失败的原因（执行catch分支）。此时，其他的pending状态的promise还是会执行直至完成。</p>
<p>&emsp;&emsp;reject()：返回一个失败状态的Promise对象，并将给定的失败信息传递给对应的处理方法。</p>
<p>&emsp;&emsp;resolve()：返回一个成功状态的Promise对象，其中value为返回结果。</p>
<p>&emsp;&emsp;Promise异步读取文件行数示例的代码如下：</p>
<pre><code>  let filelines =[];
  function readFile(inx) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  readFile(1).then(res =&gt; &#123;
    filelines.push(res);
    return readFile(2);
  &#125;).then(res =&gt; &#123;
    filelines.push(res);
    return readFile(3);
  &#125;).then(res =&gt; &#123;
    filelines.push(res);
    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
    console.log(filelines);
  &#125;)

  Wed May 26 2021 17:10:52 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:10:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 82
  Wed May 26 2021 17:10:54 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 90
  Wed May 26 2021 17:10:55 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 64
  Wed May 26 2021 17:10:55 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：82 90 64
</code></pre>
<p>&emsp;&emsp;<u><strong>Promise处理异步（特别是处理一次性结果）十分方便，也支持链式的进行调用，是目前较好的异步编程方式。</strong>特别是结合Array对象相关的方法如map()、filter()等。不过Promise也有一定的缺点，一但创建便会执行，不能取消，也无法得知目前进展到哪一个阶段；如果不设置回调函数，Promise内部抛出的错误，不会反应到外部等问题。</u></p>
<p>&emsp;&emsp;例如上面的Promise处理代码可以结合Array.map()方法生成promise对象集合（数组），由Promise.all()去并行执行（流程控制相关概念见后文）：</p>
<pre><code>  function readFile(inx)&#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  Promise.all([1, 2, 3].map((item) =&gt; readFile(item))).then(list =&gt; &#123;
    console.log(new Date() + &#39; 代码执行完成，文件行数依次为：&#39;);
    console.log(list)
  &#125;)

  Wed May 26 2021 17:11:46 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 97
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 69
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 75
  Wed May 26 2021 17:11:47 GMT+0800 (中国标准时间) 代码执行完成，文件行数依次为：97 69 75
</code></pre>
<p>&emsp;&emsp;这两段代码相比，可以看到后面这段代码明显更加的简洁。更重要的是，前一种写法读取3个文件的任务需要3s时间才能完成，后一种并行执行写法只需要1s时间便可完成。</p>
<h4 id="5-async-await（ES7新增）"><a href="#5-async-await（ES7新增）" class="headerlink" title="5) async/await（ES7新增）"></a>5) async/await（<u>ES7新增</u>）</h4><p>&emsp;&emsp;async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。<br>&emsp;&emsp;async 函数是 Generator 函数的语法糖且async 函数自带执行器。async函数可能包含0个或者多个await表达式。<br>&emsp;&emsp;async函数一定会返回一个promise对象。如果一个async函数的返回值不是promise，那么它将会被隐式地包装在一个promise中。</p>
<p>&emsp;&emsp;await表达式会暂停整个async函数的执行进程并出让其控制权：<br>&emsp;&emsp;(1) 如果await后面是普通表达式， await 表达式的运算结果就是它等待的的结果。<br>&emsp;&emsp;(2) 如果await后面是promise对象，只有当其等待的promise的异步操作成功或失败之后才会恢复进程，promise的结果会被当作该await表达式的返回值，此时await会阻塞后面的代码执行。<u>所以把await放在async函数内部，因为async 函数的调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</u><br>&emsp;&emsp;(3) <u>await 命令后面的 promise 运行结果如果是 rejected，此时async/await无法处理，一般要把 await 命令放在 try…catch 代码块中。</u></p>
<p>&emsp;&emsp;async/await读取文件行数示例代码：</p>
<pre><code>  function readFile(inx) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟这些文件的总行数
        console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
        resolve(lines)
      &#125;, 1000, inx)
    &#125;)
  &#125;
  async function getLines()&#123;
    let line1 = await readFile(1); // 读取文件1
    let line2 = await readFile(2); // 读取文件2
    let line3 = await readFile(3); // 读取文件3
    console.log(new Date() + &#39; 代码执行完成，结果为：&#39; + [line1, line2, line3])
  &#125;
  console.log(new Date() + &#39; 代码开始执行~&#39;);
  getLines();

  Wed May 26 2021 17:18:13 GMT+0800 (中国标准时间) 代码开始执行~
  Wed May 26 2021 17:18:14 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 72
  Wed May 26 2021 17:18:15 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 82
  Wed May 26 2021 17:18:16 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 55
  Wed May 26 2021 17:18:16 GMT+0800 (中国标准时间) 代码执行完成，结果为：72,82,55
</code></pre>
<p>&emsp;&emsp;async/await的优点：<br>&emsp;&emsp;它做到了真正的串行的同步写法，代码阅读相对容易。<br>&emsp;&emsp;对于条件语句和其他流程语句比较友好，可以将await直接写到判断条件里。<br>&emsp;&emsp;处理复杂流程时，在代码更加清晰简洁。</p>
<p>&emsp;&emsp;async/await的缺点：<br>&emsp;&emsp;<u>无法处理promise返回的reject对象，要借助try…catch…捕获异常等。</u><br>&emsp;&emsp;<strong>await只能串行，做不到并行（因为await一定是阻塞的）等。</strong></p>
<h2 id="2、异步操作流程控制"><a href="#2、异步操作流程控制" class="headerlink" title="2、异步操作流程控制"></a>2、异步操作流程控制</h2><p>&emsp;&emsp;如果有多个异步操作，为了代码的执行效率与可维护性，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。<br>&emsp;&emsp;流程控制一般有串行执行、并行执行等方式。<br>&emsp;&emsp;串行执行：一个异步任务执行完成后在执行下一个任务。（上面异步读取文件行数的示例中，除了Promise处理中的第2种写法，其他全是串行执行的）<br>&emsp;&emsp;并行执行：所有异步任务同时执行（并行非并发）。（例如上面Promise处理中的第2种写法）</p>
<p>&emsp;&emsp;例如读取文件异步操作回调函数的写法：</p>
<pre><code>  // 其他代码省略
  asyncFn(1, function () &#123;
    asyncFn(2, function () &#123;
      asyncFn(3, consoleResult)
    &#125;)
  &#125;)
</code></pre>
<p>&emsp;&emsp;这段代码虽然也是串行执行的，但多次嵌套，不利于阅读与维护。我们编写一个流程控制函数来控制异步操作串行执行，代码如下：</p>
<pre><code>  let fileList = [1, 2, 3];
  let fileLines = [];
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb(lines)
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(&#39;代码执行完成，文件行数依次为：&#39;);
    console.log(fileLines)
  &#125;
  function series(item) &#123;
    if (item) &#123;
      asyncFn(item, function (lines) &#123;
        fileLines.push(lines)
        return series(fileList.shift());
      &#125;);
    &#125; else &#123;
      return consoleResult();
    &#125;
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  series(fileList.shift());

  输出
  Mon Nov 30 2020 21:48:41 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 21:48:42 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65
  Mon Nov 30 2020 21:48:43 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 70
  Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 70
  Mon Nov 30 2020 21:48:44 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,70,70
</code></pre>
<p>&emsp;&emsp;上面的代码中，series为流程控制函数。每次读取一个文件，并将文件名从待读取文件f列表ileList中删除。再递归调用读取下一个文件，直至待读取文件列表为空则所有文件读取完成。这里串行执行读取文件完成需要3s时间。（_串行流程函数控制不止这一种方式实现_）</p>
<p>&emsp;&emsp;将流程控制改为并行执行（利用循环语句）：</p>
<pre><code>  let fileList = [1, 2, 3];
  let fileLines = [];
  function asyncFn(inx, cb) &#123;
    setTimeout(() =&gt; &#123; // 用setTimeout模拟读取文件的异步操作，假设每读取耗时1s
      let lines = Math.floor(Math.random() * 50) + 50; // 用随机数[50-100）模拟本次读取的文件的行数
      console.log(new Date() + &#39; 第&#39; + inx + &#39;读取文件完成，文件总行数为 &#39; + lines);
      cb(lines)
    &#125;, 1000)
  &#125;
  function consoleResult() &#123;
    console.log(new Date() + &#39;代码执行完成，文件行数依次为：&#39; + fileLines);
  &#125;
  function series(fileList) &#123;
    fileList.forEach((item, index) =&gt; &#123;
      asyncFn(item, function (lines) &#123;
        fileLines[index] = lines
        if (fileLines.length == fileList.length) &#123;
          consoleResult();
        &#125;
      &#125;);
    &#125;)
  &#125;
  console.log(new Date() + &#39; 代码开始执行，获取当前文件列表中文件对应的行数~&#39;);
  series(fileList);

  输出
  Mon Nov 30 2020 21:49:52 GMT+0800 (中国标准时间) 代码开始执行，获取当前文件列表中文件对应的行数~
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第1读取文件完成，文件总行数为 65
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第2读取文件完成，文件总行数为 94
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间) 第3读取文件完成，文件总行数为 57
  Mon Nov 30 2020 21:49:53 GMT+0800 (中国标准时间)代码执行完成，文件行数依次为：65,94,57
</code></pre>
<p>&emsp;&emsp;上面的代码中，series中使用forEach()方法时读取文件同时进行，因为不知道各次读取文件完成的先后顺序，这里不能使用fileLines.push()方法保存结果，可能会得的结果与文件读取顺序不匹配。这里将结果赋值给fileLines[index]能保证结果的顺序与读取文件的顺序一致。当获得的结果的长度与读取文件的次数相同时，所有文件读取完成。这里并行执行读取文件完成需要1s时间。</p>
<p><em>&emsp;&emsp;[注] 并行流程函数控制不止这一种方式实现</em></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
</search>
